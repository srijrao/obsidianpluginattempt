/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

<<<<<<< HEAD
// src/components/chat/tools/FileSearchTool.ts
var FileSearchTool;
var init_FileSearchTool = __esm({
  "src/components/chat/tools/FileSearchTool.ts"() {
    FileSearchTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_search");
        __publicField(this, "description", "Search for files in the vault by name or path");
        __publicField(this, "parameters", {
          query: {
            type: "string",
            description: "Search query to find files (searches filename and path)",
            required: false
          },
          filterType: {
            type: "string",
            enum: ["markdown", "image", "all"],
            description: "Type of files to show",
            default: "markdown"
          },
          maxResults: {
            type: "number",
            description: "Maximum number of results to return",
            default: 10
          }
        });
      }
      async execute(params, context) {
        const { query = "", filterType = "markdown", maxResults = 10 } = params;
        try {
          const allFiles = filterType === "markdown" ? this.app.vault.getMarkdownFiles() : filterType === "image" ? this.app.vault.getFiles().filter((f) => {
            var _a2;
            return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = f.extension) == null ? void 0 : _a2.toLowerCase());
          }) : this.app.vault.getFiles();
          let matchingFiles = allFiles;
          if (query.trim()) {
            const normalizedQuery = query.toLowerCase();
            const queryWords = normalizedQuery.split(/\s+/).filter((word) => word.length > 0);
            matchingFiles = [];
            for (const file of allFiles) {
              const searchText = `${file.path} ${file.basename}`.toLowerCase();
              const searchTextNormalized = searchText.replace(/_/g, " ");
              if (queryWords.every(
                (word) => searchText.includes(word) || searchTextNormalized.includes(word)
              )) {
                matchingFiles.push(file);
                if (matchingFiles.length >= maxResults) {
                  break;
                }
              }
            }
          }
          if (matchingFiles.length === 0) {
            return {
              success: false,
              error: `No files found matching query: "${query}"`
            };
          }
          const limitedFiles = matchingFiles.sort((a, b) => {
            var _a2, _b;
            return (((_a2 = b.stat) == null ? void 0 : _a2.mtime) || 0) - (((_b = a.stat) == null ? void 0 : _b.mtime) || 0);
          }).slice(0, maxResults);
          const files = limitedFiles.map((file) => {
            var _a2, _b, _c;
            return {
              path: file.path,
              name: file.name,
              basename: file.basename,
              extension: file.extension,
              size: ((_a2 = file.stat) == null ? void 0 : _a2.size) || 0,
              created: ((_b = file.stat) == null ? void 0 : _b.ctime) || 0,
              modified: ((_c = file.stat) == null ? void 0 : _c.mtime) || 0
            };
          });
          return {
            success: true,
            data: {
              files,
              count: files.length,
              query: query || "all files"
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to search files: ${error.message}`
          };
        }
      }
      getFileFilter(filterType) {
        switch (filterType) {
          case "markdown":
            return (file) => file.extension === "md";
          case "image":
            return (file) => {
              var _a2;
              return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = file.extension) == null ? void 0 : _a2.toLowerCase());
            };
          case "all":
          default:
            return () => true;
        }
      }
    };
  }
});

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "node_modules/js-yaml/dist/js-yaml.mjs"() {
    isNothing_1 = isNothing;
    isObject_1 = isObject;
    toArray_1 = toArray;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// src/components/FileHandler.ts
function getVaultItem(app, path, type2) {
  const item = app.vault.getAbstractFileByPath(path);
  if (!item) {
    return null;
  }
  if (type2 === "file" && item instanceof import_obsidian.TFile) {
    return item;
  }
  if (type2 === "folder" && item instanceof import_obsidian.TFolder) {
    return item;
  }
  return null;
}
function itemNotFoundError(path, type2) {
  return `${type2.charAt(0).toUpperCase() + type2.slice(1)} not found or is not a ${type2}: "${path}"`;
}
async function createFile(app, filePath, content = "") {
  try {
    await app.vault.create(filePath, content);
    return `Created file '${filePath}'.`;
  } catch (err) {
    return `Failed to create file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
async function readFile(app, filePath) {
  const file = getVaultItem(app, filePath, "file");
  if (!file) return itemNotFoundError(filePath, "file");
  try {
    return await app.vault.read(file);
  } catch (err) {
    return `Failed to read file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
async function writeFile(app, filePath, content) {
  const file = getVaultItem(app, filePath, "file");
  if (!file) return itemNotFoundError(filePath, "file");
  try {
    await app.vault.modify(file, content);
    return `Wrote to file '${filePath}'.`;
  } catch (err) {
    return `Failed to write file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
var import_obsidian;
var init_FileHandler = __esm({
  "src/components/FileHandler.ts"() {
    import_obsidian = require("obsidian");
    init_js_yaml();
  }
});

// src/components/chat/tools/FileReadTool.ts
var import_obsidian2, FileReadTool;
var init_FileReadTool = __esm({
  "src/components/chat/tools/FileReadTool.ts"() {
    import_obsidian2 = require("obsidian");
    init_FileHandler();
    FileReadTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_read");
        __publicField(this, "description", "Read file contents from the vault");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file to read (relative to vault root)",
            required: true
          },
          maxSize: {
            type: "number",
            description: "Maximum file size in bytes (default 1MB)",
            default: 1024 * 1024
          }
        });
      }
      async execute(params, context) {
        var _a2, _b, _c;
        const filePath = params.path || params.filePath;
        const { maxSize = 1024 * 1024 } = params;
        if (!filePath) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file && file instanceof import_obsidian2.TFile && ((_a2 = file.stat) == null ? void 0 : _a2.size) && file.stat.size > maxSize) {
            return {
              success: false,
              error: `File too large (${file.stat.size} bytes, max ${maxSize} bytes): ${filePath}`
            };
          }
          let content = await readFile(this.app, filePath);
          if (content.startsWith("File not found") || content.startsWith("Failed to read")) {
            return {
              success: false,
              error: content
            };
          }
          content = content.split("\n").map((line) => line.replace(/\s+$/g, "")).join("\n").replace(/\n{3,}/g, "\n\n").replace(/ {3,}/g, "  ").trim();
          return {
            success: true,
            data: {
              content,
              filePath,
              size: file instanceof import_obsidian2.TFile ? ((_b = file.stat) == null ? void 0 : _b.size) || 0 : 0,
              modified: file instanceof import_obsidian2.TFile ? ((_c = file.stat) == null ? void 0 : _c.mtime) || 0 : 0,
              extension: file instanceof import_obsidian2.TFile ? file.extension : void 0
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to read file: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/BackupManager.ts
var import_obsidian3, BackupManager;
var init_BackupManager = __esm({
  "src/components/BackupManager.ts"() {
    import_obsidian3 = require("obsidian");
    BackupManager = class {
      // Limit backups to prevent excessive storage
      constructor(app, pluginDataPath) {
        __publicField(this, "app");
        __publicField(this, "backupFilePath");
        __publicField(this, "maxBackupsPerFile", 10);
        this.app = app;
        this.backupFilePath = `${pluginDataPath}/backups.json`;
      }
      /**
      * Creates a backup of a file's current content before modification
      */
      async createBackup(filePath, currentContent) {
        try {
          const backupData = await this.loadBackupData();
          if (!backupData.backups[filePath]) {
            backupData.backups[filePath] = [];
          }
          const timestamp2 = Date.now();
          const readableTimestamp = new Date(timestamp2).toLocaleString();
          const backup = {
            filePath,
            content: currentContent,
            timestamp: timestamp2,
            readableTimestamp
          };
          backupData.backups[filePath].unshift(backup);
          if (backupData.backups[filePath].length > this.maxBackupsPerFile) {
            backupData.backups[filePath] = backupData.backups[filePath].slice(0, this.maxBackupsPerFile);
          }
          await this.saveBackupData(backupData);
          console.log(`[AI Assistant] Backup created for ${filePath} at ${readableTimestamp}`);
        } catch (error) {
          console.error("Failed to create backup:", error);
        }
      }
      /**
       * Gets all backups for a specific file
       */
      async getBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          return backupData.backups[filePath] || [];
        } catch (error) {
          console.error("Failed to get backups for file:", error);
          return [];
        }
      }
      /**
       * Gets all files that have backups
       */
      async getAllBackupFiles() {
        try {
          const backupData = await this.loadBackupData();
          return Object.keys(backupData.backups).filter(
            (path) => backupData.backups[path] && backupData.backups[path].length > 0
          );
        } catch (error) {
          console.error("Failed to get backup files:", error);
          return [];
        }
      }
      /**
       * Restores a backup to the vault, overwriting the current file
       */
      async restoreBackup(backup) {
        try {
          const file = this.app.vault.getAbstractFileByPath(backup.filePath);
          if (!file) {
            await this.app.vault.create(backup.filePath, backup.content);
            return { success: true };
          }
          if (!(file instanceof import_obsidian3.TFile)) {
            return { success: false, error: `Path is not a file: ${backup.filePath}` };
          }
          await this.app.vault.modify(file, backup.content);
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
      /**
       * Deletes all backups for a specific file
       */
      async deleteBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          delete backupData.backups[filePath];
          await this.saveBackupData(backupData);
        } catch (error) {
          console.error("Failed to delete backups for file:", error);
        }
      }
      /**
       * Deletes a specific backup entry
       */
      async deleteSpecificBackup(filePath, timestamp2) {
        try {
          const backupData = await this.loadBackupData();
          if (backupData.backups[filePath]) {
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp !== timestamp2
            );
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to delete specific backup:", error);
        }
      }
      /**
       * Checks if content is different from the most recent backup
       */
      async shouldCreateBackup(filePath, newContent) {
        try {
          const backups = await this.getBackupsForFile(filePath);
          if (backups.length === 0) {
            return true;
          }
          const mostRecentBackup = backups[0];
          return mostRecentBackup.content !== newContent;
        } catch (error) {
          console.error("Failed to check if backup should be created:", error);
          return true;
        }
      }
      /**
      * Loads backup data from the JSON file
      */
      async loadBackupData() {
        try {
          const adapter = this.app.vault.adapter;
          if (await adapter.exists(this.backupFilePath)) {
            const content = await adapter.read(this.backupFilePath);
            const parsed = JSON.parse(content);
            if (parsed && typeof parsed === "object" && parsed.backups) {
              return parsed;
            }
          }
        } catch (error) {
          console.error("Failed to load backup data:", error);
        }
        return { backups: {} };
      }
      /**
      * Saves backup data to the JSON file
      */
      async saveBackupData(backupData) {
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          try {
            if (!await adapter.exists(backupDir)) {
              await adapter.mkdir(backupDir);
            }
          } catch (mkdirError) {
            console.warn("Could not create backup directory:", mkdirError);
          }
          await adapter.write(this.backupFilePath, JSON.stringify(backupData, null, 2));
        } catch (error) {
          console.error("Failed to save backup data:", error);
          throw error;
        }
      }
      /**
       * Gets the total number of backups across all files
       */
      async getTotalBackupCount() {
        try {
          const backupData = await this.loadBackupData();
          return Object.values(backupData.backups).reduce((total, backups) => total + backups.length, 0);
        } catch (error) {
          console.error("Failed to get total backup count:", error);
          return 0;
        }
      }
      /**
       * Gets the total size of all backups in bytes (approximate)
       */
      async getTotalBackupSize() {
        try {
          const backupData = await this.loadBackupData();
          let totalSize = 0;
          Object.values(backupData.backups).forEach((backups) => {
            backups.forEach((backup) => {
              totalSize += backup.content.length;
            });
          });
          return totalSize;
        } catch (error) {
          console.error("Failed to get total backup size:", error);
          return 0;
        }
      }
      /**
       * Initializes the backup system by ensuring the directory exists
       */
      async initialize() {
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          if (!await adapter.exists(backupDir)) {
            await adapter.mkdir(backupDir);
            console.log("[AI Assistant] Created backup directory:", backupDir);
          }
          if (!await adapter.exists(this.backupFilePath)) {
            await this.saveBackupData({ backups: {} });
            console.log("[AI Assistant] Created backup file:", this.backupFilePath);
          }
        } catch (error) {
          console.error("Failed to initialize backup system:", error);
        }
      }
      /**
       * Cleans up old backups to prevent unlimited growth
       * Removes backups older than specified days (default: 30 days)
       */
      async cleanupOldBackups(maxDays = 30) {
        try {
          const backupData = await this.loadBackupData();
          const cutoffTime = Date.now() - maxDays * 24 * 60 * 60 * 1e3;
          let cleaned = false;
          for (const filePath in backupData.backups) {
            const originalLength = backupData.backups[filePath].length;
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp > cutoffTime
            );
            if (backupData.backups[filePath].length < originalLength) {
              cleaned = true;
              console.log(`[AI Assistant] Cleaned ${originalLength - backupData.backups[filePath].length} old backups for ${filePath}`);
            }
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
          }
          if (cleaned) {
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to cleanup old backups:", error);
        }
      }
    };
  }
});

// src/components/chat/tools/FileWriteTool.ts
var import_obsidian4, FileWriteTool;
var init_FileWriteTool = __esm({
  "src/components/chat/tools/FileWriteTool.ts"() {
    import_obsidian4 = require("obsidian");
    init_FileHandler();
    init_BackupManager();
    FileWriteTool = class {
      constructor(app, backupManager) {
        this.app = app;
        __publicField(this, "name", "file_write");
        __publicField(this, "description", "Write/modify file contents in the vault");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file to write (relative to vault root)",
            required: true
          },
          content: {
            type: "string",
            description: "Content to write to the file",
            required: true
          },
          createIfNotExists: {
            type: "boolean",
            description: "Whether to create the file if it does not exist",
            default: true
          },
          backup: {
            type: "boolean",
            description: "Whether to create a backup before modifying existing files",
            default: true
          }
        });
        __publicField(this, "backupManager");
        const defaultPath = app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
        this.backupManager = backupManager || new BackupManager(app, defaultPath);
      }
      async execute(params, context) {
        const filePath = params.path || params.filePath || params.filename;
        const { content, createIfNotExists = true, backup = true } = params;
        if (!filePath) {
          return {
            success: false,
            error: "filePath or filename parameter is required"
          };
        }
        if (content === void 0 || content === null) {
          return {
            success: false,
            error: "content parameter is required"
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            if (!createIfNotExists) {
              return {
                success: false,
                error: `File not found and createIfNotExists is false: ${filePath}`
              };
            }
            const result2 = await createFile(this.app, filePath, content);
            if (result2.startsWith("Failed to create")) {
              return {
                success: false,
                error: result2
              };
            }
            return {
              success: true,
              data: {
                action: "created",
                filePath,
                size: content.length
              }
            };
          }
          if (!(file instanceof import_obsidian4.TFile)) {
            return {
              success: false,
              error: `Path is not a file: ${filePath}`
            };
          }
          if (backup) {
            const originalContent = await this.app.vault.read(file);
            const shouldBackup = await this.backupManager.shouldCreateBackup(filePath, content);
            if (shouldBackup) {
              console.log(`[AI Assistant] Creating backup for ${filePath}`);
              await this.backupManager.createBackup(filePath, originalContent);
            } else {
              console.log(`[AI Assistant] Skipping backup for ${filePath} - content unchanged`);
            }
          }
          const result = await writeFile(this.app, filePath, content);
          if (result.startsWith("Failed to write")) {
            return {
              success: false,
              error: result
            };
          }
          return {
            success: true,
            data: {
              action: "modified",
              filePath,
              size: content.length,
              backupCreated: backup
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to write file: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/chat/filediffhandler.ts
function createSuggestionBlock(suggestionText) {
  return `\`\`\`suggestion
${suggestionText}
\`\`\``;
}
async function insertFileChangeSuggestion(vault, file, suggestionText, position) {
  const content = await vault.read(file);
  const lines = content.split("\n");
  const suggestionBlock = createSuggestionBlock(suggestionText);
  if (position !== void 0 && position >= 0 && position <= lines.length) {
    lines.splice(position, 0, suggestionBlock);
  } else {
    lines.push(suggestionBlock);
  }
  await vault.modify(file, lines.join("\n"));
}
function showFileChangeSuggestionsModal(app, suggestions) {
  new FileChangeSuggestionsModal(app, suggestions).open();
}
function formatSuggestionForDisplay(suggestionText) {
  const html = suggestionText.split("\n").map((line) => {
    if (line.startsWith("+")) return `<span class="suggestion-add">${line}</span>`;
    if (line.startsWith("-")) return `<span class="suggestion-remove">${line}</span>`;
    return line;
  }).join("<br>");
  return `<pre>${html}</pre>`;
}
var import_obsidian5, FileChangeSuggestionsModal;
var init_filediffhandler = __esm({
  "src/components/chat/filediffhandler.ts"() {
    import_obsidian5 = require("obsidian");
    FileChangeSuggestionsModal = class extends import_obsidian5.Modal {
      constructor(app, suggestions) {
        super(app);
        __publicField(this, "suggestions");
        this.suggestions = suggestions;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "File Change Suggestions" });
        this.suggestions.forEach((s) => {
          const container = contentEl.createDiv("suggestion-container");
          container.createEl("h4", { text: s.file.path });
          container.createEl("pre", { text: s.suggestionText });
          const btnRow = container.createDiv("suggestion-btn-row");
          const acceptBtn = btnRow.createEl("button", { text: "Accept" });
          const rejectBtn = btnRow.createEl("button", { text: "Reject" });
          acceptBtn.onclick = () => {
            var _a2;
            (_a2 = s.onAccept) == null ? void 0 : _a2.call(s);
            new import_obsidian5.Notice("Suggestion accepted");
            this.close();
          };
          rejectBtn.onclick = () => {
            var _a2;
            (_a2 = s.onReject) == null ? void 0 : _a2.call(s);
            new import_obsidian5.Notice("Suggestion rejected");
            this.close();
          };
        });
      }
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/tools/FileDiffTool.ts
var import_obsidian6, FileDiffTool;
var init_FileDiffTool = __esm({
  "src/components/chat/tools/FileDiffTool.ts"() {
    import_obsidian6 = require("obsidian");
    init_filediffhandler();
    FileDiffTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_diff");
        __publicField(this, "description", "Compare and suggest changes to files");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file to compare/modify (relative to vault root)",
            required: true
          },
          originalContent: {
            type: "string",
            description: "Original content for comparison (if not provided, reads from file)",
            required: false
          },
          suggestedContent: {
            type: "string",
            description: "Suggested new content for the file",
            required: true
          },
          action: {
            type: "string",
            enum: ["compare", "apply", "suggest"],
            description: "Action to perform: compare files, apply changes, or show suggestion UI",
            default: "suggest"
          },
          insertPosition: {
            type: "number",
            description: "Line number to insert suggestion at (for suggest action)",
            required: false
          }
        });
      }
      async execute(params, context) {
        const filePath = params.path || params.filePath;
        const suggestedContent = params.suggestedContent || params.text;
        const { originalContent, action = "suggest", insertPosition } = params;
        if (!filePath) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        if (!suggestedContent) {
          return {
            success: false,
            error: "suggestedContent parameter is required"
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file || !(file instanceof import_obsidian6.TFile)) {
            return {
              success: false,
              error: `File not found: ${filePath}`
            };
          }
          const currentContent = originalContent || await this.app.vault.read(file);
          switch (action) {
            case "compare":
              return this.compareFiles(currentContent, suggestedContent, filePath);
            case "apply":
              return this.applyChanges(file, suggestedContent);
            case "suggest":
            default:
              return this.showSuggestion(file, currentContent, suggestedContent, insertPosition);
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to process file diff: ${error.message}`
          };
        }
      }
      compareFiles(originalContent, suggestedContent, filePath) {
        const diff = this.generateDiff(originalContent, suggestedContent);
        return {
          success: true,
          data: {
            action: "compare",
            filePath,
            diff,
            formattedDiff: formatSuggestionForDisplay(diff),
            hasChanges: diff.length > 0
          }
        };
      }
      async applyChanges(file, suggestedContent) {
        try {
          await this.app.vault.modify(file, suggestedContent);
          return {
            success: true,
            data: {
              action: "apply",
              filePath: file.path,
              size: suggestedContent.length
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to apply changes: ${error.message}`
          };
        }
      }
      async showSuggestion(file, originalContent, suggestedContent, insertPosition) {
        const diff = this.generateDiff(originalContent, suggestedContent);
        if (diff.length === 0) {
          return {
            success: true,
            data: {
              action: "suggest",
              filePath: file.path,
              message: "No changes detected"
            }
          };
        }
        try {
          const suggestion = {
            file,
            suggestionText: diff,
            onAccept: () => {
              this.app.vault.modify(file, suggestedContent);
            },
            onReject: () => {
            }
          };
          showFileChangeSuggestionsModal(this.app, [suggestion]);
          if (insertPosition !== void 0) {
            await insertFileChangeSuggestion(this.app.vault, file, diff, insertPosition);
          }
          return {
            success: true,
            data: {
              action: "suggest",
              filePath: file.path,
              diff,
              suggestionInserted: insertPosition !== void 0
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to show suggestion: ${error.message}`
          };
        }
      }
      generateDiff(original, suggested) {
        const originalLines = original.split("\n");
        const suggestedLines = suggested.split("\n");
        const diff = [];
        const maxLines = Math.max(originalLines.length, suggestedLines.length);
        for (let i = 0; i < maxLines; i++) {
          const originalLine = originalLines[i] || "";
          const suggestedLine = suggestedLines[i] || "";
          if (originalLine !== suggestedLine) {
            if (originalLine && !suggestedLine) {
              diff.push(`-${originalLine}`);
            } else if (!originalLine && suggestedLine) {
              diff.push(`+${suggestedLine}`);
            } else if (originalLine !== suggestedLine) {
              diff.push(`-${originalLine}`);
              diff.push(`+${suggestedLine}`);
            }
          }
        }
        return diff.join("\n");
      }
    };
  }
});

// src/components/chat/tools/FileMoveTool.ts
var import_obsidian7, FileMoveTool;
var init_FileMoveTool = __esm({
  "src/components/chat/tools/FileMoveTool.ts"() {
    import_obsidian7 = require("obsidian");
    FileMoveTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_move");
        __publicField(this, "description", "Move or rename files within the vault");
        __publicField(this, "parameters", {
          sourcePath: {
            type: "string",
            description: "Path to the source file (relative to vault root)",
            required: true
          },
          destinationPath: {
            type: "string",
            description: "Destination path for the file (relative to vault root)",
            required: true
          },
          createFolders: {
            type: "boolean",
            description: "Whether to create parent folders if they don't exist",
            default: true
          },
          overwrite: {
            type: "boolean",
            description: "Whether to overwrite destination if it exists",
            default: false
          }
        });
      }
      async execute(params, context) {
        const { sourcePath, destinationPath, createFolders = true, overwrite = false } = params;
        if (!sourcePath || !destinationPath) {
          return {
            success: false,
            error: "Both sourcePath and destinationPath parameters are required"
          };
        }
        try {
          const sourceFile = this.app.vault.getAbstractFileByPath(sourcePath);
          if (!sourceFile) {
            return {
              success: false,
              error: `Source file not found: ${sourcePath}`
            };
          }
          if (!(sourceFile instanceof import_obsidian7.TFile)) {
            return {
              success: false,
              error: `Source path is not a file: ${sourcePath}`
            };
          }
          const destinationExists = this.app.vault.getAbstractFileByPath(destinationPath);
          if (destinationExists && !overwrite) {
            return {
              success: false,
              error: `Destination already exists and overwrite is not enabled: ${destinationPath}`
            };
          }
          const lastSlashIndex = destinationPath.lastIndexOf("/");
          const destinationFolder = lastSlashIndex !== -1 ? destinationPath.substring(0, lastSlashIndex) : "";
          if (destinationFolder && createFolders) {
            const folderExists = this.app.vault.getAbstractFileByPath(destinationFolder);
            if (!folderExists) {
              await this.app.vault.createFolder(destinationFolder);
            } else if (!(folderExists instanceof import_obsidian7.TFolder)) {
              return {
                success: false,
                error: `Destination parent path is not a folder: ${destinationFolder}`
              };
            }
          }
          await this.app.fileManager.renameFile(sourceFile, destinationPath);
          return {
            success: true,
            data: {
              action: "moved",
              sourcePath,
              destinationPath
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to move file: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }
    };
  }
});

// src/components/chat/tools/ThoughtTool.ts
var ThoughtCategory, ThoughtTool;
var init_ThoughtTool = __esm({
  "src/components/chat/tools/ThoughtTool.ts"() {
    ThoughtCategory = /* @__PURE__ */ ((ThoughtCategory2) => {
      ThoughtCategory2["Analysis"] = "analysis";
      ThoughtCategory2["Planning"] = "planning";
      ThoughtCategory2["ProblemSolving"] = "problem-solving";
      ThoughtCategory2["Reflection"] = "reflection";
      ThoughtCategory2["Conclusion"] = "conclusion";
      return ThoughtCategory2;
    })(ThoughtCategory || {});
    ThoughtTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "thought");
        __publicField(this, "description", "Record and display a single AI reasoning step or thought process.");
        __publicField(this, "parameters", {
          thought: {
            type: "string",
            description: "The main thought or reasoning step to record",
            required: true
          },
          step: {
            type: "number",
            description: "Current step number in a multi-step process",
            required: false
          },
          totalSteps: {
            type: "number",
            description: "Total number of steps in the process",
            required: false
          },
          category: {
            type: "string",
            enum: Object.values(ThoughtCategory),
            description: "Category of the thought for organization",
            default: "analysis" /* Analysis */
          },
          confidence: {
            type: "number",
            description: "Confidence level in this thought (1-10 scale)",
            default: 7,
            minimum: 1,
            maximum: 10
          }
        });
      }
      /**
       * Execute the tool with the given parameters.
       * @param params - ThoughtParams object (see interface for details)
       * @param context - Execution context (unused)
       * @returns ToolResult with formatted thought or error
       */
      async execute(params, context) {
        if (!params.thought || typeof params.thought !== "string" || params.thought.trim().length === 0) {
          return {
            success: false,
            error: 'Parameter "thought" is required and must be a non-empty string.'
          };
        }
        const thought = params.thought.trim();
        const step = typeof params.step === "number" && params.step > 0 ? params.step : void 0;
        const totalSteps = typeof params.totalSteps === "number" && params.totalSteps > 0 ? params.totalSteps : void 0;
        const category = Object.values(ThoughtCategory).includes(params.category) ? params.category : "analysis" /* Analysis */;
        const confidence = this.validateConfidence(params.confidence);
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const stepInfo = step && totalSteps ? `Step ${step}/${totalSteps}` : step ? `Step ${step}` : "";
        const formattedThought = this.renderThought({
          thought,
          stepInfo,
          category,
          confidence,
          timestamp: timestamp2
        });
        return {
          success: true,
          data: {
            thought,
            step,
            totalSteps,
            category,
            confidence,
            timestamp: timestamp2,
            formattedThought
          }
        };
      }
      /**
       * Render a thought in a visually distinct, concise format for MCP tool output.
       * @param opts - Rendering options
       * @returns Formatted string
       */
      renderThought(opts) {
        const { thought, stepInfo, category, confidence, timestamp: timestamp2 } = opts;
        const emoji = this.getCategoryEmoji(category);
        const confidenceBar = "\u25CF".repeat(confidence) + "\u25CB".repeat(10 - confidence);
        let header = `${emoji} **${category.replace("-", " ").toUpperCase()}**`;
        if (stepInfo) header += ` | ${stepInfo}`;
        header += ` | Confidence: ${confidence}/10 ${confidenceBar} | ${new Date(timestamp2).toLocaleTimeString()}`;
        return `${header}
> ${thought}`;
      }
      /**
       * Get an emoji for a given category.
       * @param category - ThoughtCategory
       * @returns Emoji string
       */
      getCategoryEmoji(category) {
        switch (category) {
          case "analysis" /* Analysis */:
            return "\u{1F50D}";
          case "planning" /* Planning */:
            return "\u{1F4CB}";
          case "problem-solving" /* ProblemSolving */:
            return "\u{1F9E9}";
          case "reflection" /* Reflection */:
            return "\u{1F914}";
          case "conclusion" /* Conclusion */:
            return "\u2705";
          default:
            return "\u{1F4AD}";
        }
      }
      /**
       * Ensure confidence is an integer between 1 and 10 (default 7).
       * @param confidence - number | undefined
       * @returns number
       */
      validateConfidence(confidence) {
        if (typeof confidence !== "number" || isNaN(confidence)) return 7;
        return Math.max(1, Math.min(10, Math.round(confidence)));
      }
    };
  }
});

// src/components/chat/tools/FileListTool.ts
var import_obsidian8, FileListTool;
var init_FileListTool = __esm({
  "src/components/chat/tools/FileListTool.ts"() {
    import_obsidian8 = require("obsidian");
    FileListTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_list");
        __publicField(this, "description", "List all files in a specified folder in the vault");
        __publicField(this, "parameters", {
          path: { type: "string", description: "Path to the folder (relative to vault root)", required: true },
          recursive: { type: "boolean", description: "Whether to list files recursively", default: false }
        });
      }
      async execute(params, context) {
        const folderPath = params.path || params.folderPath;
        const { recursive = false } = params;
        if (!folderPath) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        const vault = this.app.vault;
        const folder = vault.getAbstractFileByPath(folderPath);
        if (!folder || !(folder instanceof import_obsidian8.TFolder)) {
          return {
            success: false,
            error: "Folder not found: " + folderPath
          };
        }
        const filesFound = [];
        const walk = (currentFolder) => {
          for (const child of currentFolder.children) {
            if (child instanceof import_obsidian8.TFile) {
              filesFound.push(child.path);
            } else if (child instanceof import_obsidian8.TFolder && recursive) {
              walk(child);
            }
          }
        };
        try {
          walk(folder);
          return {
            success: true,
            data: { files: filesFound, count: filesFound.length, path: folderPath, recursive }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
    };
  }
});

// src/components/chat/tools/FileRenameTool.ts
var import_obsidian9, FileRenameTool;
var init_FileRenameTool = __esm({
  "src/components/chat/tools/FileRenameTool.ts"() {
    import_obsidian9 = require("obsidian");
    FileRenameTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_rename");
        __publicField(this, "description", "Rename a file within the vault (does not move directories)");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Current path to the file (relative to vault root)",
            required: true
          },
          newName: {
            type: "string",
            description: "New name for the file (not a path, just the filename)",
            required: true
          },
          overwrite: {
            type: "boolean",
            description: "Whether to overwrite if a file with the new name exists",
            default: false
          }
        });
      }
      async execute(params, context) {
        const { path, newName, newPath, overwrite = false } = params;
        const finalNewName = newName || newPath;
        if (!path || !finalNewName) {
          return {
            success: false,
            error: "Both path and newName (or newPath) parameters are required"
          };
        }
        try {
          const vault = this.app.vault;
          const file = vault.getAbstractFileByPath(path);
          if (!file || !(file instanceof import_obsidian9.TFile)) {
            return {
              success: false,
              error: "File not found: " + path
            };
          }
          const parent = file.parent;
          if (!parent) {
            return {
              success: false,
              error: "Parent folder not found for file: " + path
            };
          }
          const newPathFull = parent.path ? `${parent.path}/${finalNewName}` : finalNewName;
          if (!overwrite && vault.getAbstractFileByPath(newPathFull)) {
            return {
              success: false,
              error: "A file with the new name already exists: " + newPathFull
            };
          }
          await vault.rename(file, newPathFull);
          return {
            success: true,
            data: { oldPath: path, newPath: newPathFull }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
    };
  }
});

// src/components/chat/tools/toolcollect.ts
function getAllToolClasses() {
  const toolClasses = [
    FileSearchTool,
    FileReadTool,
    FileWriteTool,
    FileDiffTool,
    FileMoveTool,
    ThoughtTool,
    FileListTool,
    FileRenameTool
  ];
  console.log("[AI Assistant] getAllToolClasses: Checking tool classes...");
  toolClasses.forEach((tc) => {
    console.log(`[AI Assistant] Tool Class Name: ${tc.name}`);
  });
  console.log("[AI Assistant] Loading agent tools (class names):", toolClasses.map((tc) => tc.name));
  return toolClasses;
}
function getToolMetadata() {
  return [
    {
      name: "file_search",
      description: "Search for files in the vault by name or path",
      parameters: {
        query: { type: "string", description: "Search query to find files (searches filename and path)", required: false },
        filterType: { type: "string", enum: ["markdown", "image", "all"], description: "Type of files to show", default: "markdown" },
        maxResults: { type: "number", description: "Maximum number of results to return", default: 10 }
      }
    },
    {
      name: "file_read",
      description: "Read file contents from the vault",
      parameters: {
        path: { type: "string", description: "Path to the file to read (relative to vault root)", required: true },
        maxSize: { type: "number", description: "Maximum file size in bytes (default 1MB)", default: 1024 * 1024 }
      }
    },
    {
      name: "file_write",
      description: "Write or create files in the vault",
      parameters: {
        path: { type: "string", description: "Path where to write the file (relative to vault root)", required: true },
        content: { type: "string", description: "Content to write to the file", required: true },
        createIfNotExists: { type: "boolean", description: "Whether to create the file if it does not exist", default: true },
        backup: { type: "boolean", description: "Whether to create a backup before modifying existing files", default: true }
      }
    },
    {
      name: "file_diff",
      description: "Compare and suggest changes to files",
      parameters: {
        path: { type: "string", description: "Path to the file to compare/modify (relative to vault root)", required: true },
        originalContent: { type: "string", description: "Original content for comparison (if not provided, reads from file)", required: false },
        suggestedContent: { type: "string", description: "Suggested new content for the file", required: true },
        action: { type: "string", enum: ["compare", "apply", "suggest"], description: "Action to perform: compare files, apply changes, or show suggestion UI", required: false },
        insertPosition: { type: "number", description: "Position to insert suggestion (optional)", required: false }
      }
    },
    {
      name: "file_move",
      description: "Move or rename files within the vault",
      parameters: {
        sourcePath: { type: "string", description: "Path to the source file (relative to vault root)", required: true },
        destinationPath: { type: "string", description: "Destination path for the file (relative to vault root)", required: true },
        createFolders: { type: "boolean", description: "Whether to create parent folders if they don't exist", default: true },
        overwrite: { type: "boolean", description: "Whether to overwrite destination if it exists", default: false }
      }
    },
    {
      name: "thought",
      description: 'Internal reasoning and planning tool - provide either "thought" or "reasoning" parameter',
      parameters: {
        thought: { type: "string", description: "The reasoning or thought process", required: false },
        reasoning: { type: "string", description: "Alias for thought parameter (legacy support)", required: false },
        step: { type: "number", description: "Current step number in the thought process", required: false },
        totalSteps: { type: "number", description: "Total expected steps in the thought process", required: false },
        category: { type: "string", enum: ["analysis", "planning", "problem-solving", "reflection", "conclusion", "reasoning"], description: "Category of thought for better organization", default: "analysis" },
        confidence: { type: "number", description: "Confidence level (1-10 scale)", required: false },
        enableStructuredReasoning: { type: "boolean", description: "Enable structured multi-step reasoning", required: false },
        reasoningDepth: { type: "string", enum: ["shallow", "medium", "deep"], description: "Depth of reasoning: shallow, medium, or deep", required: false }
      }
    },
    {
      name: "file_list",
      description: "List all files in a specified folder in the vault",
      parameters: {
        path: { type: "string", description: "Path to the folder (relative to vault root)", required: true },
        recursive: { type: "boolean", description: "Whether to list files recursively", default: false }
      }
    },
    {
      name: "file_rename",
      description: "Rename a file within the vault (does not move directories)",
      parameters: {
        path: { type: "string", description: "Current path to the file (relative to vault root)", required: true },
        newName: { type: "string", description: "New name for the file (not a path, just the filename)", required: true },
        overwrite: { type: "boolean", description: "Whether to overwrite if a file with the new name exists", default: false }
      }
    }
  ];
}
function createToolInstances(app, plugin) {
  const toolClasses = getAllToolClasses();
  console.log("[AI Assistant] createToolInstances: Instantiating tools...");
  return toolClasses.map((ToolClass) => {
    const instance = plugin && ToolClass.name === "FileWriteTool" ? new ToolClass(app, plugin.backupManager) : new ToolClass(app);
    console.log(`[AI Assistant] Instantiated Tool instance name: ${instance.name}, from Class: ${ToolClass.name}`);
    return instance;
  });
}
var init_toolcollect = __esm({
  "src/components/chat/tools/toolcollect.ts"() {
    init_FileSearchTool();
    init_FileReadTool();
    init_FileWriteTool();
    init_FileDiffTool();
    init_FileMoveTool();
    init_ThoughtTool();
    init_FileListTool();
    init_FileRenameTool();
  }
});

// src/promptConstants.ts
var promptConstants_exports = {};
__export(promptConstants_exports, {
  AGENT_SYSTEM_PROMPT: () => AGENT_SYSTEM_PROMPT,
  AGENT_SYSTEM_PROMPT_TEMPLATE: () => AGENT_SYSTEM_PROMPT_TEMPLATE,
  DEFAULT_GENERAL_SYSTEM_PROMPT: () => DEFAULT_GENERAL_SYSTEM_PROMPT,
  DEFAULT_SUMMARY_PROMPT: () => DEFAULT_SUMMARY_PROMPT,
  DEFAULT_TITLE_PROMPT: () => DEFAULT_TITLE_PROMPT,
  DEFAULT_YAML_SYSTEM_MESSAGE: () => DEFAULT_YAML_SYSTEM_MESSAGE,
  buildAgentSystemPrompt: () => buildAgentSystemPrompt,
  getDynamicToolList: () => getDynamicToolList
});
function buildAgentSystemPrompt(enabledTools) {
  const toolList = getDynamicToolList(enabledTools);
  const toolDescriptions = toolList.map((tool, idx) => `${idx + 1}. ${tool.name} - ${tool.description}`).join("\n");
  return AGENT_SYSTEM_PROMPT_TEMPLATE.replace("{{TOOL_DESCRIPTIONS}}", toolDescriptions);
}
var DEFAULT_TITLE_PROMPT, DEFAULT_SUMMARY_PROMPT, DEFAULT_GENERAL_SYSTEM_PROMPT, getDynamicToolList, AGENT_SYSTEM_PROMPT_TEMPLATE, AGENT_SYSTEM_PROMPT, DEFAULT_YAML_SYSTEM_MESSAGE;
var init_promptConstants = __esm({
  "src/promptConstants.ts"() {
    init_toolcollect();
    DEFAULT_TITLE_PROMPT = "You are a title generator. You will give succinct titles that do not contain backslashes, forward slashes, or colons. Only generate a title as your response.";
    DEFAULT_SUMMARY_PROMPT = "Summarize the note content in 1-2 sentences, focusing on the main ideas and purpose.";
    DEFAULT_GENERAL_SYSTEM_PROMPT = "You are a helpful assistant in an Obsidian Vault.";
    getDynamicToolList = (enabledTools) => {
      const toolMetadata = getToolMetadata();
      return toolMetadata.filter((tool) => !enabledTools || enabledTools[tool.name] !== false).map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters
      }));
    };
    AGENT_SYSTEM_PROMPT_TEMPLATE = `
You are an AI assistant in an Obsidian Vault with access to powerful tools (follows MCP standard) for vault management and interaction. Try to use tools whenever possible to perform tasks. Start by thinking through a plan before executing tasks. Provide explanations, summaries, or discussions naturally. Ask clarifying questions when requests are ambiguous

Available tools:
{{TOOL_DESCRIPTIONS}}

When using tools, respond ONLY with a JSON object using these EXACT parameter names:
{
  "action": "tool_name",
  "parameters": { 
    "path": "path/to/file.md",  // - Use relative paths from vault root (e.g., "My Note.md" or "folder/My Note.md")
    /* other tool-specific parameters */
  },
  "requestId": "unique_id",
  "finished": false // - Set to true only when the entire request is fully completed
}
`;
    AGENT_SYSTEM_PROMPT = buildAgentSystemPrompt();
    DEFAULT_YAML_SYSTEM_MESSAGE = "You are an assistant that generates YAML attribute values for Obsidian notes. Read the note and generate a value for the specified YAML field. Only output the value, not the key or extra text.";
  }
});

// src/types.ts
var types_exports = {};
__export(types_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS
});
var DEFAULT_SETTINGS;
var init_types = __esm({
  "src/types.ts"() {
    init_promptConstants();
    DEFAULT_SETTINGS = {
      referenceCurrentNote: false,
      provider: "openai",
      selectedModel: void 0,
      availableModels: [],
      openaiSettings: {
        apiKey: "",
        model: "gpt-4.1",
        availableModels: []
      },
      anthropicSettings: {
        apiKey: "",
        model: "claude-3-5-sonnet-latest",
        availableModels: []
      },
      geminiSettings: {
        apiKey: "",
        model: "gemini-2.5-flash-preview-05-20",
        availableModels: []
      },
      ollamaSettings: {
        serverUrl: "http://localhost:11434",
        model: "llama2",
        availableModels: []
      },
      systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
      temperature: 0.7,
      maxTokens: 1e3,
      includeDateWithSystemMessage: false,
      includeTimeWithSystemMessage: false,
      enableStreaming: true,
      autoOpenModelSettings: false,
      enableObsidianLinks: true,
      titleOutputMode: "clipboard",
      summaryOutputMode: "clipboard",
      chatSeparator: "----",
      chatStartString: void 0,
      chatEndString: void 0,
      enableContextNotes: false,
      contextNotes: "",
      titlePrompt: DEFAULT_TITLE_PROMPT,
      summaryPrompt: DEFAULT_SUMMARY_PROMPT,
      maxSessions: 10,
      autoSaveSessions: true,
      sessions: [],
      activeSessionId: void 0,
      expandLinkedNotesRecursively: false,
      maxLinkExpansionDepth: 2,
      chatNoteFolder: "",
      // Default to vault root
      yamlAttributeGenerators: [
        {
          attributeName: "summary",
          prompt: DEFAULT_SUMMARY_PROMPT,
          outputMode: "metadata",
          commandName: "Generate YAML: summary"
        }
      ],
      providerConfigExpanded: {
        openai: false,
        anthropic: false,
        gemini: false,
        ollama: false
      },
      generalSectionsExpanded: {
        "AI Model Settings": true,
        "Date Settings": true,
        "Note Reference Settings": true,
        "Provider Configuration": true,
        // For the main group of provider configs
        "AI Model Configuration": true
      },
      modelSettingPresets: [
        {
          name: "Default",
          selectedModel: void 0,
          systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
          temperature: 0.7,
          maxTokens: 1e3,
          enableStreaming: true
        }
      ],
      agentMode: {
        enabled: false,
        maxToolCalls: 10,
        timeoutMs: 3e4
      },
      uiBehavior: {
        collapseOldReasoning: true,
        showCompletionNotifications: true,
        includeReasoningInExports: true
      },
      enabledTools: {},
      enabledModels: {}
    };
  }
});

// providers/base.ts
var ProviderErrorType, ProviderError, BaseProvider;
var init_base = __esm({
  "providers/base.ts"() {
    ProviderErrorType = /* @__PURE__ */ ((ProviderErrorType5) => {
      ProviderErrorType5["InvalidApiKey"] = "invalid_api_key";
      ProviderErrorType5["RateLimit"] = "rate_limit";
      ProviderErrorType5["InvalidRequest"] = "invalid_request";
      ProviderErrorType5["ServerError"] = "server_error";
      ProviderErrorType5["NetworkError"] = "network_error";
      return ProviderErrorType5;
    })(ProviderErrorType || {});
    ProviderError = class extends Error {
      constructor(type2, message, statusCode) {
        super(message);
        __publicField(this, "type");
        __publicField(this, "statusCode");
        this.type = type2;
        this.statusCode = statusCode;
        this.name = "ProviderError";
      }
    };
    BaseProvider = class {
      /**
       * Handle common HTTP errors
       */
      handleHttpError(error) {
        if (error instanceof Response) {
          const status2 = error.status;
          switch (status2) {
            case 401:
              throw new ProviderError(
                "invalid_api_key" /* InvalidApiKey */,
                "Invalid API key",
                status2
              );
            case 429:
              throw new ProviderError(
                "rate_limit" /* RateLimit */,
                "Rate limit exceeded",
                status2
              );
            case 400:
              throw new ProviderError(
                "invalid_request" /* InvalidRequest */,
                "Invalid request",
                status2
              );
            case 500:
            case 502:
            case 503:
            case 504:
              throw new ProviderError(
                "server_error" /* ServerError */,
                "Server error occurred",
                status2
              );
            default:
              throw new ProviderError(
                "server_error" /* ServerError */,
                `Unknown error occurred: ${status2}`,
                status2
              );
          }
        }
        if (!error.response) {
          throw new ProviderError(
            "network_error" /* NetworkError */,
            "Network error occurred"
          );
        }
        const status = error.response.status;
        switch (status) {
          case 401:
            throw new ProviderError(
              "invalid_api_key" /* InvalidApiKey */,
              "Invalid API key",
              status
            );
          case 429:
            throw new ProviderError(
              "rate_limit" /* RateLimit */,
              "Rate limit exceeded",
              status
            );
          case 400:
            throw new ProviderError(
              "invalid_request" /* InvalidRequest */,
              "Invalid request",
              status
            );
          case 500:
          case 502:
          case 503:
          case 504:
            throw new ProviderError(
              "server_error" /* ServerError */,
              "Server error occurred",
              status
            );
          default:
            throw new ProviderError(
              "server_error" /* ServerError */,
              `Unknown error occurred: ${status}`,
              status
            );
        }
      }
      /**
       * Format error message for connection test results
       */
      formatErrorMessage(error) {
        if (error instanceof ProviderError) {
          switch (error.type) {
            case "invalid_api_key" /* InvalidApiKey */:
              return "Invalid API key. Please check your credentials.";
            case "rate_limit" /* RateLimit */:
              return "Rate limit exceeded. Please try again later.";
            case "network_error" /* NetworkError */:
              return "Network error. Please check your internet connection.";
            default:
              return error.message;
          }
        }
        return error.message || "An unknown error occurred";
      }
      /**
       * Create a standard error response for connection tests
       */
      createErrorResponse(error) {
        return {
          success: false,
          message: this.formatErrorMessage(error)
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/@anthropic-ai/sdk/version.mjs"() {
    VERSION = "0.36.3";
  }
});

// node_modules/@anthropic-ai/sdk/_shims/registry.mjs
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto, kind, fetch2, Request2, Response2, Headers2, FormData2, Blob2, File2, ReadableStream2, getMultipartRequestOptions, getDefaultAgent, fileFromPath, isFsReadStream;
var init_registry = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/registry.mjs"() {
    auto = false;
    kind = void 0;
    fetch2 = void 0;
    Request2 = void 0;
    Response2 = void 0;
    Headers2 = void 0;
    FormData2 = void 0;
    Blob2 = void 0;
    File2 = void 0;
    ReadableStream2 = void 0;
    getMultipartRequestOptions = void 0;
    getDefaultAgent = void 0;
    fileFromPath = void 0;
    isFsReadStream = void 0;
  }
});

// node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs
var MultipartBody;
var init_MultipartBody = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs"() {
    MultipartBody = class {
      constructor(body) {
        this.body = body;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
var init_web_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs"() {
    init_MultipartBody();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs
var init_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs"() {
    init_web_runtime();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/index.mjs
var init_shims = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/index.mjs"() {
    init_registry();
    init_runtime();
    init_registry();
    if (!kind) setShims(getRuntime(), { auto: true });
  }
});

// node_modules/@anthropic-ai/sdk/error.mjs
var AnthropicError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm({
  "node_modules/@anthropic-ai/sdk/error.mjs"() {
    init_core();
    AnthropicError = class extends Error {
    };
    APIError = class _APIError extends AnthropicError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.request_id = headers == null ? void 0 : headers["request-id"];
        this.error = error;
      }
      static makeMessage(status, error, message) {
        const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error = errorResponse;
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message != null ? message : "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
    };
    AuthenticationError = class extends APIError {
    };
    PermissionDeniedError = class extends APIError {
    };
    NotFoundError = class extends APIError {
    };
    ConflictError = class extends APIError {
    };
    UnprocessableEntityError = class extends APIError {
    };
    RateLimitError = class extends APIError {
    };
    InternalServerError = class extends APIError {
    };
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var LineDecoder;
var init_line = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs"() {
    init_error();
    LineDecoder = class _LineDecoder {
      constructor() {
        this.buffer = [];
        this.trailingCR = false;
      }
      decode(chunk) {
        let text = this.decodeText(chunk);
        if (this.trailingCR) {
          text = "\r" + text;
          this.trailingCR = false;
        }
        if (text.endsWith("\r")) {
          this.trailingCR = true;
          text = text.slice(0, -1);
        }
        if (!text) {
          return [];
        }
        const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
        let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
        if (trailingNewline) {
          lines.pop();
        }
        if (lines.length === 1 && !trailingNewline) {
          this.buffer.push(lines[0]);
          return [];
        }
        if (this.buffer.length > 0) {
          lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
          this.buffer = [];
        }
        if (!trailingNewline) {
          this.buffer = [lines.pop() || ""];
        }
        return lines;
      }
      decodeText(bytes) {
        var _a2;
        if (bytes == null)
          return "";
        if (typeof bytes === "string")
          return bytes;
        if (typeof Buffer !== "undefined") {
          if (bytes instanceof Buffer) {
            return bytes.toString();
          }
          if (bytes instanceof Uint8Array) {
            return Buffer.from(bytes).toString();
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if (typeof TextDecoder !== "undefined") {
          if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
            (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
            return this.textDecoder.decode(bytes);
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
      }
      flush() {
        if (!this.buffer.length && !this.trailingCR) {
          return [];
        }
        const lines = [this.buffer.join("")];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
      }
    };
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  }
});

// node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_stream_utils = __esm({
  "node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
var Stream, SSEDecoder;
var init_streaming = __esm({
  "node_modules/@anthropic-ai/sdk/streaming.mjs"() {
    init_shims();
    init_error();
    init_line();
    init_stream_utils();
    init_core();
    init_error();
    Stream = class _Stream {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      static fromSSEResponse(response, controller) {
        let consumed = false;
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (sse.event === "completion") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "ping") {
                continue;
              }
              if (sse.event === "error") {
                throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
              }
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = ReadableStreamToAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller),
          new _Stream(() => teeIterator(right), this.controller)
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self = this;
        let iter;
        const encoder = new TextEncoder();
        return new ReadableStream2({
          async start() {
            iter = self[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encoder.encode(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            var _a2;
            await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/uploads.mjs
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type2 = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type2 === "string") {
      options = { ...options, type: type2 };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var isResponseLike, isFileLike, isBlobLike, getStringFromMaybeBuffer, isAsyncIterableIterator, isMultipartBody;
var init_uploads = __esm({
  "node_modules/@anthropic-ai/sdk/uploads.mjs"() {
    init_shims();
    init_shims();
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    getStringFromMaybeBuffer = (x) => {
      if (typeof x === "string")
        return x;
      if (typeof Buffer !== "undefined" && x instanceof Buffer)
        return String(x);
      return void 0;
    };
    isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  }
});

// node_modules/@anthropic-ai/sdk/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return _addRequestID(json2, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    console.log(`Anthropic:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractPage_client, APIPromise, APIClient, AbstractPage, PagePromise, createResponseHeaders, requestOptionsKeys, isRequestOptions, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, safeJSON, startsWithSchemeRegexp, isAbsoluteURL, sleep, validatePositiveInteger, castToError, readEnv, uuid4, isRunningInBrowser, isHeadersProtocol, getHeader;
var init_core = __esm({
  "node_modules/@anthropic-ai/sdk/core.mjs"() {
    init_version();
    init_streaming();
    init_error();
    init_shims();
    init_uploads();
    __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    APIPromise = class _APIPromise extends Promise {
      constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get("request-id") };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    APIClient = class {
      constructor({
        baseURL,
        maxRetries = 2,
        timeout = 6e5,
        // 10 minutes
        httpAgent,
        fetch: overriddenFetch
      }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
        this.timeout = validatePositiveInteger("timeout", timeout);
        this.httpAgent = httpAgent;
        this.fetch = overriddenFetch != null ? overriddenFetch : fetch2;
      }
      authHeaders(opts) {
        return {};
      }
      /**
       * Override this to add your own default headers, for example:
       *
       *  {
       *    ...super.defaultHeaders(),
       *    Authorization: 'Bearer 123',
       *  }
       */
      defaultHeaders(opts) {
        return {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": this.getUserAgent(),
          ...getPlatformHeaders(),
          ...this.authHeaders(opts)
        };
      }
      /**
       * Override this to add your own headers validation:
       */
      validateHeaders(headers, customHeaders) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      get(path, opts) {
        return this.methodRequest("get", path, opts);
      }
      post(path, opts) {
        return this.methodRequest("post", path, opts);
      }
      patch(path, opts) {
        return this.methodRequest("patch", path, opts);
      }
      put(path, opts) {
        return this.methodRequest("put", path, opts);
      }
      delete(path, opts) {
        return this.methodRequest("delete", path, opts);
      }
      methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then(async (opts2) => {
          const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
          return { method, path, ...opts2, body };
        }));
      }
      getAPIList(path, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path, ...opts });
      }
      calculateContentLength(body) {
        if (typeof body === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.byteLength(body, "utf8").toString();
          }
          if (typeof TextEncoder !== "undefined") {
            const encoder = new TextEncoder();
            const encoded = encoder.encode(body);
            return encoded.length.toString();
          }
        } else if (ArrayBuffer.isView(body)) {
          return body.byteLength.toString();
        }
        return null;
      }
      buildRequest(options, { retryCount = 0 } = {}) {
        var _a2, _b, _c, _d, _e, _f;
        const { method, path, query, headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path, query);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
        const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
        const minAgentTimeout = timeout + 1e3;
        if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
          httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
        const req = {
          method,
          ...body && { body },
          headers: reqHeaders,
          ...httpAgent && { agent: httpAgent },
          // @ts-ignore node-fetch uses a custom AbortSignal type that is
          // not compatible with standard web types
          signal: (_f = options.signal) != null ? _f : null
        };
        return { req, url, timeout };
      }
      buildHeaders({ options, headers, contentLength, retryCount }) {
        const reqHeaders = {};
        if (contentLength) {
          reqHeaders["content-length"] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        if (isMultipartBody(options.body) && kind !== "node") {
          delete reqHeaders["content-type"];
        }
        if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
          reqHeaders["x-stainless-retry-count"] = String(retryCount);
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      parseHeaders(headers) {
        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
      }
      async makeRequest(optionsInput, retriesRemaining) {
        var _a2, _b, _c;
        const options = await optionsInput;
        const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
        await this.prepareRequest(req, { url, options });
        debug("request", url, options, req.headers);
        if ((_b = options.signal) == null ? void 0 : _b.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
          if ((_c = options.signal) == null ? void 0 : _c.aborted) {
            throw new APIUserAbortError();
          }
          if (retriesRemaining) {
            return this.retryRequest(options, retriesRemaining);
          }
          if (response.name === "AbortError") {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
          if (retriesRemaining && this.shouldRetry(response)) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
            return this.retryRequest(options, retriesRemaining, responseHeaders);
          }
          const errText = await response.text().catch((e) => castToError(e).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
          debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
          const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
          throw err;
        }
        return { response, options, controller };
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page2);
      }
      buildURL(path, query) {
        const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      stringifyQuery(query) {
        return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key)}=`;
          }
          throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const { signal, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const fetchOptions = {
          signal: controller.signal,
          ...options
        };
        if (fetchOptions.method) {
          fetchOptions.method = fetchOptions.method.toUpperCase();
        }
        return (
          // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
          this.fetch.call(void 0, url, fetchOptions).finally(() => {
            clearTimeout(timeout);
          })
        );
      }
      shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, responseHeaders) {
        var _a2;
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
    };
    AbstractPage = class {
      constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageInfo() != null;
      }
      async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
          throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        const nextOptions = { ...this.options };
        if ("params" in nextInfo && typeof nextOptions.query === "object") {
          nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
        } else if ("url" in nextInfo) {
          const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
          for (const [key, value] of params) {
            nextInfo.url.searchParams.set(key, value);
          }
          nextOptions.query = void 0;
          nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client, request, Page2) {
        super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    createResponseHeaders = (headers) => {
      return new Proxy(Object.fromEntries(
        // @ts-ignore
        headers.entries()
      ), {
        get(target, name) {
          const key = name.toString();
          return target[key.toLowerCase()] || target[key];
        }
      });
    };
    requestOptionsKeys = {
      method: true,
      path: true,
      query: true,
      body: true,
      headers: true,
      maxRetries: true,
      stream: true,
      timeout: true,
      httpAgent: true,
      signal: true,
      idempotencyKey: true,
      __binaryRequest: true,
      __binaryResponse: true,
      __streamClass: true
    };
    isRequestOptions = (obj) => {
      return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
    };
    getPlatformProperties = () => {
      var _a2, _b;
      if (typeof Deno !== "undefined" && Deno.build != null) {
=======
// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// types.ts
var DEFAULT_SETTINGS = {
  provider: "openai",
  openaiSettings: {
    apiKey: "",
    model: "gpt-4",
    availableModels: ["gpt-4", "gpt-4-turbo-preview", "gpt-3.5-turbo"]
  },
  anthropicSettings: {
    apiKey: "",
    model: "claude-3-sonnet-20240229",
    availableModels: [
      "claude-3-opus-20240229",
      "claude-3-sonnet-20240229",
      "claude-3-haiku-20240307"
    ]
  },
  geminiSettings: {
    apiKey: "",
    model: "gemini-pro",
    availableModels: ["gemini-pro"]
  },
  ollamaSettings: {
    serverUrl: "http://localhost:11434",
    model: "llama2",
    availableModels: []
  },
  systemMessage: "You are a helpful assistant.",
  temperature: 0.7,
  maxTokens: 2e3,
  includeDateWithSystemMessage: true,
  includeTimeWithSystemMessage: false,
  enableStreaming: true,
  autoOpenModelSettings: false,
  enableObsidianLinks: true,
  enableContextNotes: false,
  contextNotes: "",
  referenceCurrentNote: false,
  chatSeparator: "----",
  debugMode: false
};

// settings.ts
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var MyPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  /**
   * Display the settings tab
   * 
   * Shows only the auto-open setting here since all other settings
   * are managed in the model settings view for better organization.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Assistant Settings" });
    containerEl.createEl("h3", { text: "API Keys" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.openaiSettings.apiKey).onChange(async (value) => {
      this.plugin.settings.openaiSettings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Anthropic API Key").setDesc("Enter your Anthropic API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.anthropicSettings.apiKey).onChange(async (value) => {
      this.plugin.settings.anthropicSettings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Google API Key").setDesc("Enter your Google API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.geminiSettings.apiKey).onChange(async (value) => {
      this.plugin.settings.geminiSettings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ollama Server URL").setDesc("Enter your Ollama server URL (default: http://localhost:11434)").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaSettings.serverUrl).onChange(async (value) => {
      this.plugin.settings.ollamaSettings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Model Settings" });
    new import_obsidian.Setting(containerEl).setName("Auto-open Model Settings").setDesc("Automatically open model settings when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoOpenModelSettings).onChange(async (value) => {
      this.plugin.settings.autoOpenModelSettings = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Open Model Settings").setDesc("Open the model settings view").addButton((button) => button.setButtonText("Open").onClick(() => {
      this.plugin.activateView();
    }));
    containerEl.createEl("h3", { text: "Debugging" });
    new import_obsidian.Setting(containerEl).setName("Enable Debug Mode").setDesc("Log detailed information to the console for debugging purposes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Chat Formatting" });
    new import_obsidian.Setting(containerEl).setName("Chat Separator").setDesc("The string used to separate chat messages.").addText((text) => {
      var _a;
      text.setPlaceholder("----").setValue((_a = this.plugin.settings.chatSeparator) != null ? _a : "").onChange(async (value) => {
        this.plugin.settings.chatSeparator = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Chat Start String").setDesc("The string that indicates where to start taking the note for context.").addText((text) => {
      var _a;
      text.setPlaceholder("===START===").setValue((_a = this.plugin.settings.chatStartString) != null ? _a : "").onChange(async (value) => {
        this.plugin.settings.chatStartString = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Chat End String").setDesc("The string that indicates where to end taking the note for context.").addText((text) => {
      var _a;
      text.setPlaceholder("===END===").setValue((_a = this.plugin.settings.chatEndString) != null ? _a : "").onChange(async (value) => {
        this.plugin.settings.chatEndString = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
function getDebugFlag() {
  return localStorage.getItem("ai_chat_debug") === "true";
}
function debug(...args) {
  if (getDebugFlag()) {
    console.log("[AI Chat Debug]", ...args);
  }
}

// utils.ts
var import_obsidian3 = require("obsidian");
var APIError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.status = status;
    this.code = code;
    this.name = "APIError";
  }
};
var APIHandler = class {
  static async fetchWithRetry(url, options, retryOptions = {}) {
    const { maxRetries, baseDelay, maxDelay } = {
      ...this.DEFAULT_OPTIONS,
      ...retryOptions
    };
    let lastError = new Error("Unknown error");
    let attempt = 0;
    while (attempt < maxRetries) {
      try {
        const response = await fetch(url, options);
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const delay = retryAfter ? parseInt(retryAfter) * 1e3 : this.calculateDelay(attempt, baseDelay, maxDelay);
          debug(`Rate limited. Retrying in ${delay}ms`);
          await this.delay(delay);
          attempt++;
          continue;
        }
        if (!response.ok) {
          const error = await this.handleErrorResponse(response);
          if (this.isRetryableError(error)) {
            const delay = this.calculateDelay(attempt, baseDelay, maxDelay);
            debug(`Request failed with ${error.status}. Retrying in ${delay}ms`);
            await this.delay(delay);
            attempt++;
            continue;
          }
          throw error;
        }
        return response;
      } catch (error) {
        lastError = error;
        if (!this.isRetryableError(error)) {
          throw error;
        }
        if (attempt < maxRetries - 1) {
          const delay = this.calculateDelay(attempt, baseDelay, maxDelay);
          debug(`Request failed. Retrying in ${delay}ms`, error);
          await this.delay(delay);
        }
        attempt++;
      }
    }
    throw lastError;
  }
  static isRetryableError(error) {
    if (error instanceof TypeError && error.message === "Failed to fetch") {
      return true;
    }
    if (error instanceof APIError && error.status === 429) {
      return true;
    }
    if (error instanceof APIError && error.status && error.status >= 500) {
      return true;
    }
    return false;
  }
  static async handleErrorResponse(response) {
    var _a, _b;
    let errorMessage = `HTTP ${response.status}`;
    let errorCode;
    try {
      const data = await response.json();
      errorMessage = ((_a = data.error) == null ? void 0 : _a.message) || data.message || errorMessage;
      errorCode = ((_b = data.error) == null ? void 0 : _b.code) || data.code;
    } catch (e) {
      errorMessage = response.statusText || errorMessage;
    }
    return new APIError(errorMessage, response.status, errorCode);
  }
  static calculateDelay(attempt, baseDelay, maxDelay) {
    const expDelay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
    const jitter = Math.random() * 0.1 * expDelay;
    return Math.round(expDelay + jitter);
  }
  static delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  static handleError(error) {
    if (error instanceof APIError) {
      new import_obsidian3.Notice(`API Error: ${error.message}`);
      debug("API Error:", error);
    } else if (error.name === "AbortError") {
      debug("Request aborted");
    } else {
      new import_obsidian3.Notice(`Error: ${error.message}`);
      debug("Unexpected error:", error);
    }
  }
};
__publicField(APIHandler, "DEFAULT_OPTIONS", {
  maxRetries: 3,
  baseDelay: 1e3,
  maxDelay: 1e4
});
var EventManager = class {
  constructor() {
    __publicField(this, "subscriptions", []);
  }
  registerWorkspaceEvent(workspace, event, callback) {
    const eventRef = workspace.on(event, callback);
    this.subscriptions.push(() => {
      workspace.offref(eventRef);
    });
  }
  addEventListener(element, event, callback) {
    element.addEventListener(event, callback);
    this.subscriptions.push(() => element.removeEventListener(event, callback));
  }
  cleanup() {
    let error;
    for (const unsubscribe of this.subscriptions) {
      try {
        unsubscribe();
      } catch (e) {
        if (!error && e instanceof Error) {
          error = e;
        }
      }
    }
    this.subscriptions = [];
    if (error) {
      throw error;
    }
  }
};
var _StreamManager = class _StreamManager {
  constructor(onWrite, onComplete, onError) {
    // 50ms flush interval
    __publicField(this, "buffer", "");
    __publicField(this, "flushTimeout", null);
    __publicField(this, "lastFlushTime", 0);
    __publicField(this, "isPaused", false);
    __publicField(this, "onWrite");
    __publicField(this, "onComplete");
    __publicField(this, "onError");
    this.onWrite = onWrite;
    this.onComplete = onComplete;
    this.onError = onError;
  }
  /**
   * Add data to the stream buffer
   */
  async write(chunk) {
    var _a;
    try {
      await this.onWrite(chunk);
    } catch (error) {
      (_a = this.onError) == null ? void 0 : _a.call(this, error instanceof Error ? error : new Error(String(error)));
    }
  }
  /**
   * Force flush the buffer
   */
  flush() {
    var _a;
    if (this.buffer && !this.isPaused) {
      const now = Date.now();
      const timeSinceLastFlush = now - this.lastFlushTime;
      if (timeSinceLastFlush < _StreamManager.FLUSH_INTERVAL) {
        this.scheduleFlush();
        return;
      }
      try {
        this.onWrite(this.buffer);
        this.buffer = "";
        this.lastFlushTime = now;
      } catch (error) {
        (_a = this.onError) == null ? void 0 : _a.call(this, error);
      }
    }
  }
  /**
   * Schedule a buffer flush
   */
  scheduleFlush() {
    if (!this.flushTimeout) {
      this.flushTimeout = setTimeout(() => {
        this.flushTimeout = null;
        this.flush();
      }, _StreamManager.FLUSH_INTERVAL);
    }
  }
  /**
   * Pause stream processing
   */
  pause() {
    this.isPaused = true;
  }
  /**
   * Resume stream processing
   */
  resume() {
    this.isPaused = false;
    if (this.buffer.length > 0) {
      this.flush();
    }
  }
  /**
   * Complete the stream
   */
  complete() {
    var _a;
    this.flush();
    if (this.flushTimeout) {
      clearTimeout(this.flushTimeout);
      this.flushTimeout = null;
    }
    (_a = this.onComplete) == null ? void 0 : _a.call(this);
  }
  /**
   * Clean up resources
   */
  destroy() {
    if (this.flushTimeout) {
      clearTimeout(this.flushTimeout);
      this.flushTimeout = null;
    }
    this.buffer = "";
  }
};
__publicField(_StreamManager, "BUFFER_SIZE", 1024);
// 1KB buffer size
__publicField(_StreamManager, "FLUSH_INTERVAL", 50);
var StreamManager = _StreamManager;

// providers/base.ts
var ProviderError = class extends Error {
  constructor(type, message, statusCode) {
    super(message);
    this.type = type;
    this.statusCode = statusCode;
    this.name = "ProviderError";
  }
};
var BaseProvider = class {
  async makeRequest(url, options) {
    return APIHandler.fetchWithRetry(url, options, {
      maxRetries: 3,
      baseDelay: 1e3,
      maxDelay: 1e4
    });
  }
  handleHttpError(response) {
    const status = response.status;
    switch (status) {
      case 401:
        return new ProviderError(
          "invalid_api_key" /* INVALID_API_KEY */,
          "Invalid API key",
          status
        );
      case 429:
        return new ProviderError(
          "rate_limit" /* RATE_LIMIT */,
          "Rate limit exceeded",
          status
        );
      case 400:
        return new ProviderError(
          "invalid_request" /* INVALID_REQUEST */,
          "Invalid request parameters",
          status
        );
      case 413:
        return new ProviderError(
          "context_length" /* CONTEXT_LENGTH */,
          "Input too long",
          status
        );
      default:
        if (status >= 500) {
          return new ProviderError(
            "server_error" /* SERVER_ERROR */,
            `Server error (${status})`,
            status
          );
        }
        return new ProviderError(
          "server_error" /* SERVER_ERROR */,
          `HTTP error ${status}`,
          status
        );
    }
  }
  validateCompletionOptions(options) {
    if (options.temperature !== void 0 && (options.temperature < 0 || options.temperature > 1)) {
      throw new ProviderError(
        "invalid_request" /* INVALID_REQUEST */,
        "Temperature must be between 0 and 1"
      );
    }
    if (options.maxTokens !== void 0 && options.maxTokens <= 0) {
      throw new ProviderError(
        "invalid_request" /* INVALID_REQUEST */,
        "Max tokens must be greater than 0"
      );
    }
  }
  /**
   * Create a standard error response for connection tests
   */
  createErrorResponse(error) {
    let message = "Connection failed: ";
    if (error instanceof ProviderError) {
      switch (error.type) {
        case "invalid_api_key" /* INVALID_API_KEY */:
          message += "Invalid API key. Please check your credentials.";
          break;
        case "rate_limit" /* RATE_LIMIT */:
          message += "Rate limit exceeded. Please try again later.";
          break;
        case "network_error" /* NETWORK_ERROR */:
          message += "Network error. Please check your internet connection.";
          break;
        default:
          message += error.message;
          break;
      }
    } else if (error instanceof APIError) {
      message += error.message;
    } else if (error instanceof Error) {
      message += error.message;
    } else {
      message += "Unknown error occurred";
    }
    return {
      success: false,
      message
    };
  }
  createStreamManager(options) {
    if (!options.streamCallback) return void 0;
    return new StreamManager(
      options.streamCallback,
      void 0,
      (error) => {
        debug("Stream error:", error);
      }
    );
  }
  logRequestStart(method, endpoint) {
    debug(`${method} ${endpoint} - Request started`);
  }
  logRequestEnd(method, endpoint, duration) {
    debug(`${method} ${endpoint} - Request completed in ${duration}ms`);
  }
  logError(error) {
    if (error instanceof ProviderError) {
      debug(`Provider error: ${error.type} - ${error.message}`);
    } else {
      debug("Unexpected error:", error);
    }
  }
};

// providers/anthropic.ts
var AnthropicProvider = class extends BaseProvider {
  constructor(apiKey, model = "claude-3-sonnet-20240229") {
    super();
    __publicField(this, "apiKey");
    __publicField(this, "baseUrl", "https://api.anthropic.com/v1");
    __publicField(this, "model");
    this.apiKey = apiKey;
    this.model = model;
  }
  /**
   * Get a completion from Anthropic
   * 
   * Sends the conversation to Anthropic and streams back the response.
   * 
   * @param messages - The conversation history
   * @param options - Settings for this completion
   */
  async getCompletion(messages, options) {
    var _a, _b, _c, _d, _e, _f;
    this.validateCompletionOptions(options);
    const streamManager = this.createStreamManager(options);
    try {
      this.logRequestStart("POST", "/messages");
      const startTime = Date.now();
      const url = `${this.baseUrl}/messages`;
      const headers = {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      };
      const formattedMessages = this.formatMessages(messages);
      const body = {
        model: this.model,
        messages: formattedMessages,
        max_tokens: (_a = options.maxTokens) != null ? _a : 2e3,
        temperature: (_b = options.temperature) != null ? _b : 0.7,
        stream: Boolean(options.streamCallback)
      };
      if (options.streamCallback) {
        const response = await this.makeRequest(url, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
          signal: (_c = options.abortController) == null ? void 0 : _c.signal
        });
        const reader = (_d = response.body) == null ? void 0 : _d.getReader();
        if (!reader) {
          throw new ProviderError(
            "server_error" /* SERVER_ERROR */,
            "Failed to get response stream"
          );
        }
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const json = JSON.parse(data);
                if (json.type === "content_block_delta" && ((_e = json.delta) == null ? void 0 : _e.text)) {
                  streamManager == null ? void 0 : streamManager.write(json.delta.text);
                }
              } catch (e) {
                debug("Error parsing Anthropic response chunk:", e);
              }
            }
          }
        }
        streamManager == null ? void 0 : streamManager.complete();
      } else {
        const response = await this.makeRequest(url, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
          signal: (_f = options.abortController) == null ? void 0 : _f.signal
        });
        const data = await response.json();
        let content = "";
        if (data.content && data.content.length > 0) {
          content = data.content.map((block) => block.type === "text" ? block.text : "").join("");
        }
        if (streamManager) {
          streamManager.write(content);
          streamManager.complete();
        }
      }
      this.logRequestEnd("POST", "/messages", Date.now() - startTime);
    } catch (error) {
      if (error instanceof ProviderError) {
        throw error;
      }
      if (error.name === "AbortError") {
        debug("Anthropic stream was aborted");
        streamManager == null ? void 0 : streamManager.destroy();
      } else {
        this.logError(error);
        throw new ProviderError(
          "server_error" /* SERVER_ERROR */,
          `Error calling Anthropic: ${error.message}`
        );
      }
    }
  }
  /**
   * Format messages for Anthropic's API
   * 
   * @param messages Array of message objects
   * @returns Formatted messages for Anthropic API
   */
  formatMessages(messages) {
    const result = [];
    const systemMessages = messages.filter((msg) => msg.role === "system");
    if (systemMessages.length > 0) {
      result.push({
        role: "system",
        content: systemMessages.map((msg) => msg.content).join("\n\n")
      });
    }
    const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
    result.push(...nonSystemMessages.map((msg) => ({
      role: msg.role,
      content: msg.content
    })));
    return result;
  }
  /**
   * Get available Anthropic models
   * 
   * Returns the list of Claude models.
   * 
   * @returns List of available model names
   */
  async getAvailableModels() {
    return [
      "claude-3-opus-20240229",
      "claude-3-sonnet-20240229",
      "claude-3-haiku-20240307"
    ];
  }
  /**
   * Test connection to Anthropic
   * 
   * Verifies the API key works by attempting a simple completion.
   * 
   * @returns Test results including success/failure
   */
  async testConnection() {
    try {
      const url = `${this.baseUrl}/messages`;
      const headers = {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      };
      const body = {
        model: this.model,
        messages: [{ role: "user", content: "Hello!" }],
        max_tokens: 1
      };
      const response = await this.makeRequest(url, {
        method: "POST",
        headers,
        body: JSON.stringify(body)
      });
      const models = await this.getAvailableModels();
      return {
        success: true,
        message: "Successfully connected to Anthropic Claude!",
        models
      };
    } catch (error) {
      return this.createErrorResponse(error);
    }
  }
};

// providers/openai.ts
var OpenAIProvider = class extends BaseProvider {
  constructor(apiKey, model = "gpt-4") {
    super();
    __publicField(this, "apiKey");
    __publicField(this, "baseUrl", "https://api.openai.com/v1");
    __publicField(this, "model");
    this.apiKey = apiKey;
    this.model = model;
  }
  /**
   * Get a completion from OpenAI
   * 
   * Sends the conversation to OpenAI and streams back the response.
   * 
   * @param messages - The conversation history
   * @param options - Settings for this completion
   */
  async getCompletion(messages, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.validateCompletionOptions(options);
    const streamManager = this.createStreamManager(options);
    try {
      this.logRequestStart("POST", "/chat/completions");
      const startTime = Date.now();
      const url = `${this.baseUrl}/chat/completions`;
      const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`
      };
      const body = {
        model: this.model,
        messages,
        temperature: (_a = options.temperature) != null ? _a : 0.7,
        max_tokens: options.maxTokens,
        stream: Boolean(options.streamCallback)
      };
      if (options.streamCallback) {
        const response = await this.makeRequest(url, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
          signal: (_b = options.abortController) == null ? void 0 : _b.signal
        });
        const reader = (_c = response.body) == null ? void 0 : _c.getReader();
        if (!reader) {
          throw new ProviderError(
            "server_error" /* SERVER_ERROR */,
            "Failed to get response stream"
          );
        }
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const json = JSON.parse(data);
                const content = (_f = (_e = (_d = json.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.content;
                if (content) {
                  streamManager == null ? void 0 : streamManager.write(content);
                }
              } catch (e) {
                debug("Error parsing OpenAI response chunk:", e);
              }
            }
          }
        }
        streamManager == null ? void 0 : streamManager.complete();
      } else {
        const response = await this.makeRequest(url, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
          signal: (_g = options.abortController) == null ? void 0 : _g.signal
        });
        const data = await response.json();
        if (data.choices && data.choices[0] && data.choices[0].message) {
          const content = data.choices[0].message.content;
          if (content && streamManager) {
            streamManager.write(content);
            streamManager.complete();
          }
        }
      }
      this.logRequestEnd("POST", "/chat/completions", Date.now() - startTime);
    } catch (error) {
      if (error instanceof ProviderError) {
        throw error;
      }
      if (error.name === "AbortError") {
        debug("OpenAI stream was aborted");
        streamManager == null ? void 0 : streamManager.destroy();
      } else {
        this.logError(error);
        throw new ProviderError(
          "server_error" /* SERVER_ERROR */,
          `Error calling OpenAI: ${error.message}`
        );
      }
    }
  }
  /**
   * Get available OpenAI models
   * 
   * Fetches the list of available models from OpenAI's API.
   * Filters to only include GPT models.
   * 
   * @returns List of available model names
   */
  async getAvailableModels() {
    try {
      this.logRequestStart("GET", "/models");
      const startTime = Date.now();
      const response = await this.makeRequest(`${this.baseUrl}/models`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        }
      });
      const data = await response.json();
      this.logRequestEnd("GET", "/models", Date.now() - startTime);
      return data.data.map((model) => model.id).filter((id) => id.includes("gpt-4") || id.includes("gpt-3.5") || id.includes("gpt-4o"));
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }
  /**
   * Test connection to OpenAI
   * 
   * Verifies the API key works by attempting to list models.
   * 
   * @returns Test results including success/failure and available models
   */
  async testConnection() {
    try {
      const models = await this.getAvailableModels();
      return {
        success: true,
        message: `Successfully connected to OpenAI! Found ${models.length} available models.`,
        models
      };
    } catch (error) {
      return this.createErrorResponse(error);
    }
  }
};

// providers/gemini.ts
var GeminiProvider = class extends BaseProvider {
  constructor(apiKey, model = "gemini-pro") {
    super();
    __publicField(this, "apiKey");
    __publicField(this, "baseUrl", "https://generativelanguage.googleapis.com/v1");
    __publicField(this, "model");
    this.apiKey = apiKey;
    this.model = model;
  }
  /**
   * Get a completion from Google Gemini
   * 
   * Sends the conversation to Gemini and streams back the response.
   * 
   * @param messages - The conversation history
   * @param options - Settings for this completion
   */
  async getCompletion(messages, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    this.validateCompletionOptions(options);
    const streamManager = this.createStreamManager(options);
    try {
      const formattedMessages = this.formatMessages(messages);
      const isStreaming = Boolean(options.streamCallback);
      if (isStreaming) {
        this.logRequestStart("POST", `/models/${this.model}:streamGenerateContent`);
        const startTime = Date.now();
        const url = `${this.baseUrl}/models/${this.model}:streamGenerateContent?key=${this.apiKey}`;
        const response = await this.makeRequest(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents: formattedMessages,
            generationConfig: {
              temperature: (_a = options.temperature) != null ? _a : 0.7,
              maxOutputTokens: (_b = options.maxTokens) != null ? _b : 1e3
            },
            safetySettings: [
              {
                category: "HARM_CATEGORY_HARASSMENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_HATE_SPEECH",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              }
            ]
          }),
          signal: (_c = options.abortController) == null ? void 0 : _c.signal
        });
        const reader = (_d = response.body) == null ? void 0 : _d.getReader();
        if (!reader) {
          throw new ProviderError(
            "server_error" /* SERVER_ERROR */,
            "Failed to get response stream"
          );
        }
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.trim() && !line.startsWith("[")) {
              try {
                const data = JSON.parse(line);
                const text = (_i = (_h = (_g = (_f = (_e = data.candidates) == null ? void 0 : _e[0]) == null ? void 0 : _f.content) == null ? void 0 : _g.parts) == null ? void 0 : _h[0]) == null ? void 0 : _i.text;
                if (text && streamManager) {
                  streamManager.write(text);
                }
              } catch (e) {
                debug("Error parsing Gemini response chunk:", e);
              }
            }
          }
        }
        streamManager == null ? void 0 : streamManager.complete();
        this.logRequestEnd("POST", `/models/${this.model}:streamGenerateContent`, Date.now() - startTime);
      } else {
        this.logRequestStart("POST", `/models/${this.model}:generateContent`);
        const startTime = Date.now();
        const url = `${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;
        const response = await this.makeRequest(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents: formattedMessages,
            generationConfig: {
              temperature: (_j = options.temperature) != null ? _j : 0.7,
              maxOutputTokens: (_k = options.maxTokens) != null ? _k : 1e3
            }
          }),
          signal: (_l = options.abortController) == null ? void 0 : _l.signal
        });
        const data = await response.json();
        const content = ((_q = (_p = (_o = (_n = (_m = data.candidates) == null ? void 0 : _m[0]) == null ? void 0 : _n.content) == null ? void 0 : _o.parts) == null ? void 0 : _p[0]) == null ? void 0 : _q.text) || "";
        if (options.streamCallback) {
          options.streamCallback(content);
        }
        this.logRequestEnd("POST", `/models/${this.model}:generateContent`, Date.now() - startTime);
      }
    } catch (error) {
      if (error instanceof ProviderError) {
        throw error;
      }
      if (error.name === "AbortError") {
        debug("Gemini stream was aborted");
        streamManager == null ? void 0 : streamManager.destroy();
      } else {
        this.logError(error);
        throw new ProviderError(
          "server_error" /* SERVER_ERROR */,
          `Error calling Gemini: ${error.message}`
        );
      }
    }
  }
  /**
   * Get available Gemini models
   * 
   * Fetches the list of available models from Google's API.
   * Filters to only include Gemini models.
   * 
   * @returns List of available model names
   */
  async getAvailableModels() {
    try {
      this.logRequestStart("GET", "/models");
      const startTime = Date.now();
      const response = await this.makeRequest(`${this.baseUrl}/models?key=${this.apiKey}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      const data = await response.json();
      this.logRequestEnd("GET", "/models", Date.now() - startTime);
      return data.models.map((model) => model.name.split("/").pop()).filter((id) => id.startsWith("gemini-"));
    } catch (error) {
      console.error("Error fetching Gemini models:", error);
      throw error;
    }
  }
  /**
   * Test connection to Gemini
   * 
   * Verifies the API key works by attempting to list models.
   * 
   * @returns Test results including success/failure and available models
   */
  async testConnection() {
    try {
      const models = await this.getAvailableModels();
      return {
        success: true,
        message: `Successfully connected to Google Gemini! Found ${models.length} available models.`,
        models
      };
    } catch (error) {
      return this.createErrorResponse(error);
    }
  }
  /**
   * Format messages for Gemini API
   * 
   * Converts from the plugin's Message format to Gemini's expected format.
   * 
   * @param messages - Array of messages to format
   * @returns Formatted messages for Gemini API
   */
  formatMessages(messages) {
    const formattedMessages = [];
    let currentRole = null;
    let content = { parts: [{ text: "" }] };
    for (const message of messages) {
      const role = message.role === "system" ? "user" : message.role;
      if (role !== currentRole && currentRole !== null) {
        formattedMessages.push({
          role: currentRole,
          parts: [{ text: content.parts[0].text }]
        });
        content = { parts: [{ text: message.content }] };
      } else {
        content.parts[0].text += (content.parts[0].text ? "\n\n" : "") + message.content;
      }
      currentRole = role;
    }
    if (currentRole !== null) {
      formattedMessages.push({
        role: currentRole,
        parts: [{ text: content.parts[0].text }]
      });
    }
    return formattedMessages;
  }
};

// providers/ollama.ts
var OllamaProvider = class extends BaseProvider {
  constructor(serverUrl = "http://localhost:11434", model = "llama2") {
    super();
    __publicField(this, "apiKey", "");
    // Ollama doesn't use API keys
    __publicField(this, "baseUrl");
    __publicField(this, "model");
    this.baseUrl = serverUrl;
    this.model = model;
  }
  /**
   * Get a completion from Ollama
   *
   * Sends the conversation to the local Ollama server and streams back the response.
   *
   * @param messages - The conversation history
   * @param options - Settings for this completion
   */
  async getCompletion(messages, options) {
    var _a, _b, _c, _d, _e;
    this.validateCompletionOptions(options);
    const streamManager = this.createStreamManager(options);
    try {
      this.logRequestStart("POST", "/api/generate");
      const startTime = Date.now();
      const formattedPrompt = this.formatMessages(messages);
      const url = `${this.baseUrl}/api/generate`;
      const response = await this.makeRequest(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.model,
          prompt: formattedPrompt,
          stream: Boolean(options.streamCallback),
          options: {
            temperature: (_a = options.temperature) != null ? _a : 0.7,
            num_predict: (_b = options.maxTokens) != null ? _b : 2e3
          }
        }),
        signal: (_c = options.abortController) == null ? void 0 : _c.signal
      });
      if (options.streamCallback && streamManager) {
        const reader = (_d = response.body) == null ? void 0 : _d.getReader();
        if (!reader) {
          throw new ProviderError(
            "server_error" /* SERVER_ERROR */,
            "Failed to get response stream"
          );
        }
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.trim()) {
              try {
                const data = JSON.parse(line);
                if (data.response) {
                  streamManager.write(data.response);
                }
                if (data.done) {
                  streamManager.complete();
                }
              } catch (e) {
                debug("Error parsing Ollama response chunk:", e);
              }
            }
          }
        }
      } else {
        const data = await response.json();
        if (options.streamCallback && data.response) {
          options.streamCallback(data.response);
        }
      }
      this.logRequestEnd("POST", "/api/generate", Date.now() - startTime);
    } catch (error) {
      if (error instanceof ProviderError) {
        throw error;
      }
      if (error.name === "AbortError") {
        debug("Ollama stream was aborted");
        streamManager == null ? void 0 : streamManager.destroy();
      } else {
        const errorMessage = ((_e = error.message) == null ? void 0 : _e.includes("fetch")) ? "Could not connect to Ollama server. Make sure Ollama is installed and running." : `Error calling Ollama: ${error.message}`;
        this.logError(error);
        throw new ProviderError(
          "server_error" /* SERVER_ERROR */,
          errorMessage
        );
      }
    }
  }
  /**
   * Get available Ollama models
   *
   * Fetches the list of models installed on the local Ollama server.
   *
   * @returns List of available model names
   */
  async getAvailableModels() {
    try {
      this.logRequestStart("GET", "/api/tags");
      const startTime = Date.now();
      const response = await this.makeRequest(`${this.baseUrl}/api/tags`, {
        method: "GET"
      });
      const data = await response.json();
      this.logRequestEnd("GET", "/api/tags", Date.now() - startTime);
      return data.models.map((model) => model.name);
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }
  /**
   * Test connection to Ollama
   *
   * Verifies the Ollama server is running and accessible.
   * Also checks if any models are installed.
   *
   * @returns Test results including success/failure and available models
   */
  async testConnection() {
    try {
      const models = await this.getAvailableModels();
      if (models.length === 0) {
>>>>>>> main
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(process.platform),
          "X-Stainless-Arch": normalizeArch(process.arch),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
<<<<<<< HEAD
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
    };
    safeJSON = (text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    };
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    validatePositiveInteger = (name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new AnthropicError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new AnthropicError(`${name} must be a positive integer`);
      }
      return n;
    };
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          return new Error(JSON.stringify(err));
        } catch (e) {
        }
      }
      return new Error(String(err));
    };
    readEnv = (env) => {
      var _a2, _b, _c, _d, _e, _f;
      if (typeof process !== "undefined") {
        return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
      }
      if (typeof Deno !== "undefined") {
        return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
      }
      return void 0;
    };
    uuid4 = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
    isHeadersProtocol = (headers) => {
      return typeof (headers == null ? void 0 : headers.get) === "function";
    };
    getHeader = (headers, header) => {
      var _a2;
      const lowerCasedHeader = header.toLowerCase();
      if (isHeadersProtocol(headers)) {
        const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
          const value = headers.get(key);
          if (value) {
            return value;
          }
        }
      }
      for (const [key, value] of Object.entries(headers)) {
        if (key.toLowerCase() === lowerCasedHeader) {
          if (Array.isArray(value)) {
            if (value.length <= 1)
              return value[0];
            console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
            return value[0];
          }
          return value;
        }
      }
      return void 0;
    };
  }
});

// node_modules/@anthropic-ai/sdk/pagination.mjs
var Page;
var init_pagination = __esm({
  "node_modules/@anthropic-ai/sdk/pagination.mjs"() {
    init_core();
    Page = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.first_id = body.first_id || null;
        this.last_id = body.last_id || null;
      }
      getPaginatedItems() {
        var _a2;
        return (_a2 = this.data) != null ? _a2 : [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        var _a2;
        if ((_a2 = this.options.query) == null ? void 0 : _a2["before_id"]) {
          const firstId = this.first_id;
          if (!firstId) {
            return null;
          }
          return {
            params: {
              before_id: firstId
            }
          };
        }
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          params: {
            after_id: cursor
          }
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/shared.mjs
var init_shared = __esm({
  "node_modules/@anthropic-ai/sdk/resources/shared.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/@anthropic-ai/sdk/resource.mjs"() {
    APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models, BetaModelInfosPage;
var init_models = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}?beta=true`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models?beta=true", BetaModelInfosPage, { query, ...options });
      }
    };
    BetaModelInfosPage = class extends Page {
    };
    Models.BetaModelInfosPage = BetaModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder;
var init_jsonl = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs"() {
    init_error();
    init_stream_utils();
    init_line();
    JSONLDecoder = class _JSONLDecoder {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      async *decoder() {
        const lineDecoder = new LineDecoder();
        for await (const chunk of this.iterator) {
          for (const line of lineDecoder.decode(chunk)) {
            yield JSON.parse(line);
          }
        }
        for (const line of lineDecoder.flush()) {
          yield JSON.parse(line);
        }
      }
      [Symbol.asyncIterator]() {
        return this.decoder();
      }
      static fromResponse(response, controller) {
        if (!response.body) {
          controller.abort();
          throw new AnthropicError(`Attempted to iterate over a response with no body`);
        }
        return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches, BetaMessageBatchesPage;
var init_batches = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/batches?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      retrieve(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.retrieve(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { betas, ...query } = params;
        return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
          query,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      delete(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      cancel(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.cancel(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      async results(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.results(messageBatchId, {}, params);
        }
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        const { betas } = params;
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    BetaMessageBatchesPage = class extends Page {
    };
    Batches.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize, strip, unstrip, generate, partialParse;
var init_parser = __esm({
  "node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs"() {
    tokenize = (input) => {
      let current = 0;
      let tokens = [];
      while (current < input.length) {
        let char = input[current];
        if (char === "\\") {
          current++;
          continue;
        }
        if (char === "{") {
          tokens.push({
            type: "brace",
            value: "{"
          });
          current++;
          continue;
        }
        if (char === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
          current++;
          continue;
        }
        if (char === "[") {
          tokens.push({
            type: "paren",
            value: "["
          });
          current++;
          continue;
        }
        if (char === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
          current++;
          continue;
        }
        if (char === ":") {
          tokens.push({
            type: "separator",
            value: ":"
          });
          current++;
          continue;
        }
        if (char === ",") {
          tokens.push({
            type: "delimiter",
            value: ","
          });
          current++;
          continue;
        }
        if (char === '"') {
          let value = "";
          let danglingQuote = false;
          char = input[++current];
          while (char !== '"') {
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            if (char === "\\") {
              current++;
              if (current === input.length) {
                danglingQuote = true;
                break;
              }
              value += char + input[current];
              char = input[++current];
            } else {
              value += char;
              char = input[++current];
            }
          }
          char = input[++current];
          if (!danglingQuote) {
            tokens.push({
              type: "string",
              value
            });
          }
          continue;
        }
        let WHITESPACE = /\s/;
        if (char && WHITESPACE.test(char)) {
          current++;
          continue;
        }
        let NUMBERS = /[0-9]/;
        if (char && NUMBERS.test(char) || char === "-" || char === ".") {
          let value = "";
          if (char === "-") {
            value += char;
            char = input[++current];
          }
          while (char && NUMBERS.test(char) || char === ".") {
            value += char;
            char = input[++current];
          }
          tokens.push({
            type: "number",
            value
          });
          continue;
        }
        let LETTERS = /[a-z]/i;
        if (char && LETTERS.test(char)) {
          let value = "";
          while (char && LETTERS.test(char)) {
            if (current === input.length) {
              break;
            }
            value += char;
            char = input[++current];
          }
          if (value == "true" || value == "false" || value === "null") {
            tokens.push({
              type: "name",
              value
            });
          } else {
            current++;
            continue;
          }
          continue;
        }
        current++;
      }
      return tokens;
    };
    strip = (tokens) => {
      if (tokens.length === 0) {
        return tokens;
      }
      let lastToken = tokens[tokens.length - 1];
      switch (lastToken.type) {
        case "separator":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
        case "number":
          let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
          if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
        case "string":
          let tokenBeforeTheLastToken = tokens[tokens.length - 2];
          if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
          break;
        case "delimiter":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
      }
      return tokens;
    };
    unstrip = (tokens) => {
      let tail = [];
      tokens.map((token) => {
        if (token.type === "brace") {
          if (token.value === "{") {
            tail.push("}");
          } else {
            tail.splice(tail.lastIndexOf("}"), 1);
          }
        }
        if (token.type === "paren") {
          if (token.value === "[") {
            tail.push("]");
          } else {
            tail.splice(tail.lastIndexOf("]"), 1);
          }
        }
      });
      if (tail.length > 0) {
        tail.reverse().map((item) => {
          if (item === "}") {
            tokens.push({
              type: "brace",
              value: "}"
            });
          } else if (item === "]") {
            tokens.push({
              type: "paren",
              value: "]"
            });
          }
        });
      }
      return tokens;
    };
    generate = (tokens) => {
      let output = "";
      tokens.map((token) => {
        switch (token.type) {
          case "string":
            output += '"' + token.value + '"';
            break;
          default:
            output += token.value;
            break;
        }
      });
      return output;
    };
    partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  }
});

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
function checkNever(x) {
}
var __classPrivateFieldSet2, __classPrivateFieldGet2, _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage, JSON_BUF_PROPERTY, BetaMessageStream;
var init_BetaMessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY = "__json_buf";
    BetaMessageStream = class _BetaMessageStream {
      constructor() {
        _BetaMessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _BetaMessageStream_connectedPromise.set(this, void 0);
        _BetaMessageStream_resolveConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_rejectConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_endPromise.set(this, void 0);
        _BetaMessageStream_resolveEndPromise.set(this, () => {
        });
        _BetaMessageStream_rejectEndPromise.set(this, () => {
        });
        _BetaMessageStream_listeners.set(this, {});
        _BetaMessageStream_ended.set(this, false);
        _BetaMessageStream_errored.set(this, false);
        _BetaMessageStream_aborted.set(this, false);
        _BetaMessageStream_catchingPromiseCreated.set(this, false);
        _BetaMessageStream_response.set(this, void 0);
        _BetaMessageStream_request_id.set(this, void 0);
        _BetaMessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet2(this, _BetaMessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet2(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _BetaMessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _BetaMessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_response, response, "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet2(this, _BetaMessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet2(this, _BetaMessageStream_ended, true, "f");
          __classPrivateFieldGet2(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
      }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS, Messages;
var init_messages = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs"() {
    init_resource();
    init_batches();
    init_batches();
    init_BetaMessageStream();
    DEPRECATED_MODELS = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches(this._client);
      }
      create(params, options) {
        var _a2, _b;
        const { betas, ...body } = params;
        if (body.model in DEPRECATED_MODELS) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages?beta=true", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          headers: {
            ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0,
            ...options == null ? void 0 : options.headers
          },
          stream: (_b = params.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return BetaMessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/count_tokens?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "token-counting-2024-11-01"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
    };
    Messages.Batches = Batches;
    Messages.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs"() {
    init_resource();
    init_models();
    init_models();
    init_messages();
    init_messages();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.models = new Models(this._client);
        this.messages = new Messages(this._client);
      }
    };
    Beta.Models = Models;
    Beta.BetaModelInfosPage = BetaModelInfosPage;
    Beta.Messages = Messages;
  }
});

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions;
var init_completions = __esm({
  "node_modules/@anthropic-ai/sdk/resources/completions.mjs"() {
    init_resource();
    Completions = class extends APIResource {
      create(body, options) {
        var _a2, _b;
        return this._client.post("/v1/complete", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2, MessageBatchesPage;
var init_batches2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches2 = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(body, options) {
        return this._client.post("/v1/messages/batches", { body, ...options });
      }
      /**
       * This endpoint is idempotent and can be used to poll for Message Batch
       * completion. To access the results of a Message Batch, make a request to the
       * `results_url` field in the response.
       */
      retrieve(messageBatchId, options) {
        return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/messages/batches", MessageBatchesPage, { query, ...options });
      }
      /**
       * Delete a Message Batch.
       *
       * Message Batches can only be deleted once they've finished processing. If you'd
       * like to delete an in-progress batch, you must first cancel it.
       */
      delete(messageBatchId, options) {
        return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);
      }
      /**
       * Batches may be canceled any time before processing ends. Once cancellation is
       * initiated, the batch enters a `canceling` state, at which time the system may
       * complete any in-progress, non-interruptible requests before finalizing
       * cancellation.
       *
       * The number of canceled requests is specified in `request_counts`. To determine
       * which requests were canceled, check the individual results within the batch.
       * Note that cancellation may not result in any canceled requests if they were
       * non-interruptible.
       */
      cancel(messageBatchId, options) {
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);
      }
      /**
       * Streams the results of a Message Batch as a `.jsonl` file.
       *
       * Each line in the file is a JSON object containing the result of a single request
       * in the Message Batch. Results are not guaranteed to be in the same order as
       * requests. Use the `custom_id` field to match results to requests.
       */
      async results(messageBatchId, options) {
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    MessageBatchesPage = class extends Page {
    };
    Batches2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
function checkNever2(x) {
}
var __classPrivateFieldSet3, __classPrivateFieldGet3, _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage, JSON_BUF_PROPERTY2, MessageStream;
var init_MessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY2 = "__json_buf";
    MessageStream = class _MessageStream {
      constructor() {
        _MessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _MessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _MessageStream_connectedPromise.set(this, void 0);
        _MessageStream_resolveConnectedPromise.set(this, () => {
        });
        _MessageStream_rejectConnectedPromise.set(this, () => {
        });
        _MessageStream_endPromise.set(this, void 0);
        _MessageStream_resolveEndPromise.set(this, () => {
        });
        _MessageStream_rejectEndPromise.set(this, () => {
        });
        _MessageStream_listeners.set(this, {});
        _MessageStream_ended.set(this, false);
        _MessageStream_errored.set(this, false);
        _MessageStream_aborted.set(this, false);
        _MessageStream_catchingPromiseCreated.set(this, false);
        _MessageStream_response.set(this, void 0);
        _MessageStream_request_id.set(this, void 0);
        _MessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet3(this, _MessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet3(this, _MessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet3(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet3(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet3(this, _MessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet3(this, _MessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet3(this, _MessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _MessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _MessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet3(this, _MessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_response, response, "f");
        __classPrivateFieldSet3(this, _MessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet3(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet3(this, _MessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet3(this, _MessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet3(this, _MessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet3(this, _MessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet3(this, _MessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet3(this, _MessageStream_ended, true, "f");
          __classPrivateFieldGet3(this, _MessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
      }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY2, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2, DEPRECATED_MODELS2;
var init_messages2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs"() {
    init_resource();
    init_batches2();
    init_batches2();
    init_MessageStream();
    Messages2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches2(this._client);
      }
      create(body, options) {
        var _a2, _b;
        if (body.model in DEPRECATED_MODELS2) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return MessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(body, options) {
        return this._client.post("/v1/messages/count_tokens", { body, ...options });
      }
    };
    DEPRECATED_MODELS2 = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages2.Batches = Batches2;
    Messages2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2, ModelInfosPage;
var init_models2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models2 = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models", ModelInfosPage, { query, ...options });
      }
    };
    ModelInfosPage = class extends Page {
    };
    Models2.ModelInfosPage = ModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/index.mjs
var init_resources = __esm({
  "node_modules/@anthropic-ai/sdk/resources/index.mjs"() {
    init_shared();
    init_beta();
    init_completions();
    init_messages2();
    init_models2();
  }
});

// node_modules/@anthropic-ai/sdk/index.mjs
var _a, Anthropic, HUMAN_PROMPT, AI_PROMPT, sdk_default;
var init_sdk = __esm({
  "node_modules/@anthropic-ai/sdk/index.mjs"() {
    init_core();
    init_error();
    init_uploads();
    init_resources();
    init_completions();
    init_models2();
    init_beta();
    init_messages2();
    Anthropic = class extends APIClient {
      /**
       * API Client for interfacing with the Anthropic API.
       *
       * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
       * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
       * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = ((_a2) => (_a2 = readEnv("ANTHROPIC_API_KEY")) != null ? _a2 : null)(), authToken = ((_b) => (_b = readEnv("ANTHROPIC_AUTH_TOKEN")) != null ? _b : null)(), ...opts } = {}) {
        var _a3;
        const options = {
          apiKey,
          authToken,
          ...opts,
          baseURL: baseURL || `https://api.anthropic.com`
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
        }
        super({
          baseURL: options.baseURL,
          timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
          httpAgent: options.httpAgent,
          maxRetries: options.maxRetries,
          fetch: options.fetch
        });
        this.completions = new Completions(this);
        this.messages = new Messages2(this);
        this.models = new Models2(this);
        this.beta = new Beta(this);
        this._options = options;
        this.apiKey = apiKey;
        this.authToken = authToken;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(opts) {
        return {
          ...super.defaultHeaders(opts),
          ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
          "anthropic-version": "2023-06-01",
          ...this._options.defaultHeaders
        };
      }
      validateHeaders(headers, customHeaders) {
        if (this.apiKey && headers["x-api-key"]) {
          return;
        }
        if (customHeaders["x-api-key"] === null) {
          return;
        }
        if (this.authToken && headers["authorization"]) {
          return;
        }
        if (customHeaders["authorization"] === null) {
          return;
        }
        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
      }
      authHeaders(opts) {
        const apiKeyAuth = this.apiKeyAuth(opts);
        const bearerAuth = this.bearerAuth(opts);
        if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
          return apiKeyAuth;
        }
        if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
          return bearerAuth;
        }
        return {};
      }
      apiKeyAuth(opts) {
        if (this.apiKey == null) {
          return {};
        }
        return { "X-Api-Key": this.apiKey };
      }
      bearerAuth(opts) {
        if (this.authToken == null) {
          return {};
        }
        return { Authorization: `Bearer ${this.authToken}` };
      }
    };
    _a = Anthropic;
    Anthropic.Anthropic = _a;
    Anthropic.HUMAN_PROMPT = "\n\nHuman:";
    Anthropic.AI_PROMPT = "\n\nAssistant:";
    Anthropic.DEFAULT_TIMEOUT = 6e5;
    Anthropic.AnthropicError = AnthropicError;
    Anthropic.APIError = APIError;
    Anthropic.APIConnectionError = APIConnectionError;
    Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
    Anthropic.APIUserAbortError = APIUserAbortError;
    Anthropic.NotFoundError = NotFoundError;
    Anthropic.ConflictError = ConflictError;
    Anthropic.RateLimitError = RateLimitError;
    Anthropic.BadRequestError = BadRequestError;
    Anthropic.AuthenticationError = AuthenticationError;
    Anthropic.InternalServerError = InternalServerError;
    Anthropic.PermissionDeniedError = PermissionDeniedError;
    Anthropic.UnprocessableEntityError = UnprocessableEntityError;
    Anthropic.toFile = toFile;
    Anthropic.fileFromPath = fileFromPath;
    Anthropic.Completions = Completions;
    Anthropic.Messages = Messages2;
    Anthropic.Models = Models2;
    Anthropic.ModelInfosPage = ModelInfosPage;
    Anthropic.Beta = Beta;
    ({ HUMAN_PROMPT, AI_PROMPT } = Anthropic);
    sdk_default = Anthropic;
  }
});

// providers/anthropic.ts
function estimateTokenCount(messages) {
  const CHARS_PER_TOKEN = 4;
  const totalChars = messages.reduce((total, msg) => {
    return total + msg.content.length;
  }, 0);
  return Math.ceil(totalChars / CHARS_PER_TOKEN);
}
var MODEL_CONTEXT_WINDOWS, MODEL_OUTPUT_TOKEN_LIMITS, AnthropicProvider;
var init_anthropic = __esm({
  "providers/anthropic.ts"() {
    init_base();
    init_sdk();
    MODEL_CONTEXT_WINDOWS = {
      "claude-3-opus-20240229": 2e5,
      "claude-3-sonnet-20240229": 2e5,
      "claude-3-haiku-20240307": 2e5,
      "claude-3-7-sonnet-20250219": 2e5,
      "claude-3-5-sonnet-20241022": 2e5,
      "claude-3-5-sonnet-20240620": 2e5,
      "claude-3-5-haiku-20241022": 2e5
    };
    MODEL_OUTPUT_TOKEN_LIMITS = {
      "claude-3-7-sonnet-20250219": 64e3,
      "claude-3-5-sonnet-20241022": 8192,
      "claude-3-5-sonnet-20240620": 8192,
      "claude-3-5-haiku-20241022": 8192,
      "claude-3-opus-20240229": 4096,
      "claude-3-sonnet-20240229": 8192,
      // fallback for older sonnet
      "claude-3-haiku-20240307": 4096
      // fallback for older haiku
    };
    AnthropicProvider = class extends BaseProvider {
      constructor(apiKey, model = "claude-3-sonnet-20240229") {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl", "https://api.anthropic.com/v1");
        __publicField(this, "model");
        __publicField(this, "client");
        this.apiKey = apiKey;
        this.model = model;
        this.client = new sdk_default({
          apiKey: this.apiKey,
          dangerouslyAllowBrowser: true
          // Required for browser environments
        });
      }
      /**
       * Get a completion from Anthropic
       * 
       * Sends the conversation to Anthropic and streams back the response
       * using the official SDK's streaming support.
       * 
       * Automatically adjusts max_tokens if the request would exceed the model's context window.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d;
        try {
          const contextWindow = (_a2 = MODEL_CONTEXT_WINDOWS[this.model]) != null ? _a2 : 2e5;
          const outputTokenLimit = MODEL_OUTPUT_TOKEN_LIMITS[this.model];
          const inputTokens = estimateTokenCount(messages);
          let maxTokens = (_b = options.maxTokens) != null ? _b : 1e3;
          if (inputTokens + maxTokens > contextWindow) {
            const adjustedMaxTokens = contextWindow - inputTokens;
            if (adjustedMaxTokens <= 0) {
              throw new ProviderError(
                "invalid_request" /* InvalidRequest */,
                `Input is too long for ${this.model}'s context window. Estimated input tokens: ${inputTokens}, context window: ${contextWindow}`
              );
            }
            console.log(
              `Adjusting max_tokens from ${maxTokens} to ${adjustedMaxTokens} to fit within ${this.model}'s context window`
            );
            maxTokens = adjustedMaxTokens;
          }
          if (outputTokenLimit && maxTokens > outputTokenLimit) {
            console.log(
              `Capping max_tokens from ${maxTokens} to model output limit ${outputTokenLimit} for ${this.model}`
            );
            maxTokens = outputTokenLimit;
          }
          const { systemPrompt, anthropicMessages } = this.formatMessages(messages);
          const requestParams = {
            model: this.model,
            messages: anthropicMessages,
            temperature: (_c = options.temperature) != null ? _c : 0.7,
            max_tokens: maxTokens,
            stream: true
          };
          if (systemPrompt) {
            requestParams.system = systemPrompt;
          }
          const stream = await this.client.messages.create(requestParams);
          try {
            if (stream && typeof stream === "object") {
              if (stream.on && typeof stream.on === "function") {
                await new Promise((resolve, reject) => {
                  stream.on("content_block_delta", (chunk) => {
                    var _a3;
                    if (((_a3 = chunk.delta) == null ? void 0 : _a3.type) === "text_delta" && options.streamCallback) {
                      options.streamCallback(chunk.delta.text);
                    }
                  });
                  stream.on("end", resolve);
                  stream.on("error", reject);
                });
              } else if (Symbol.asyncIterator in stream) {
                for await (const chunk of stream) {
                  if (chunk.type === "content_block_delta" && ((_d = chunk.delta) == null ? void 0 : _d.type) === "text_delta" && options.streamCallback) {
                    options.streamCallback(chunk.delta.text);
                  }
                }
              } else if (options.streamCallback) {
                console.warn("Anthropic response is not a stream, handling as regular response");
                if ("content" in stream && typeof stream.content === "string") {
                  options.streamCallback(stream.content);
                }
              }
            }
          } catch (streamError) {
            console.error("Error processing Anthropic stream:", streamError);
            throw streamError;
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Anthropic stream was aborted");
          } else {
            console.error("Error calling Anthropic:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Anthropic models
       * 
       * Returns the list of supported Claude models.
       * Note: Anthropic doesn't have a models endpoint, so we return known models.
       * This list is based on the models defined in MODEL_CONTEXT_WINDOWS.
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          return Object.keys(MODEL_CONTEXT_WINDOWS);
        } catch (error) {
          console.error("Error getting Anthropic models:", error);
          throw error;
        }
      }
      /**
       * Format messages for Anthropic API
       * 
       * Converts from the plugin's Message format to Anthropic's expected format.
       * Handles system messages specially as Anthropic has a different format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages and system prompt for Anthropic API
       */
      formatMessages(messages) {
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        const systemPrompt = systemMessages.length > 0 ? systemMessages.map((msg) => msg.content).join("\n\n") : void 0;
        const anthropicMessages = nonSystemMessages.map((msg) => {
          const role = msg.role === "user" || msg.role === "assistant" ? msg.role : "user";
          return { role, content: msg.content };
        });
        return { systemPrompt, anthropicMessages };
      }
      /**
       * Test connection to Anthropic
       * 
       * Verifies the API key works by attempting a simple completion.
       * 
       * @returns Test results including success/failure
       */
      async testConnection() {
        try {
          await this.client.messages.create({
            model: this.model,
            messages: [{ role: "user", content: "Hi" }],
            max_tokens: 1
          });
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: "Successfully connected to Anthropic!",
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/openai.ts
var OpenAIProvider;
var init_openai = __esm({
  "providers/openai.ts"() {
    init_base();
    OpenAIProvider = class extends BaseProvider {
      constructor(apiKey, model = "gpt-4", baseUrl) {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.apiKey = apiKey;
        this.model = model;
        this.baseUrl = baseUrl || "https://api.openai.com/v1";
      }
      /**
       * Get a completion from OpenAI
       * 
       * Sends the conversation to OpenAI and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e, _f;
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: this.model,
              messages,
              temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
              max_tokens: (_b = options.maxTokens) != null ? _b : 1e3,
              stream: true
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const reader = (_d = response.body) == null ? void 0 : _d.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await (reader == null ? void 0 : reader.read()) || { done: true, value: void 0 };
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.startsWith("data: ") && line !== "data: [DONE]") {
                try {
                  const data = JSON.parse(line.slice(6));
                  const content = (_f = (_e = data.choices[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.content;
                  if (content && options.streamCallback) {
                    options.streamCallback(content);
                  }
                } catch (e) {
                  console.warn("Error parsing OpenAI response chunk:", e);
                }
              }
            }
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("OpenAI stream was aborted");
          } else {
            console.error("Error calling OpenAI:", error);
            throw error;
          }
        }
      }
      /**
       * Get available OpenAI models
       * 
       * Fetches the list of models from OpenAI's API.
       * Filters to only include chat models (GPT-3.5, GPT-4, etc.)
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          const response = await fetch(`${this.baseUrl}/models`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            }
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          return data.data.map((model) => model.id).filter((id) => id.startsWith("gpt-"));
        } catch (error) {
          console.error("Error fetching OpenAI models:", error);
          throw error;
        }
      }
      /**
       * Test connection to OpenAI
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to OpenAI! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/gemini.ts
var GeminiProvider;
var init_gemini = __esm({
  "providers/gemini.ts"() {
    init_base();
    GeminiProvider = class extends BaseProvider {
      constructor(apiKey, model = "gemini-2.0-flash", apiVersion = "v1") {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "apiVersion");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.apiKey = apiKey;
        this.model = model;
        this.apiVersion = apiVersion;
        this.baseUrl = `https://generativelanguage.googleapis.com/${this.apiVersion}`;
      }
      /**
       * Determines the correct API version for a given model name.
       * Uses v1beta for preview/experimental/beta models, otherwise v1.
       */
      getBaseUrlForModel(model) {
        if (/preview|exp|experimental|beta/i.test(model)) {
          return "https://generativelanguage.googleapis.com/v1beta";
        }
        return "https://generativelanguage.googleapis.com/v1";
      }
      /**
       * Get a completion from Google Gemini
       * 
       * Sends the conversation to Gemini and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        try {
          const formattedMessages = this.formatMessages(messages);
          const baseUrl = this.getBaseUrlForModel(this.model);
          const url = `${baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              contents: formattedMessages,
              generationConfig: {
                temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
                maxOutputTokens: (_b = options.maxTokens) != null ? _b : 1e3
              }
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          console.log("Gemini response:", JSON.stringify(data));
          const text = (_h = (_g = (_f = (_e = (_d = data.candidates) == null ? void 0 : _d[0]) == null ? void 0 : _e.content) == null ? void 0 : _f.parts) == null ? void 0 : _g[0]) == null ? void 0 : _h.text;
          if (text && options.streamCallback) {
            options.streamCallback(text);
          } else {
            console.warn("No text found in Gemini response:", JSON.stringify(data));
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Gemini request was aborted");
          } else {
            console.error("Error calling Gemini:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Gemini models from both v1 and v1beta endpoints by default
       *
       * @returns List of available model names (deduplicated)
       */
      async getAvailableModels() {
        const fetchModels = async (version) => {
          var _a2;
          const url = `https://generativelanguage.googleapis.com/${version}/models?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "GET",
            headers: { "Content-Type": "application/json" }
          });
          if (!response.ok) throw this.handleHttpError(response);
          const data = await response.json();
          return ((_a2 = data.models) == null ? void 0 : _a2.map((model) => model.name.split("/").pop())) || [];
        };
        try {
          const [v1Models, v1betaModels] = await Promise.all([
            fetchModels("v1"),
            fetchModels("v1beta")
          ]);
          return Array.from(/* @__PURE__ */ new Set([...v1Models, ...v1betaModels]));
        } catch (error) {
          console.error("Error fetching Gemini models:", error);
          throw error;
        }
      }
      /**
       * Test connection to Gemini
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to Google Gemini! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
      /**
       * Format messages for Gemini API
       * 
       * Converts from the plugin's Message format to Gemini's expected format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages for Gemini API
       */
      formatMessages(messages) {
        const geminiMessages = [];
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        for (const message of systemMessages) {
          geminiMessages.push({
            role: "user",
            parts: [{ text: message.content }]
          });
        }
        for (const message of nonSystemMessages) {
          const role = message.role === "assistant" ? "model" : "user";
          geminiMessages.push({
            role,
            parts: [{ text: message.content }]
          });
        }
        return geminiMessages;
      }
    };
  }
});

// providers/ollama.ts
var OllamaProvider;
var init_ollama = __esm({
  "providers/ollama.ts"() {
    init_base();
    OllamaProvider = class extends BaseProvider {
      constructor(serverUrl = "http://localhost:11434", model = "llama2") {
        super();
        __publicField(this, "apiKey", "");
        // Not used for Ollama
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.baseUrl = serverUrl.replace(/\/$/, "");
        this.model = model;
      }
      /**
       * Convert messages to Ollama format
       * 
       * @param messages - Standard message format
       * @returns Prompt string in Ollama format
       */
      convertToOllamaFormat(messages) {
        return messages.map((msg) => {
          if (msg.role === "system") {
            return `System: ${msg.content}

`;
          }
          return `${msg.role === "user" ? "Human" : "Assistant"}: ${msg.content}

`;
        }).join("") + "Assistant:";
      }
      /**
       * Get a completion from Ollama
       * 
       * Sends the conversation to the local Ollama server and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d;
        try {
          const prompt = this.convertToOllamaFormat(messages);
          const response = await fetch(`${this.baseUrl}/api/generate`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: this.model,
              prompt,
              stream: true,
              options: {
                temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
                num_predict: (_b = options.maxTokens) != null ? _b : 1e3
              }
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const reader = (_d = response.body) == null ? void 0 : _d.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await (reader == null ? void 0 : reader.read()) || { done: true, value: void 0 };
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim()) {
                try {
                  const data = JSON.parse(line);
                  if (data.response && options.streamCallback) {
                    options.streamCallback(data.response);
                  }
                } catch (e) {
                  console.warn("Error parsing Ollama response chunk:", e);
                }
              }
            }
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Ollama stream was aborted");
          } else {
            console.error("Error calling Ollama:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Ollama models
       * 
       * Fetches the list of models installed on the local Ollama server.
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        var _a2;
        try {
          const response = await fetch(`${this.baseUrl}/api/tags`);
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          return ((_a2 = data.models) == null ? void 0 : _a2.map((model) => model.name)) || [];
        } catch (error) {
          console.error("Error fetching Ollama models:", error);
          throw error;
        }
      }
      /**
       * Test connection to Ollama
       * 
       * Verifies the Ollama server is running and accessible.
       * Also checks if any models are installed.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          if (models.length === 0) {
            return {
              success: false,
              message: 'Connected to Ollama server, but no models are installed. Use "ollama pull model-name" to install models.',
              models: []
            };
          }
          return {
            success: true,
            message: `Successfully connected to Ollama! Found ${models.length} installed models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});
=======
    } catch (error) {
      let message = "Connection failed: ";
      if (error instanceof Error) {
        if (error.message.includes("fetch")) {
          message += "Could not connect to Ollama server. Make sure Ollama is installed and running.";
        } else {
          message += error.message;
        }
      } else {
        message += "Unknown error occurred";
      }
      return {
        success: false,
        message
      };
    }
  }
  /**
   * Format messages for Ollama API
   * 
   * Converts from the plugin's Message format to Ollama's expected format.
   * Ollama expects a simple text prompt, so we need to flatten the conversation.
   * 
   * @param messages Array of message objects
   * @returns Formatted prompt string for Ollama
   */
  formatMessages(messages) {
    let prompt = "";
    const systemMessages = messages.filter((m) => m.role === "system");
    if (systemMessages.length > 0) {
      prompt = systemMessages.map((m) => m.content).join("\n\n");
      prompt += "\n\n";
    }
    const nonSystemMessages = messages.filter((m) => m.role !== "system");
    for (const message of nonSystemMessages) {
      const roleName = message.role === "user" ? "User" : "Assistant";
      prompt += `${roleName}: ${message.content}

`;
    }
    prompt += "Assistant: ";
    return prompt;
  }
};
>>>>>>> main

// providers/index.ts
var providers_exports = {};
__export(providers_exports, {
  AnthropicProvider: () => AnthropicProvider,
  BaseProvider: () => BaseProvider,
  GeminiProvider: () => GeminiProvider,
  OllamaProvider: () => OllamaProvider,
  OpenAIProvider: () => OpenAIProvider,
  ProviderError: () => ProviderError,
  ProviderErrorType: () => ProviderErrorType,
  createProvider: () => createProvider,
  createProviderFromUnifiedModel: () => createProviderFromUnifiedModel,
  getAllAvailableModels: () => getAllAvailableModels,
  getModelIdFromUnifiedModel: () => getModelIdFromUnifiedModel,
  getProviderFromUnifiedModel: () => getProviderFromUnifiedModel
});
function createProvider(settings) {
  switch (settings.provider) {
    case "openai":
      return new OpenAIProvider(
        settings.openaiSettings.apiKey,
        settings.openaiSettings.model,
        settings.openaiSettings.baseUrl
      );
    case "anthropic":
      return new AnthropicProvider(
        settings.anthropicSettings.apiKey,
        settings.anthropicSettings.model
      );
    case "gemini":
      return new GeminiProvider(
        settings.geminiSettings.apiKey,
        settings.geminiSettings.model
      );
    case "ollama":
      return new OllamaProvider(
        settings.ollamaSettings.serverUrl,
        settings.ollamaSettings.model
      );
    default:
      throw new Error(`Invalid provider type: ${settings.provider}`);
  }
}
function createProviderFromUnifiedModel(settings, unifiedModelId) {
  const [providerType, modelId] = unifiedModelId.split(":", 2);
  switch (providerType) {
    case "openai":
      return new OpenAIProvider(settings.openaiSettings.apiKey, modelId, settings.openaiSettings.baseUrl);
    case "anthropic":
      return new AnthropicProvider(settings.anthropicSettings.apiKey, modelId);
    case "gemini":
      return new GeminiProvider(settings.geminiSettings.apiKey, modelId);
    case "ollama":
      return new OllamaProvider(settings.ollamaSettings.serverUrl, modelId);
    default:
      throw new Error(`Invalid provider type: ${providerType}`);
  }
}
async function getAllAvailableModels(settings) {
  const allModels = [];
  const getProviderDisplayName = (provider) => {
    switch (provider) {
      case "openai":
        return "OpenAI";
      case "anthropic":
        return "Anthropic";
      case "gemini":
        return "Google";
      case "ollama":
        return "Ollama";
      default:
        return provider;
    }
  };
  if (settings.openaiSettings.apiKey && settings.openaiSettings.availableModels.length > 0) {
    settings.openaiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `openai:${model}`,
        name: `${model} (${getProviderDisplayName("openai")})`,
        provider: "openai",
        modelId: model
      });
    });
  }
  if (settings.anthropicSettings.apiKey && settings.anthropicSettings.availableModels.length > 0) {
    settings.anthropicSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `anthropic:${model}`,
        name: `${model} (${getProviderDisplayName("anthropic")})`,
        provider: "anthropic",
        modelId: model
      });
    });
  }
  if (settings.geminiSettings.apiKey && settings.geminiSettings.availableModels.length > 0) {
    settings.geminiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `gemini:${model}`,
        name: `${model} (${getProviderDisplayName("gemini")})`,
        provider: "gemini",
        modelId: model
      });
    });
  }
  if (settings.ollamaSettings.serverUrl && settings.ollamaSettings.availableModels.length > 0) {
    settings.ollamaSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `ollama:${model}`,
        name: `${model} (${getProviderDisplayName("ollama")})`,
        provider: "ollama",
        modelId: model
      });
    });
  }
  return allModels;
}
function getProviderFromUnifiedModel(unifiedModelId) {
  const [providerType] = unifiedModelId.split(":", 2);
  return providerType;
}
function getModelIdFromUnifiedModel(unifiedModelId) {
  const [, modelId] = unifiedModelId.split(":", 2);
  return modelId;
}
var init_providers = __esm({
  "providers/index.ts"() {
    init_base();
    init_anthropic();
    init_openai();
    init_gemini();
    init_ollama();
  }
});

<<<<<<< HEAD
// src/components/chat/SettingsSections.ts
var SettingsSections_exports = {};
__export(SettingsSections_exports, {
  SettingsSections: () => SettingsSections
});
var import_obsidian10, SettingsSections;
var init_SettingsSections = __esm({
  "src/components/chat/SettingsSections.ts"() {
    import_obsidian10 = require("obsidian");
    init_providers();
    SettingsSections = class {
      constructor(plugin) {
        __publicField(this, "plugin");
        this.plugin = plugin;
      }
      /**
       * AI Model Settings Section
       */
      async renderAIModelSettings(containerEl, onRefresh) {
        while (containerEl.firstChild) containerEl.removeChild(containerEl.firstChild);
        if (this.plugin.settings.modelSettingPresets && this.plugin.settings.modelSettingPresets.length > 0) {
          const presetContainer = containerEl.createDiv();
          presetContainer.addClass("model-preset-buttons");
          presetContainer.createEl("div", { text: "Presets:", cls: "setting-item-name" });
          this.plugin.settings.modelSettingPresets.forEach((preset, idx) => {
            const btn = presetContainer.createEl("button", { text: preset.name });
            btn.style.marginRight = "0.5em";
            btn.onclick = async () => {
              if (preset.selectedModel !== void 0) this.plugin.settings.selectedModel = preset.selectedModel;
              if (preset.systemMessage !== void 0) this.plugin.settings.systemMessage = preset.systemMessage;
              if (preset.temperature !== void 0) this.plugin.settings.temperature = preset.temperature;
              if (preset.maxTokens !== void 0) this.plugin.settings.maxTokens = preset.maxTokens;
              if (preset.enableStreaming !== void 0) this.plugin.settings.enableStreaming = preset.enableStreaming;
              await this.plugin.saveSettings();
              if (onRefresh) {
                if (window._aiModelSettingsRefreshTimeout) {
                  clearTimeout(window._aiModelSettingsRefreshTimeout);
                }
                window._aiModelSettingsRefreshTimeout = setTimeout(() => {
                  onRefresh();
                  window._aiModelSettingsRefreshTimeout = null;
                }, 50);
              }
              new import_obsidian10.Notice(`Applied preset: ${preset.name}`);
            };
          });
        }
        new import_obsidian10.Setting(containerEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
          this.plugin.settings.systemMessage = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian10.Setting(containerEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
          this.plugin.settings.enableStreaming = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian10.Setting(containerEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.temperature = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian10.Setting(containerEl).setName("Refresh Available Models").setDesc("Test connections to all configured providers and refresh available models").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
          button.setButtonText("Refreshing...");
          button.setDisabled(true);
          try {
            await this.refreshAllAvailableModels();
            new import_obsidian10.Notice("Successfully refreshed available models");
            if (onRefresh) onRefresh();
          } catch (error) {
            new import_obsidian10.Notice(`Error refreshing models: ${error.message}`);
          } finally {
            button.setButtonText("Refresh Models");
            button.setDisabled(false);
          }
        }));
        await this.renderUnifiedModelDropdown(containerEl);
      }
      /**
       * Date Settings Section
       */
      renderDateSettings(containerEl) {
        new import_obsidian10.Setting(containerEl).setName("Include Date with System Message").setDesc("Add the current date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
          this.plugin.settings.includeDateWithSystemMessage = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian10.Setting(containerEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
          this.plugin.settings.includeTimeWithSystemMessage = value;
          await this.plugin.saveSettings();
        }));
      }
      /**
       * Note Reference Settings Section
       */
      renderNoteReferenceSettings(containerEl) {
        new import_obsidian10.Setting(containerEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
          this.plugin.settings.enableObsidianLinks = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian10.Setting(containerEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
          this.plugin.settings.enableContextNotes = value;
          await this.plugin.saveSettings();
        }));
        const contextNotesContainer = containerEl.createDiv("context-notes-container");
        contextNotesContainer.style.marginBottom = "24px";
        new import_obsidian10.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
          text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange(async (value) => {
            this.plugin.settings.contextNotes = value;
            await this.plugin.saveSettings();
          });
          text.inputEl.rows = 4;
          text.inputEl.style.width = "100%";
        });
        new import_obsidian10.Setting(containerEl).setName("Expand Linked Notes Recursively").setDesc("If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).").addToggle((toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false).onChange(async (value) => {
            this.plugin.settings.expandLinkedNotesRecursively = value;
            await this.plugin.saveSettings();
          });
        });
      }
      /**
       * Provider Configuration Section
       */
      renderProviderConfiguration(containerEl) {
        containerEl.createEl("p", {
          text: "API keys are configured in the main plugin settings. Use the test buttons below to verify connections and refresh available models.",
          cls: "setting-item-description"
        });
        this.renderOpenAIConfig(containerEl);
        this.renderAnthropicConfig(containerEl);
        this.renderGeminiConfig(containerEl);
        this.renderOllamaConfig(containerEl);
      }
      /**
       * Renders the unified model selection dropdown
       */
      async renderUnifiedModelDropdown(containerEl) {
        if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
          this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
          await this.plugin.saveSettings();
        }
        new import_obsidian10.Setting(containerEl).setName("Selected Model").setDesc("Choose from all available models across all configured providers").addDropdown((dropdown) => {
          if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
            dropdown.addOption("", "No models available - configure providers below");
          } else {
            dropdown.addOption("", "Select a model...");
            const modelsByProvider = {};
            const enabledModels = this.plugin.settings.enabledModels || {};
            const filteredModels = this.plugin.settings.availableModels.filter((model) => enabledModels[model.id] !== false);
            filteredModels.forEach((model) => {
              if (!modelsByProvider[model.provider]) {
                modelsByProvider[model.provider] = [];
              }
              modelsByProvider[model.provider].push(model);
            });
            Object.entries(modelsByProvider).forEach(([provider, models]) => {
              models.forEach((model) => {
                dropdown.addOption(model.id, model.name);
              });
            });
          }
          dropdown.setValue(this.plugin.settings.selectedModel || "").onChange(async (value) => {
            this.plugin.settings.selectedModel = value;
            if (value) {
              const provider = getProviderFromUnifiedModel(value);
              this.plugin.settings.provider = provider;
            }
            await this.plugin.saveSettings();
          });
        });
        if (this.plugin.settings.selectedModel && this.plugin.settings.availableModels) {
          const selectedModel = this.plugin.settings.availableModels.find(
            (model) => model.id === this.plugin.settings.selectedModel
          );
          if (selectedModel) {
            const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
            infoEl.setText(`Currently using: ${selectedModel.name}`);
          }
        }
      }
      /**
       * Refreshes available models from all configured providers
       */
      async refreshAllAvailableModels() {
        const providers = ["openai", "anthropic", "gemini", "ollama"];
        for (const providerType of providers) {
          try {
            const originalProvider = this.plugin.settings.provider;
            this.plugin.settings.provider = providerType;
            const providerInstance = createProvider(this.plugin.settings);
            const result = await providerInstance.testConnection();
            this.plugin.settings.provider = originalProvider;
            const providerSettings = this.plugin.settings[`${providerType}Settings`];
            if (result.success && result.models) {
              providerSettings.availableModels = result.models;
              providerSettings.lastTestResult = {
                timestamp: Date.now(),
                success: true,
                message: result.message
              };
            } else {
              providerSettings.lastTestResult = {
                timestamp: Date.now(),
                success: false,
                message: result.message
              };
            }
          } catch (error) {
            console.error(`Error testing ${providerType}:`, error);
          }
        }
        this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
        await this.plugin.saveSettings();
      }
      /**
       * Renders a collapsible section for provider configuration.
       * @param containerEl The HTML element to render the section into.
       * @param providerType The type of the provider (e.g., 'openai', 'anthropic').
       * @param displayName The display name of the provider (e.g., 'OpenAI', 'Anthropic').
       * @param renderSpecificSettings A callback function to render provider-specific settings.
       */
      _renderCollapsibleProviderConfig(containerEl, providerType, displayName, renderSpecificSettings) {
        const collapsibleContainer = containerEl.createDiv({ cls: "provider-collapsible" });
        const headerEl = collapsibleContainer.createEl("div", {
          cls: "provider-header",
          text: `\u25B6 ${displayName} Configuration`
        });
        Object.assign(headerEl.style, {
          cursor: "pointer",
          userSelect: "none",
          padding: "8px 0",
          fontWeight: "bold"
        });
        const contentEl = collapsibleContainer.createDiv({ cls: "provider-content" });
        contentEl.style.display = "none";
        contentEl.style.paddingLeft = "16px";
        let isExpanded = false;
        headerEl.addEventListener("click", () => {
          isExpanded = !isExpanded;
          contentEl.style.display = isExpanded ? "block" : "none";
          headerEl.textContent = `${isExpanded ? "\u25BC" : "\u25B6"} ${displayName} Configuration`;
        });
        const settings = this.plugin.settings[`${providerType}Settings`];
        const apiKeyStatus = settings.apiKey ? `API Key: ${settings.apiKey.substring(0, 8)}...` : "No API Key configured";
        const serverUrlStatus = settings.serverUrl ? `Server URL: ${settings.serverUrl}` : "No Server URL configured";
        contentEl.createEl("div", {
          cls: "setting-item-description",
          text: `${settings.apiKey ? apiKeyStatus : serverUrlStatus} (Configure in main plugin settings)`
        });
        if (renderSpecificSettings) {
          renderSpecificSettings(contentEl);
        }
        this.renderProviderTestSection(contentEl, providerType, displayName);
      }
      /**
       * Renders the OpenAI configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOpenAIConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "openai", "OpenAI", (contentEl) => {
          new import_obsidian10.Setting(contentEl).setName("OpenAI Base URL").setDesc("Custom base URL for OpenAI API (optional)").addText((text) => text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openaiSettings.baseUrl || "").onChange(async (value) => {
            this.plugin.settings.openaiSettings.baseUrl = value;
            await this.plugin.saveSettings();
          }));
        });
      }
      /**
       * Renders the Anthropic configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderAnthropicConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "anthropic", "Anthropic");
      }
      /**
       * Renders the Gemini configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderGeminiConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "gemini", "Gemini");
      }
      /**
       * Renders the Ollama configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOllamaConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "ollama", "Ollama", (contentEl) => {
          contentEl.createEl("div", {
            cls: "setting-item-description",
            text: "To use Ollama:"
          });
          const steps = contentEl.createEl("ol");
          steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
          steps.createEl("li", { text: "Start the Ollama server" });
          steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
          steps.createEl("li", { text: "Test connection to see available models" });
        });
      }
      /**
       * Renders the provider connection test section.
       * @param containerEl The HTML element to render the section into.
       * @param provider The internal identifier for the provider (e.g., 'openai').
       * @param displayName The user-friendly name of the provider (e.g., 'OpenAI').
       */
      renderProviderTestSection(containerEl, provider, displayName) {
        const settings = this.plugin.settings[`${provider}Settings`];
        new import_obsidian10.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${displayName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
          button.setButtonText("Testing...");
          button.setDisabled(true);
          try {
            const originalProvider = this.plugin.settings.provider;
            this.plugin.settings.provider = provider;
            const providerInstance = createProvider(this.plugin.settings);
            const result = await providerInstance.testConnection();
            this.plugin.settings.provider = originalProvider;
            if (result.success && result.models) {
              settings.availableModels = result.models;
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: true,
                message: result.message
              };
              await this.plugin.saveSettings();
              this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
              await this.plugin.saveSettings();
              new import_obsidian10.Notice(result.message);
            } else {
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: false,
                message: result.message
              };
              new import_obsidian10.Notice(result.message);
            }
          } catch (error) {
            new import_obsidian10.Notice(`Error: ${error.message}`);
          } finally {
            button.setButtonText("Test");
            button.setDisabled(false);
          }
        }));
        if (settings.lastTestResult) {
          const date = new Date(settings.lastTestResult.timestamp);
          containerEl.createEl("div", {
            text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
            cls: settings.lastTestResult.success ? "success" : "error"
          });
        }
        if (settings.availableModels && settings.availableModels.length > 0) {
          containerEl.createEl("div", {
            text: `Available models: ${settings.availableModels.map((m) => m.name || m.id).join(", ")}`,
            cls: "setting-item-description"
          });
        }
      }
      /**
       * Renders all settings sections in order for a modal or view.
       * @param containerEl The HTML element to render the sections into.
       * @param options Optional settings, e.g., onRefresh callback.
       */
      async renderAllSettings(containerEl, options) {
        await this.renderAIModelSettings(containerEl, options == null ? void 0 : options.onRefresh);
        this.renderDateSettings(containerEl);
        this.renderNoteReferenceSettings(containerEl);
        this.renderProviderConfiguration(containerEl);
      }
    };
  }
});

// src/components/chat/Buttons.ts
function createActionButton(label, tooltip, callback) {
  const button = document.createElement("button");
  button.addClass("ai-chat-action-button");
  button.setAttribute("aria-label", tooltip);
  const labelEl = document.createElement("span");
  labelEl.textContent = label;
  button.appendChild(labelEl);
  button.addEventListener("click", callback);
  return button;
}
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
  } catch (error) {
  }
}
var import_obsidian13, Buttons;
var init_Buttons = __esm({
  "src/components/chat/Buttons.ts"() {
    import_obsidian13 = require("obsidian");
    Buttons = class extends import_obsidian13.Component {
      constructor() {
        super();
        __publicField(this, "container");
        __publicField(this, "sendButton");
        __publicField(this, "stopButton");
        __publicField(this, "clearButton");
        __publicField(this, "settingsButton");
        this.container = document.createElement("div");
        this.container.addClass("ai-chat-buttons");
        this.sendButton = new import_obsidian13.ButtonComponent(this.container).setButtonText("Send").setClass("mod-cta");
        this.sendButton.buttonEl.addClass("hidden-button");
        this.stopButton = new import_obsidian13.ButtonComponent(this.container).setButtonText("Stop");
        this.stopButton.buttonEl.addClass("hidden-button");
        this.clearButton = new import_obsidian13.ButtonComponent(this.container).setButtonText("Clear");
        this.clearButton.buttonEl.addClass("hidden-button");
        this.settingsButton = new import_obsidian13.ButtonComponent(this.container).setButtonText("Settings");
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Get the button container element
       */
      getContainer() {
        return this.container;
      }
      getSendButton() {
        return this.sendButton;
      }
      getStopButton() {
        return this.stopButton;
      }
      getClearButton() {
        return this.clearButton;
      }
      getSettingsButton() {
        return this.settingsButton;
      }
      showSendButton() {
        this.sendButton.buttonEl.removeClass("hidden-button");
      }
      hideSendButton() {
        this.sendButton.buttonEl.addClass("hidden-button");
      }
      showStopButton() {
        this.stopButton.buttonEl.removeClass("hidden-button");
      }
      hideStopButton() {
        this.stopButton.buttonEl.addClass("hidden-button");
      }
      showClearButton() {
        this.clearButton.buttonEl.removeClass("hidden-button");
      }
      hideClearButton() {
        this.clearButton.buttonEl.addClass("hidden-button");
      }
      showSettingsButton() {
        this.settingsButton.buttonEl.removeClass("hidden-button");
      }
      hideSettingsButton() {
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Create action buttons for messages (copy, edit, delete, regenerate)
       */
      createMessageActions(buttons) {
        const actionsContainer = document.createElement("div");
        actionsContainer.addClass("message-actions");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          actionsContainer.appendChild(button);
        });
        return actionsContainer;
      }
      /**
       * Create the main chat control buttons (send, stop, copy all, clear, settings)
       */
      createChatControls(buttons) {
        const controlsContainer = document.createElement("div");
        controlsContainer.addClass("ai-chat-buttons");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          if (config.isHidden) {
            button.addClass("hidden-button");
          }
          controlsContainer.appendChild(button);
        });
        return controlsContainer;
      }
      /**
       * Create a single button with the given configuration
       */
      createButton(config) {
        const button = document.createElement("button");
        button.addClass("ai-chat-action-button");
        if (config.className) {
          button.addClass(config.className);
        }
        button.setAttribute("aria-label", config.tooltip);
        const labelEl = document.createElement("span");
        labelEl.textContent = config.label;
        button.appendChild(labelEl);
        button.addEventListener("click", config.onClick);
        return button;
      }
      /**
       * Show or hide a specific button in a container
       */
      toggleButton(container, label, show) {
        const button = container.querySelector(`[aria-label="${label}"]`);
        if (button instanceof HTMLElement) {
          show ? button.removeClass("hidden-button") : button.addClass("hidden-button");
        }
      }
    };
  }
});

// src/components/chat/ToolRichDisplay.ts
var import_obsidian15, ToolRichDisplay;
var init_ToolRichDisplay = __esm({
  "src/components/chat/ToolRichDisplay.ts"() {
    import_obsidian15 = require("obsidian");
    ToolRichDisplay = class extends import_obsidian15.Component {
      constructor(options) {
        super();
        __publicField(this, "element");
        __publicField(this, "options");
        this.options = options;
        this.element = this.createToolDisplay();
      }
      getElement() {
        return this.element;
      }
      createToolDisplay() {
        const container = document.createElement("div");
        container.className = "tool-rich-display";
        const iconDiv = document.createElement("div");
        iconDiv.className = "tool-rich-icon";
        iconDiv.innerHTML = this.getToolIcon();
        container.appendChild(iconDiv);
        const infoDiv = document.createElement("div");
        infoDiv.className = "tool-rich-info";
        const titleDiv = document.createElement("div");
        titleDiv.className = "tool-rich-title";
        titleDiv.innerText = this.getToolDisplayName();
        const statusSpan = document.createElement("span");
        statusSpan.className = `tool-rich-status ${this.options.result.success ? "success" : "error"}`;
        statusSpan.innerText = this.options.result.success ? "Success" : "Error";
        titleDiv.appendChild(statusSpan);
        infoDiv.appendChild(titleDiv);
        if (this.options.command.parameters && Object.keys(this.options.command.parameters).length > 0) {
          const paramsDiv = document.createElement("div");
          paramsDiv.innerHTML = `<strong>Parameters:</strong> ${this.formatParameters()}`;
          infoDiv.appendChild(paramsDiv);
        }
        const resultDiv = document.createElement("div");
        resultDiv.innerHTML = `<strong>Result:</strong> ${this.getResultSummary()}`;
        infoDiv.appendChild(resultDiv);
        const details = this.getDetailedResult();
        if (details) {
          const toggle = document.createElement("div");
          toggle.className = "tool-rich-details-toggle";
          toggle.innerText = "Show details \u25BC";
          const detailsDiv = document.createElement("div");
          detailsDiv.className = "tool-rich-details";
          detailsDiv.innerHTML = `<pre>${details}</pre>`;
          toggle.onclick = () => {
            const isExpanded = detailsDiv.classList.contains("expanded");
            if (isExpanded) {
              detailsDiv.classList.remove("expanded");
              toggle.innerText = "Show details \u25BC";
            } else {
              detailsDiv.classList.add("expanded");
              toggle.innerText = "Hide details \u25B2";
            }
          };
          infoDiv.appendChild(toggle);
          infoDiv.appendChild(detailsDiv);
        }
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "tool-rich-actions";
        if (this.options.onRerun) {
          const rerunBtn = document.createElement("button");
          rerunBtn.className = "tool-rich-action-btn";
          rerunBtn.innerText = "Re-run";
          rerunBtn.onclick = this.options.onRerun;
          actionsDiv.appendChild(rerunBtn);
        }
        if (this.options.onCopy) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "tool-rich-action-btn";
          copyBtn.innerText = "Copy";
          copyBtn.onclick = this.options.onCopy;
          actionsDiv.appendChild(copyBtn);
        }
        const copyResultBtn = document.createElement("button");
        copyResultBtn.className = "tool-rich-action-btn";
        copyResultBtn.innerText = "Copy Result";
        copyResultBtn.onclick = async () => {
          const resultText = this.options.result.success ? JSON.stringify(this.options.result.data, null, 2) : this.options.result.error || "Unknown error";
          try {
            await navigator.clipboard.writeText(resultText);
            copyResultBtn.innerText = "Copied!";
            setTimeout(() => {
              copyResultBtn.innerText = "Copy Result";
            }, 2e3);
          } catch (error) {
            console.error("Failed to copy to clipboard:", error);
          }
        };
        actionsDiv.appendChild(copyResultBtn);
        infoDiv.appendChild(actionsDiv);
        container.appendChild(infoDiv);
        return container;
      }
      getToolIcon() {
        const iconMap = {
          "file_search": "\u{1F50D}",
          "file_read": "\u{1F4D6}",
          "file_write": "\u270D\uFE0F",
          "file_diff": "\u{1F504}",
          "file_move": "\u{1F4C1}",
          "file_rename": "\u{1F3F7}\uFE0F",
          "file_list": "\u{1F4CB}",
          "thought": "\u{1F9E0}"
        };
        return iconMap[this.options.command.action] || "\u{1F527}";
      }
      getToolDisplayName() {
        const nameMap = {
          "file_search": "File Search",
          "file_read": "File Read",
          "file_write": "File Write",
          "file_diff": "File Diff",
          "file_move": "File Move",
          "file_rename": "File Rename",
          "file_list": "File List",
          "thought": "Thought Process"
        };
        return nameMap[this.options.command.action] || this.options.command.action;
      }
      formatParameters() {
        const params = this.options.command.parameters;
        const formatted = Object.entries(params).map(([key, value]) => `${key}: ${typeof value === "string" && value.length > 50 ? value.substring(0, 50) + "..." : JSON.stringify(value)}`).join(", ");
        return `<code>${formatted}</code>`;
      }
      getResultSummary() {
        if (!this.options.result.success) {
          return `<span class="tool-error">${this.options.result.error || "Unknown error"}</span>`;
        }
        const data = this.options.result.data;
        if (this.options.command.action === "file_write" && data) {
          const action = data.action || "modified";
          const filePath = data.filePath || "unknown file";
          const size = data.size ? ` (${data.size} bytes)` : "";
          if (action === "created") {
            return `<span class="tool-success">\u{1F4DD} Created file: <strong>${filePath}</strong>${size}</span>`;
          } else {
            return `<span class="tool-success">\u{1F4BE} Saved file: <strong>${filePath}</strong>${size}</span>`;
          }
        }
        if (this.options.command.action === "file_read" && data) {
          const filePath = data.filePath || this.options.command.parameters.path;
          const size = data.content ? ` (${data.content.length} chars)` : "";
          return `<span class="tool-success">\u{1F4D6} Read file: <strong>${filePath}</strong>${size}</span>`;
        }
        if (this.options.command.action === "file_search" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          return `<span class="tool-success">\u{1F50D} Found ${count} file${count !== 1 ? "s" : ""}</span>`;
        }
        if (this.options.command.action === "file_list" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          const path = data.path || this.options.command.parameters.path;
          return `<span class="tool-success">\u{1F4CB} Listed ${count} file${count !== 1 ? "s" : ""} in <strong>${path}</strong></span>`;
        }
        if (this.options.command.action === "file_move" && data) {
          const from = this.options.command.parameters.sourcePath;
          const to = this.options.command.parameters.destinationPath;
          return `<span class="tool-success">\u{1F4C1} Moved <strong>${from}</strong> \u2192 <strong>${to}</strong></span>`;
        }
        if (this.options.command.action === "file_rename" && data) {
          const oldName = this.options.command.parameters.path;
          const newName = this.options.command.parameters.newName;
          return `<span class="tool-success">\u{1F3F7}\uFE0F Renamed <strong>${oldName}</strong> \u2192 <strong>${newName}</strong></span>`;
        }
        if (this.options.command.action === "thought" && data) {
          const thought = data.thought || data.reasoning || "";
          const truncated = thought.length > 100 ? thought.substring(0, 100) + "..." : thought;
          return `<span class="tool-success">\u{1F9E0} ${truncated}</span>`;
        }
        if (typeof data === "string") {
          return data.length > 100 ? data.substring(0, 100) + "..." : data;
        }
        if (Array.isArray(data)) {
          return `${data.length} items returned`;
        }
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data);
          return `Object with ${keys.length} properties`;
        }
        return "Success";
      }
      getDetailedResult() {
        if (!this.options.result.success) {
          return this.options.result.error || "Unknown error occurred";
        }
        if (this.options.result.data) {
          return typeof this.options.result.data === "string" ? this.options.result.data : JSON.stringify(this.options.result.data, null, 2);
        }
        return null;
      }
      /**
       * Update the display with new tool result
       */
      updateResult(result) {
        this.options.result = result;
        const newElement = this.createToolDisplay();
        this.element.replaceWith(newElement);
        this.element = newElement;
      }
      /**
      * Convert the tool display to markdown format for saving to notes
      */
      toMarkdown() {
        const { command, result } = this.options;
        const status = result.success ? "\u2705" : "\u274C";
        const toolName = this.getToolDisplayName();
        const icon = this.getToolIcon();
        let markdown = `
### ${icon} ${toolName} ${status}

`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          markdown += `**Parameters:**
`;
          Object.entries(command.parameters).forEach(([key, value]) => {
            const displayValue = typeof value === "string" && value.length > 100 ? value.substring(0, 100) + "..." : JSON.stringify(value);
            markdown += `- **${key}:** \`${displayValue}\`
`;
          });
          markdown += "\n";
        }
        if (result.success) {
          markdown += `**Result:** ${this.getResultSummary()}

`;
          const details = this.getDetailedResult();
          if (details && details !== this.getResultSummary()) {
            if (details.length <= 200) {
              markdown += `**Details:** \`${details}\`

`;
            } else {
              markdown += `<details>
<summary>Show Details</summary>

\`\`\`
${details}
\`\`\`

</details>

`;
            }
          }
        } else {
          markdown += `**Error:** ${result.error}

`;
        }
        return markdown;
      }
    };
  }
});

// src/components/chat/MessageRenderer.ts
var import_obsidian16, MessageRenderer;
var init_MessageRenderer = __esm({
  "src/components/chat/MessageRenderer.ts"() {
    import_obsidian16 = require("obsidian");
    init_ToolRichDisplay();
    MessageRenderer = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * Update message container with enhanced reasoning and task status data
       */
      updateMessageWithEnhancedData(container, messageData, component) {
        const existingReasoning = container.querySelector(".reasoning-container");
        const existingTaskStatus = container.querySelector(".task-status-container");
        if (existingReasoning) existingReasoning.remove();
        if (existingTaskStatus) existingTaskStatus.remove();
        const messageContainer = container.querySelector(".message-container");
        if (!messageContainer) return;
        if (messageData.reasoning) {
          const reasoningEl = this.createReasoningSection(messageData.reasoning);
          messageContainer.insertBefore(reasoningEl, messageContainer.firstChild);
        }
        if (messageData.taskStatus) {
          const taskStatusEl = this.createTaskStatusSection(messageData.taskStatus);
          messageContainer.insertBefore(taskStatusEl, messageContainer.firstChild);
        }
        const contentEl = container.querySelector(".message-content");
        if (contentEl) {
          contentEl.empty();
          import_obsidian16.MarkdownRenderer.render(
            this.app,
            messageData.content,
            contentEl,
            "",
            component || null
          ).catch((error) => {
            contentEl.textContent = messageData.content;
          });
        }
      }
      /**
       * Create reasoning section element
       */
      createReasoningSection(reasoning) {
        var _a2;
        const reasoningContainer = document.createElement("div");
        reasoningContainer.className = "reasoning-container";
        const header = document.createElement("div");
        header.className = "reasoning-summary";
        const toggle = document.createElement("span");
        toggle.className = "reasoning-toggle";
        toggle.textContent = reasoning.isCollapsed ? "\u25B6" : "\u25BC";
        const headerText = document.createElement("span");
        const typeLabel = reasoning.type === "structured" ? "STRUCTURED REASONING" : "REASONING";
        const stepCount = ((_a2 = reasoning.steps) == null ? void 0 : _a2.length) || 0;
        headerText.innerHTML = `<strong>\u{1F9E0} ${typeLabel}</strong>`;
        if (stepCount > 0) {
          headerText.innerHTML += ` (${stepCount} steps)`;
        }
        headerText.innerHTML += ` - <em>Click to ${reasoning.isCollapsed ? "expand" : "collapse"}</em>`;
        header.appendChild(toggle);
        header.appendChild(headerText);
        const details = document.createElement("div");
        details.className = "reasoning-details";
        if (!reasoning.isCollapsed) {
          details.classList.add("expanded");
        }
        if (reasoning.type === "structured" && reasoning.steps) {
          if (reasoning.problem) {
            const problemDiv = document.createElement("div");
            problemDiv.className = "reasoning-problem";
            problemDiv.innerHTML = `<strong>Problem:</strong> ${reasoning.problem}`;
            details.appendChild(problemDiv);
          }
          reasoning.steps.forEach((step) => {
            const stepDiv = document.createElement("div");
            stepDiv.className = `reasoning-step ${step.category}`;
            stepDiv.innerHTML = `
                    <div class="step-header">
                        ${this.getStepEmoji(step.category)} Step ${step.step}: ${step.title.toUpperCase()}
                    </div>
                    <div class="step-confidence">
                        Confidence: ${step.confidence}/10
                    </div>
                    <div class="step-content">
                        ${step.content}
                    </div>
                `;
            details.appendChild(stepDiv);
          });
        } else if (reasoning.summary) {
          const summaryDiv = document.createElement("div");
          summaryDiv.className = "reasoning-completion";
          summaryDiv.textContent = reasoning.summary;
          details.appendChild(summaryDiv);
        }
        header.addEventListener("click", () => {
          const isExpanded = details.classList.contains("expanded");
          if (isExpanded) {
            details.classList.remove("expanded");
            toggle.textContent = "\u25B6";
            reasoning.isCollapsed = true;
          } else {
            details.classList.add("expanded");
            toggle.textContent = "\u25BC";
            reasoning.isCollapsed = false;
          }
        });
        reasoningContainer.appendChild(header);
        reasoningContainer.appendChild(details);
        return reasoningContainer;
      }
      /**
       * Create task status section element
       */
      createTaskStatusSection(taskStatus) {
        const statusContainer = document.createElement("div");
        statusContainer.className = "task-status-container";
        statusContainer.dataset.taskStatus = taskStatus.status;
        const statusText = this.getTaskStatusText(taskStatus);
        const statusIcon = this.getTaskStatusIcon(taskStatus.status);
        statusContainer.innerHTML = `
            <div class="task-status-header">
                ${statusIcon} <strong>${statusText}</strong>
            </div>
        `;
        if (taskStatus.toolExecutionCount > 0) {
          const toolInfo = document.createElement("div");
          toolInfo.className = "task-tool-info";
          toolInfo.textContent = `Tools used: ${taskStatus.toolExecutionCount}/${taskStatus.maxToolExecutions}`;
          statusContainer.appendChild(toolInfo);
        }
        return statusContainer;
      }
      /**
       * Get emoji for reasoning step categories
       */
      getStepEmoji(category) {
        switch (category) {
          case "analysis":
            return "\u{1F50D}";
          case "planning":
            return "\u{1F4CB}";
          case "problem-solving":
            return "\u{1F9E9}";
          case "reflection":
            return "\u{1F914}";
          case "conclusion":
            return "\u2705";
          case "reasoning":
            return "\u{1F9E0}";
          case "information":
            return "\u{1F4CA}";
          case "approach":
            return "\u{1F3AF}";
          case "evaluation":
            return "\u2696\uFE0F";
          case "synthesis":
            return "\u{1F517}";
          case "validation":
            return "\u2705";
          case "refinement":
            return "\u26A1";
          default:
            return "\u{1F4AD}";
        }
      }
      /**
       * Get task status text
       */
      getTaskStatusText(taskStatus) {
        switch (taskStatus.status) {
          case "idle":
            return "Task Ready";
          case "running":
            return "Task In Progress";
          case "stopped":
            return "Task Stopped";
          case "completed":
            return "Task Completed";
          case "limit_reached":
            return "Tool Limit Reached";
          case "waiting_for_user":
            return "Waiting for User Input";
          default:
            return "Unknown Status";
        }
      }
      /**
       * Get task status icon
       */
      getTaskStatusIcon(status) {
        switch (status) {
          case "idle":
            return "\u23F8\uFE0F";
          case "running":
            return "\u{1F504}";
          case "stopped":
            return "\u23F9\uFE0F";
          case "completed":
            return "\u2705";
          case "limit_reached":
            return "\u26A0\uFE0F";
          case "waiting_for_user":
            return "\u23F3";
          default:
            return "\u2753";
        }
      }
      /**
       * Render a complete message with tool displays if present
       */
      async renderMessage(message, container, component) {
        if (message.toolResults && message.toolResults.length > 0) {
          await this.renderMessageWithToolDisplays(message, container, component);
        } else {
          await this.renderRegularMessage(message, container, component);
        }
      }
      /**
       * Render message with embedded tool displays
       */
      async renderMessageWithToolDisplays(message, container, component) {
        var _a2;
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) return;
        messageContent.empty();
        container.classList.add("has-rich-tools");
        const parts = this.parseMessageWithTools(message.content);
        for (const part of parts) {
          if (part.type === "text" && ((_a2 = part.content) == null ? void 0 : _a2.trim())) {
            const textDiv = document.createElement("div");
            textDiv.className = "message-text-part";
            await import_obsidian16.MarkdownRenderer.render(this.app, part.content, textDiv, "", component || null);
            messageContent.appendChild(textDiv);
          } else if (part.type === "tool" && part.command && message.toolResults) {
            const toolExecutionResult = message.toolResults.find(
              (tr) => tr.command.action === part.command.action && this.compareToolParams(tr.command.parameters, part.command.parameters)
            );
            if (toolExecutionResult) {
              const richDisplay = new ToolRichDisplay({
                command: part.command,
                result: toolExecutionResult.result,
                onRerun: () => {
                  console.log("Re-run tool:", part.command);
                },
                onCopy: async () => {
                  const displayText = this.formatToolForCopy(part.command, toolExecutionResult.result);
                  try {
                    await navigator.clipboard.writeText(displayText);
                  } catch (error) {
                    console.error("Failed to copy tool result:", error);
                  }
                }
              });
              const toolWrapper = document.createElement("div");
              toolWrapper.className = "embedded-tool-display";
              toolWrapper.appendChild(richDisplay.getElement());
              messageContent.appendChild(toolWrapper);
            }
          }
        }
      }
      /**
       * Render regular message without tool displays
       */
      async renderRegularMessage(message, container, component) {
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) return;
        messageContent.empty();
        await import_obsidian16.MarkdownRenderer.render(this.app, message.content, messageContent, "", component || null);
      }
      /**
       * Parse message content to extract tool calls and text parts
       */
      parseMessageWithTools(content) {
        const parts = [];
        const toolCallRegex = /```json\s*\{[^}]*"action":\s*"([^"]+)"[^}]*\}[^`]*```/g;
        let lastIndex = 0;
        let match;
        while ((match = toolCallRegex.exec(content)) !== null) {
          if (match.index > lastIndex) {
            const textContent = content.slice(lastIndex, match.index).trim();
            if (textContent) {
              parts.push({ type: "text", content: textContent });
            }
          }
          try {
            const toolJson = match[0].replace(/```json\s*/, "").replace(/\s*```[\s\S]*?$/, "");
            const command = JSON.parse(toolJson);
            parts.push({ type: "tool", command });
          } catch (e) {
            parts.push({ type: "text", content: match[0] });
          }
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < content.length) {
          const remainingContent = content.slice(lastIndex).trim();
          if (remainingContent) {
            parts.push({ type: "text", content: remainingContent });
          }
        }
        if (parts.length === 0) {
          parts.push({ type: "text", content });
        }
        return parts;
      }
      /**
       * Compare tool parameters for matching
       */
      compareToolParams(params1, params2) {
        try {
          return JSON.stringify(params1) === JSON.stringify(params2);
        } catch (e) {
          return false;
        }
      }
      /**
      * Format tool execution for clipboard copy
      */
      formatToolForCopy(command, result) {
        const status = result.success ? "\u2705" : "\u274C";
        const statusText = result.success ? "SUCCESS" : "ERROR";
        let output = `${status} **${command.action}** ${statusText}`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          output += `

**Parameters:**
\`\`\`json
${JSON.stringify(command.parameters, null, 2)}
\`\`\``;
        }
        if (result.success) {
          output += `

**Result:**
\`\`\`json
${JSON.stringify(result.data, null, 2)}
\`\`\``;
        } else {
          output += `

**Error:**
${result.error}`;
        }
        return output;
      }
      /**
      * Get message content formatted for clipboard copy, including tool results
      */
      getMessageContentForCopy(messageData) {
        if (!messageData.toolResults || messageData.toolResults.length === 0) {
          return messageData.content;
        }
        const trimmedContent = messageData.content.trim();
        const isContentMostlyEmpty = trimmedContent === "" || trimmedContent.startsWith("*[Tool execution limit reached") || /^[\s\n]*\*.*\*[\s\n]*$/.test(trimmedContent);
        if (isContentMostlyEmpty) {
          let result2 = "";
          for (const toolResult of messageData.toolResults) {
            result2 += `

**Tool Execution:** ${toolResult.command.action}
`;
            result2 += `**Status:** ${toolResult.result.success ? "SUCCESS" : "ERROR"}

`;
            if (toolResult.command.parameters && Object.keys(toolResult.command.parameters).length > 0) {
              result2 += `**Parameters:**
\`\`\`json
${JSON.stringify(toolResult.command.parameters, null, 2)}
\`\`\`

`;
            }
            if (toolResult.result.success && toolResult.result.data) {
              result2 += `**Result:**
\`\`\`json
${JSON.stringify(toolResult.result.data, null, 2)}
\`\`\`
`;
            } else if (!toolResult.result.success && toolResult.result.error) {
              result2 += `**Error:**
${toolResult.result.error}
`;
            }
          }
          if (trimmedContent && !trimmedContent.startsWith("*[Tool execution limit reached")) {
            result2 = trimmedContent + result2;
          }
          return result2.trim();
        }
        const parts = this.parseMessageWithTools(messageData.content);
        let result = "";
        for (const part of parts) {
          if (part.type === "text") {
            result += part.content;
          } else if (part.type === "tool" && part.command) {
            const toolResult = messageData.toolResults.find(
              (tr) => {
                var _a2, _b;
                return tr.command.action === ((_a2 = part.command) == null ? void 0 : _a2.action) && this.compareToolParams(tr.command.parameters, (_b = part.command) == null ? void 0 : _b.parameters);
              }
            );
            if (toolResult) {
              result += `

**Tool Execution:** ${part.command.action}
`;
              result += `**Status:** ${toolResult.result.success ? "SUCCESS" : "ERROR"}

`;
              if (part.command.parameters && Object.keys(part.command.parameters).length > 0) {
                result += `**Parameters:**
\`\`\`json
${JSON.stringify(part.command.parameters, null, 2)}
\`\`\`

`;
              }
              if (toolResult.result.success) {
                result += `**Result:**
\`\`\`json
${JSON.stringify(toolResult.result.data, null, 2)}
\`\`\`
`;
              } else {
                result += `**Error:**
${toolResult.result.error}
`;
              }
            }
          }
        }
        return result;
      }
    };
  }
});

// src/components/chat/chatPersistence.ts
function buildChatYaml(settings, provider, model) {
  if (settings.selectedModel) {
    const providerType = getProviderFromUnifiedModel(settings.selectedModel);
    const modelId = getModelIdFromUnifiedModel(settings.selectedModel);
    const yamlObj = {
      provider: providerType,
      model: modelId,
      unified_model: settings.selectedModel,
      // Add unified model ID for future compatibility
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    return `---
${dump(yamlObj)}---
`;
  } else {
    const yamlObj = {
      provider: provider || settings.provider,
      model: model || getCurrentModelForProvider(settings),
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    return `---
${dump(yamlObj)}---
`;
  }
}
function getCurrentModelForProvider(settings) {
  switch (settings.provider) {
    case "openai":
      return settings.openaiSettings.model;
    case "anthropic":
      return settings.anthropicSettings.model;
    case "gemini":
      return settings.geminiSettings.model;
    case "ollama":
      return settings.ollamaSettings.model;
    default:
      return "";
  }
}
async function saveChatAsNote({
  app,
  messages,
  settings,
  provider,
  model,
  chatSeparator,
  chatNoteFolder,
  agentResponseHandler
}) {
  let chatContent = "";
  const messageRenderer = new MessageRenderer(app);
  messages.forEach((el, index) => {
    var _a2, _b;
    const htmlElement = el;
    if (htmlElement.classList.contains("tool-display-message")) {
      return;
    }
    const messageDataStr = htmlElement.dataset.messageData;
    let messageData = null;
    if (messageDataStr) {
      try {
        messageData = JSON.parse(messageDataStr);
      } catch (e) {
        console.log("Failed to parse message data:", e);
      }
    }
    console.log("DEBUG saveChatAsNote - Message data:", {
      hasMessageData: !!messageData,
      hasToolResults: messageData && messageData.toolResults && messageData.toolResults.length > 0,
      toolResultsLength: ((_a2 = messageData == null ? void 0 : messageData.toolResults) == null ? void 0 : _a2.length) || 0,
      messageDataStr: (messageDataStr == null ? void 0 : messageDataStr.substring(0, 200)) + "..."
    });
    if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
      chatContent += messageRenderer.getMessageContentForCopy(messageData);
    } else {
      const rawContent = htmlElement.dataset.rawContent;
      const content = rawContent !== void 0 ? rawContent : ((_b = el.querySelector(".message-content")) == null ? void 0 : _b.textContent) || "";
      chatContent += content;
    }
    if (index < messages.length - 1) {
      chatContent += "\n\n" + chatSeparator + "\n\n";
    }
  });
  const yaml = buildChatYaml(settings, provider, model);
  chatContent = chatContent.replace(/^---[\s\S]*?---\n?/, "");
  const noteContent = yaml + "\n" + chatContent.trimStart();
  const now = /* @__PURE__ */ new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const fileName = `Chat Export ${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}-${pad(now.getMinutes())}.md`;
  let filePath = fileName;
  const folder = chatNoteFolder == null ? void 0 : chatNoteFolder.trim();
  if (folder) {
    filePath = folder.replace(/[/\\]+$/, "") + "/" + fileName;
  }
  try {
    await app.vault.create(filePath, noteContent);
    new import_obsidian18.Notice(`Chat saved as note: ${filePath}`);
  } catch (e) {
    new import_obsidian18.Notice("Failed to save chat as note.");
  }
}
async function loadChatYamlAndApplySettings({
  app,
  plugin,
  settings,
  file
}) {
  let content = await app.vault.read(file);
  const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
  let yamlObj = {};
  if (yamlMatch) {
    try {
      yamlObj = load(yamlMatch[1]) || {};
    } catch (e) {
      yamlObj = {};
    }
  }
  if (yamlObj.unified_model) {
    settings.selectedModel = yamlObj.unified_model;
  } else if (yamlObj.provider && yamlObj.model) {
    const unifiedModelId = `${yamlObj.provider}:${yamlObj.model}`;
    settings.selectedModel = unifiedModelId;
    settings.provider = yamlObj.provider;
    switch (yamlObj.provider) {
      case "openai":
        settings.openaiSettings.model = yamlObj.model;
        break;
      case "anthropic":
        settings.anthropicSettings.model = yamlObj.model;
        break;
      case "gemini":
        settings.geminiSettings.model = yamlObj.model;
        break;
      case "ollama":
        settings.ollamaSettings.model = yamlObj.model;
        break;
    }
  }
  let newSystemMessage = yamlObj.system_message || settings.systemMessage;
  let newTemperature = settings.temperature;
  if (yamlObj.temperature !== void 0) {
    const tempNum = parseFloat(yamlObj.temperature);
    if (!isNaN(tempNum)) newTemperature = tempNum;
  }
  settings.systemMessage = newSystemMessage;
  settings.temperature = newTemperature;
  if (plugin.onSettingsLoadedFromNote) {
    plugin.onSettingsLoadedFromNote(settings);
  }
  return {
    provider: yamlObj.provider,
    model: yamlObj.model,
    unifiedModel: settings.selectedModel,
    systemMessage: newSystemMessage,
    temperature: newTemperature
  };
}
var import_obsidian18;
var init_chatPersistence = __esm({
  "src/components/chat/chatPersistence.ts"() {
    import_obsidian18 = require("obsidian");
    init_js_yaml();
    init_providers();
    init_MessageRenderer();
  }
});

// src/components/chat/ChatHelpModal.ts
var import_obsidian19, ChatHelpModal;
var init_ChatHelpModal = __esm({
  "src/components/chat/ChatHelpModal.ts"() {
    import_obsidian19 = require("obsidian");
    ChatHelpModal = class extends import_obsidian19.Modal {
      constructor(app) {
        super(app);
      }
      createCollapsibleSection(title, contentCallback, expanded = true) {
        const sectionContainer = createDiv();
        sectionContainer.addClass("ai-collapsible-section");
        const header = createDiv();
        header.addClass("ai-collapsible-header");
        const arrow = createSpan();
        arrow.addClass("ai-collapsible-arrow");
        arrow.textContent = expanded ? "\u25BC" : "\u25B6";
        const titleSpan = createSpan();
        titleSpan.textContent = title;
        header.appendChild(arrow);
        header.appendChild(titleSpan);
        const content = createDiv();
        content.addClass("ai-collapsible-content");
        content.style.display = expanded ? "block" : "none";
        header.addEventListener("click", () => {
          const isExpanded = content.style.display !== "none";
          content.style.display = isExpanded ? "none" : "block";
          arrow.textContent = isExpanded ? "\u25B6" : "\u25BC";
        });
        sectionContainer.appendChild(header);
        sectionContainer.appendChild(content);
        const originalContent = this.contentEl;
        this.contentEl = content;
        contentCallback();
        this.contentEl = originalContent;
        return sectionContainer;
      }
      onOpen() {
        this.titleEl.setText("AI Chat Help");
        this.contentEl.empty();
        this.contentEl.appendChild(this.createCollapsibleSection("Slash Commands", () => {
          this.contentEl.innerHTML = `
                <code>/clear</code> \u2013 Clear the chat<br>
                <code>/copy</code> \u2013 Copy all chat<br>
                <code>/save</code> \u2013 Save chat as note<br>
                <code>/settings</code> \u2013 Open settings<br>
                <code>/help</code> \u2013 Show this help<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Keyboard Shortcuts (when chat window or input is focused)", () => {
          this.contentEl.innerHTML = `
                <code>Ctrl+Shift+X</code> \u2013 Clear chat<br>
                <code>Ctrl+Shift+C</code> \u2013 Copy all chat<br>
                <code>Ctrl+Shift+S</code> \u2013 Save as note<br>
                <code>Ctrl+Shift+O</code> \u2013 Open settings<br>
                <code>Ctrl+Shift+H</code> \u2013 Show this help<br>
                <code>Ctrl+Shift+R</code> \u2013 Toggle referencing current note<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Other", () => {
          this.contentEl.innerHTML = `
                <code>Enter</code> \u2013 Send message<br>
                <code>Shift+Enter</code> \u2013 Newline<br>
                <br>
                You can also use the buttons at the top of the chat window.
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Reference Current Note", () => {
          this.contentEl.innerHTML = `
                <strong>What is it?</strong><br>
                When enabled, the AI can see the content of your currently active note during chat. This helps the AI give more relevant, context-aware responses.<br><br>

                <strong>How to use:</strong><br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>Click the <code>\u{1F4DD}</code> button at the top of the chat window to toggle referencing the current note.</li>
                  <li>Or use the slash command <code>/ref</code> or keyboard shortcut <code>Ctrl+Shift+R</code>.</li>
                  <li>The name of the referenced note will appear in faded small text below the buttons when enabled.</li>
                </ul>

                <strong>Notes:</strong><br>
                - When referencing is enabled, the AI receives:<br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>The system prompt (always)</li>
                  <li>Context notes (if enabled in settings)</li>
                  <li>The content of the currently active note</li>
                  <li>The chat history (all previous user/assistant messages)</li>
                </ul>
                - Only the currently active note is shared in addition to the above context.<br>
                - You can turn this on or off at any time.<br>
                - No other notes or personal data are accessed.<br>
                - The <code>\u{1F4DD}</code> button will show "On" or "Off" to indicate the current state.
            `;
        }));
      }
    };
  }
});

// src/components/chat/SettingsModal.ts
var SettingsModal_exports = {};
__export(SettingsModal_exports, {
  SettingsModal: () => SettingsModal
});
var import_obsidian20, SettingsModal;
var init_SettingsModal = __esm({
  "src/components/chat/SettingsModal.ts"() {
    import_obsidian20 = require("obsidian");
    init_SettingsSections();
    SettingsModal = class extends import_obsidian20.Modal {
      constructor(app, plugin) {
        super(app);
        __publicField(this, "plugin");
        __publicField(this, "settingsSections");
        __publicField(this, "_onSettingsChange", () => {
          this.onOpen();
        });
        this.plugin = plugin;
        this.settingsSections = new SettingsSections(plugin);
        this.titleEl.setText("AI Model Settings");
        this.plugin.onSettingsChange(this._onSettingsChange);
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("ai-settings-modal");
        await this.settingsSections.renderAllSettings(contentEl, { onRefresh: () => this.onOpen() });
      }
      onClose() {
        this.plugin.offSettingsChange(this._onSettingsChange);
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/eventHandlers.ts
function handleCopyAll(messagesContainer, plugin) {
  return async () => {
    const messages = messagesContainer.querySelectorAll(".ai-chat-message");
    let chatContent = "";
    messages.forEach((el, index) => {
      var _a2, _b;
      const htmlElement = el;
      if (htmlElement.classList.contains("tool-display-message")) {
        return;
      }
      let messageData = null;
      const messageDataStr = htmlElement.dataset.messageData;
      if (messageDataStr) {
        try {
          messageData = JSON.parse(messageDataStr);
        } catch (e) {
        }
      }
      console.log("DEBUG handleCopyAll - Message data:", {
        hasMessageData: !!messageData,
        hasToolResults: messageData && messageData.toolResults && messageData.toolResults.length > 0,
        toolResultsLength: ((_a2 = messageData == null ? void 0 : messageData.toolResults) == null ? void 0 : _a2.length) || 0,
        messageDataStr: (messageDataStr == null ? void 0 : messageDataStr.substring(0, 200)) + "..."
      });
      if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
        const renderer = new MessageRenderer(plugin.app);
        chatContent += renderer.getMessageContentForCopy(messageData);
      } else {
        const rawContent = htmlElement.dataset.rawContent;
        const content = rawContent !== void 0 ? rawContent : ((_b = el.querySelector(".message-content")) == null ? void 0 : _b.textContent) || "";
        chatContent += content;
      }
      if (index < messages.length - 1) {
        chatContent += "\n\n" + plugin.settings.chatSeparator + "\n\n";
      }
    });
    await copyToClipboard(chatContent);
  };
}
function handleSaveNote(messagesContainer, plugin, app, agentResponseHandler) {
  return async () => {
    await saveChatAsNote({
      app,
      messages: messagesContainer.querySelectorAll(".ai-chat-message"),
      settings: plugin.settings,
      chatSeparator: plugin.settings.chatSeparator,
      chatNoteFolder: plugin.settings.chatNoteFolder,
      agentResponseHandler
    });
  };
}
function handleClearChat(messagesContainer, chatHistoryManager) {
  return async () => {
    messagesContainer.empty();
    try {
      await chatHistoryManager.clearHistory();
    } catch (e) {
      new import_obsidian21.Notice("Failed to clear chat history.");
    }
  };
}
function handleSettings(app, plugin) {
  return () => {
    const { SettingsModal: SettingsModal2 } = (init_SettingsModal(), __toCommonJS(SettingsModal_exports));
    const settingsModal = new SettingsModal2(app, plugin);
    settingsModal.open();
  };
}
function handleHelp(app) {
  return () => {
    new ChatHelpModal(app).open();
  };
}
var import_obsidian21;
var init_eventHandlers = __esm({
  "src/components/chat/eventHandlers.ts"() {
    init_Buttons();
    init_chatPersistence();
    init_ChatHelpModal();
    import_obsidian21 = require("obsidian");
    init_MessageRenderer();
  }
});

// src/components/chat/BotMessage.ts
var BotMessage_exports = {};
__export(BotMessage_exports, {
  BotMessage: () => BotMessage
});
var import_obsidian24, BotMessage;
var init_BotMessage = __esm({
  "src/components/chat/BotMessage.ts"() {
    import_obsidian24 = require("obsidian");
    init_Buttons();
    BotMessage = class extends import_obsidian24.Component {
      constructor(app, plugin, content) {
        super();
        __publicField(this, "app");
        __publicField(this, "plugin");
        __publicField(this, "content");
        __publicField(this, "element");
        __publicField(this, "contentEl");
        this.app = app;
        this.plugin = plugin;
        this.content = content;
        this.element = this.createMessageElement();
      }
      getElement() {
        return this.element;
      }
      getContent() {
        return this.content;
      }
      async setContent(content) {
        this.content = content;
        this.element.dataset.rawContent = content;
        this.contentEl.empty();
        await import_obsidian24.MarkdownRenderer.render(
          this.app,
          content,
          this.contentEl,
          "",
          this
        );
      }
      createMessageElement() {
        const messageEl = document.createElement("div");
        messageEl.addClass("ai-chat-message", "assistant");
        messageEl.dataset.rawContent = this.content;
        const messageContainer = messageEl.createDiv("message-container");
        this.contentEl = messageContainer.createDiv("message-content");
        import_obsidian24.MarkdownRenderer.render(
          this.app,
          this.content,
          this.contentEl,
          "",
          this
        );
        const buttons = new Buttons();
        const actions = buttons.createMessageActions([
          {
            label: "Copy",
            tooltip: "Copy message",
            onClick: async () => {
              const content = messageEl.dataset.rawContent || "";
              if (content.trim() === "") return;
              await navigator.clipboard.writeText(content);
            }
          },
          {
            label: "Edit",
            tooltip: "Edit message",
            onClick: () => {
              const wasEditing = this.contentEl.hasClass("editing");
              if (!wasEditing) {
                const textarea = document.createElement("textarea");
                textarea.value = messageEl.dataset.rawContent || "";
                this.contentEl.empty();
                this.contentEl.appendChild(textarea);
                textarea.focus();
                this.contentEl.addClass("editing");
              } else {
                const textarea = this.contentEl.querySelector("textarea");
                if (textarea) {
                  this.setContent(textarea.value);
                  this.contentEl.removeClass("editing");
                }
              }
            }
          },
          {
            label: "Delete",
            tooltip: "Delete message",
            onClick: () => {
              messageEl.remove();
            }
          },
          {
            label: "Regenerate",
            tooltip: "Regenerate this response",
            onClick: () => {
              const event = new CustomEvent("ai-assistant:regenerate-response", {
                detail: { messageEl }
              });
              this.app.workspace.trigger("ai-assistant:regenerate-response", messageEl);
            }
          }
        ]);
        messageEl.addEventListener("mouseenter", () => {
        });
        messageEl.addEventListener("mouseleave", () => {
        });
        messageContainer.appendChild(actions);
        return messageEl;
      }
    };
  }
});

// src/components/chat/inputHandler.ts
var inputHandler_exports = {};
__export(inputHandler_exports, {
  setupInputHandler: () => setupInputHandler
});
function setupInputHandler(textarea, messagesContainer, sendMessage, handleSlashCommand, app, plugin, sendButton, stopButton) {
  const handleKeyboardShortcuts = async (e) => {
    if (e.ctrlKey && e.shiftKey) {
      if (e.key.toLowerCase() === "x") {
        e.preventDefault();
        await handleSlashCommand("/clear");
        return true;
      }
      if (e.key.toLowerCase() === "c") {
        e.preventDefault();
        await handleSlashCommand("/copy");
        return true;
      }
      if (e.key.toLowerCase() === "s") {
        e.preventDefault();
        await handleSlashCommand("/save");
        return true;
      }
      if (e.key.toLowerCase() === "o") {
        e.preventDefault();
        await handleSlashCommand("/settings");
        return true;
      }
      if (e.key.toLowerCase() === "h") {
        e.preventDefault();
        handleHelp(app)();
        return true;
      }
      if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        await handleSlashCommand("/ref");
        return true;
      }
    }
    return false;
  };
  textarea.addEventListener("keydown", async (e) => {
    if (await handleKeyboardShortcuts(e)) return;
    if (e.key === "Enter" && !e.shiftKey) {
      const val = textarea.value.trim();
      if (val === "/clear" || val === "/copy" || val === "/save" || val === "/settings" || val === "/help" || val === "/ref") {
        e.preventDefault();
        await handleSlashCommand(val);
        textarea.value = "";
        return;
      }
      await sendMessage();
      e.preventDefault();
    }
  });
  messagesContainer.addEventListener("keydown", async (e) => {
    await handleKeyboardShortcuts(e);
  });
}
var init_inputHandler = __esm({
  "src/components/chat/inputHandler.ts"() {
    init_eventHandlers();
  }
});

// src/YAMLHandler.ts
var YAMLHandler_exports = {};
__export(YAMLHandler_exports, {
  generateNoteTitle: () => generateNoteTitle,
  generateYamlAttribute: () => generateYamlAttribute,
  upsertYamlField: () => upsertYamlField
});
function generateTableOfContents(noteContent) {
  const headerLines = noteContent.split("\n").filter((line) => /^#{1,6}\s+.+/.test(line));
  if (headerLines.length === 0) return "";
  return headerLines.map((line) => {
    const match = line.match(/^(#{1,6})\s+(.+)/);
    if (!match) return "";
    const level = match[1].length;
    const title = match[2].trim();
    return `${"  ".repeat(level - 1)}- ${title}`;
  }).join("\n");
}
function debug2(...args) {
  if (DEBUG) {
    console.log("[DEBUG]", ...args);
  }
}
async function generateNoteTitle(app, settings, processMessages2) {
  var _a2, _b;
  debug2("Starting generateNoteTitle");
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian6.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const toc = generateTableOfContents(noteContent);
  const prompt = DEFAULT_TITLE_PROMPT;
  const userContent = (toc && toc.trim().length > 0 ? "Table of Contents:\n" + toc + "\n\n" : "") + noteContent;
  try {
    debug2("Provider:", settings.provider);
    const provider = settings.selectedModel ? createProviderFromUnifiedModel(settings, settings.selectedModel) : createProvider(settings);
    const messages = [
      { role: "system", content: prompt },
      { role: "user", content: userContent }
    ];
    debug2("Original messages:", JSON.stringify(messages));
    const originalEnableContextNotes = settings.enableContextNotes;
    debug2("Original enableContextNotes:", originalEnableContextNotes);
    settings.enableContextNotes = false;
    try {
      const processedMessages = await processMessages2(messages);
      debug2("Processed messages:", JSON.stringify(processedMessages));
      settings.enableContextNotes = originalEnableContextNotes;
      if (!processedMessages || processedMessages.length === 0) {
        debug2("No processed messages!");
        new import_obsidian6.Notice("No valid messages to send to the model. Please check your note content.");
        return;
      }
      debug2("Calling provider.getCompletion");
      let resultBuffer = "";
      await provider.getCompletion(processedMessages, {
        temperature: 0,
        streamCallback: (chunk) => {
          resultBuffer += chunk;
        }
      });
      debug2("Result from provider (buffered):", resultBuffer);
      let title = resultBuffer.trim();
      debug2("Extracted title before sanitization:", title);
      title = title.replace(/[\\/:]/g, "").trim();
      debug2("Sanitized title:", title);
      if (title && typeof title === "string" && title.length > 0) {
        const outputMode = (_a2 = settings.titleOutputMode) != null ? _a2 : "clipboard";
        debug2("Output mode:", outputMode);
        if (outputMode === "replace-filename") {
          const file = app.workspace.getActiveFile();
          if (file) {
            const ext = file.extension ? "." + file.extension : "";
            const sanitized = title;
            const parentPath = file.parent ? file.parent.path : "";
            const newPath = parentPath ? parentPath + "/" + sanitized + ext : sanitized + ext;
            if (file.path !== newPath) {
              await app.fileManager.renameFile(file, newPath);
              new import_obsidian6.Notice(`Note renamed to: ${sanitized}${ext}`);
            } else {
              new import_obsidian6.Notice(`Note title is already: ${sanitized}${ext}`);
            }
          }
        } else if (outputMode === "metadata") {
          const file = app.workspace.getActiveFile();
          if (file) {
            await upsertYamlField(app, file, "title", title);
            new import_obsidian6.Notice(`Inserted title into metadata: ${title}`);
          }
        } else {
          try {
            await navigator.clipboard.writeText(title);
            new import_obsidian6.Notice(`Generated title (copied): ${title}`);
          } catch (e) {
            new import_obsidian6.Notice(`Generated title: ${title}`);
          }
        }
      } else {
        debug2("No title generated after sanitization.");
        new import_obsidian6.Notice("No title generated.");
      }
    } catch (processError) {
      debug2("Error in processMessages or provider.getCompletion:", processError);
      settings.enableContextNotes = originalEnableContextNotes;
      throw processError;
    }
  } catch (err) {
    new import_obsidian6.Notice("Error generating title: " + ((_b = err == null ? void 0 : err.message) != null ? _b : err));
  }
}
async function generateYamlAttribute(app, settings, processMessages2, attributeName, prompt, outputMode = "metadata") {
  debug2(`Starting generateYamlAttribute for ${attributeName}`);
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian6.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const toc = generateTableOfContents(noteContent);
  let prompt = settings.summaryPrompt + "\n\n";
  if (toc && toc.trim().length > 0) {
    prompt += "Table of Contents:\n" + toc + "\n\n";
  }
  prompt += noteContent;
  try {
    debug2("Provider:", settings.provider);
    const provider = createProvider(settings);
    const messages = [
      { role: "system", content: settings.summaryPrompt },
      { role: "user", content: (toc && toc.trim().length > 0 ? "Table of Contents:\n" + toc + "\n\n" : "") + noteContent }
    ];
    debug2("Original messages:", JSON.stringify(messages));
    const originalEnableContextNotes = settings.enableContextNotes;
    debug2("Original enableContextNotes:", originalEnableContextNotes);
    settings.enableContextNotes = false;
    try {
      const processedMessages = await processMessages2(messages);
      debug2("Processed messages:", JSON.stringify(processedMessages));
      settings.enableContextNotes = originalEnableContextNotes;
      if (!processedMessages || processedMessages.length === 0) {
        debug2("No processed messages!");
        new import_obsidian6.Notice("No valid messages to send to the model. Please check your note content.");
        return;
      }
      debug2("Calling provider.getCompletion");
      let resultBuffer = "";
      await provider.getCompletion(processedMessages, {
        temperature: 0,
        streamCallback: (chunk) => {
          resultBuffer += chunk;
        }
      });
      debug2("Result from provider (buffered):", resultBuffer);
      let summary = resultBuffer.trim();
      debug2("Extracted summary before sanitization:", summary);
      summary = summary.replace(/[\\/:]/g, "").trim();
      debug2("Sanitized summary:", summary);
      if (summary && typeof summary === "string" && summary.length > 0) {
        const outputMode = (_a2 = settings.summaryOutputMode) != null ? _a2 : "clipboard";
        debug2("Output mode:", outputMode);
        if (outputMode === "metadata") {
          const file = app.workspace.getActiveFile();
          if (file) {
            await upsertYamlField(app, file, "abstract", summary);
            new import_obsidian6.Notice(`Inserted summary into metadata: ${summary}`);
          }
        } else {
          try {
            await navigator.clipboard.writeText(summary);
            new import_obsidian6.Notice(`Generated summary (copied): ${summary}`);
          } catch (e) {
            new import_obsidian6.Notice(`Generated summary: ${summary}`);
          }
        }
      } else {
        debug2("No summary generated after sanitization.");
        new import_obsidian6.Notice("No summary generated.");
      }
    } catch (processError) {
      debug2("Error in processMessages or provider.getCompletion:", processError);
      settings.enableContextNotes = originalEnableContextNotes;
      throw processError;
    }
  } catch (err) {
    new import_obsidian6.Notice("Error generating summary: " + ((_b = err == null ? void 0 : err.message) != null ? _b : err));
  }
}
async function upsertYamlField(app, file, field, value) {
  let content = await app.vault.read(file);
  let newContent = content;
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  if (match) {
    let yamlObj = {};
    try {
      yamlObj = load(match[1]) || {};
    } catch (e) {
      yamlObj = {};
    }
    yamlObj[field] = value;
    const newYaml = dump(yamlObj, { lineWidth: -1 }).trim();
    newContent = content.replace(frontmatterRegex, `---
${newYaml}
---`);
  } else {
    const newYaml = dump({ [field]: value }, { lineWidth: -1 }).trim();
    newContent = `---
${newYaml}
---
` + content;
  }
  await app.vault.modify(file, newContent);
}
var import_obsidian6, DEBUG;
var init_filechanger = __esm({
  "src/filechanger.ts"() {
    import_obsidian6 = require("obsidian");
    init_providers();
    init_promptConstants();
    init_js_yaml();
    DEBUG = true;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  VIEW_TYPE_MODEL_SETTINGS: () => VIEW_TYPE_MODEL_SETTINGS,
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian11 = require("obsidian");
init_SettingsSections();

// src/components/chat/CollapsibleSection.ts
var CollapsibleSectionRenderer = class {
  /**
   * Creates a collapsible section with a header that can be toggled
   */
  static createCollapsibleSection(containerEl, title, contentCallback, plugin, settingsType) {
    var _a2;
    plugin.settings[settingsType] = plugin.settings[settingsType] || {};
    let isExpanded = (_a2 = plugin.settings[settingsType][title]) != null ? _a2 : false;
    const collapsibleContainer = containerEl.createEl("div");
    collapsibleContainer.addClass("ai-collapsible-section");
    const headerEl = collapsibleContainer.createEl("div");
    headerEl.addClass("ai-collapsible-header");
    const arrow = headerEl.createEl("span");
    arrow.addClass("ai-collapsible-arrow");
    arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
    const titleSpan = headerEl.createEl("span");
    titleSpan.textContent = title;
    const contentEl = collapsibleContainer.createEl("div");
    contentEl.addClass("ai-collapsible-content");
    contentEl.style.display = isExpanded ? "block" : "none";
    headerEl.addEventListener("click", async () => {
      isExpanded = !isExpanded;
      contentEl.style.display = isExpanded ? "block" : "none";
      arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
      plugin.settings[settingsType][title] = isExpanded;
      await plugin.saveSettings();
    });
    const result = contentCallback(contentEl);
    if (result instanceof Promise) {
      result.catch((error) => console.error("Error in collapsible section:", error));
    }
  }
};

// src/settings.ts
init_toolcollect();
init_providers();
var MyPluginSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    __publicField(this, "settingsSections");
    this.plugin = plugin;
    this.settingsSections = new SettingsSections(this.plugin);
  }
  /**
   * Creates a text input setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param placeholder The placeholder text for the input.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   * @param options Additional options for the text input (e.g., trim, undefinedIfEmpty, isTextArea).
   */
  createTextSetting(containerEl, name, desc, placeholder, getValue, setValue, options) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).then((setting) => {
      const textInputOptions = {
        trim: options == null ? void 0 : options.trim,
        undefinedIfEmpty: options == null ? void 0 : options.undefinedIfEmpty
      };
      if (options == null ? void 0 : options.isTextArea) {
        setting.addTextArea((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      } else {
        setting.addText((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      }
    });
  }
  /**
   * Configures a text input (either single-line or multi-line).
   * @param textComponent The TextComponent or TextAreaComponent to configure.
   * @param placeholder The placeholder text.
   * @param getValue A function to get the current value.
   * @param setValue A function to set the new value.
   * @param options Additional options for processing the input value (e.g., trim, undefinedIfEmpty).
   */
  configureTextInput(textComponent, placeholder, getValue, setValue, options) {
    var _a2;
    textComponent.setPlaceholder(placeholder).setValue((_a2 = getValue()) != null ? _a2 : "").onChange(async (value) => {
      let processedValue = value;
      if (options == null ? void 0 : options.trim) {
        processedValue = processedValue.trim();
      }
      if ((options == null ? void 0 : options.undefinedIfEmpty) && processedValue === "") {
        processedValue = void 0;
      }
      await setValue(processedValue);
    });
  }
  /**
   * Creates a dropdown setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param options A record of option values to display names.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   */
  createDropdownSetting(containerEl, name, desc, options, getValue, setValue) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).addDropdown((drop) => {
      Object.entries(options).forEach(([key, display]) => drop.addOption(key, display));
      drop.setValue(getValue());
      drop.onChange(async (value) => {
        await setValue(value);
      });
    });
  }
  /**
   * Creates a toggle (checkbox) setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param getValue A function to get the current boolean value.
   * @param setValue A function to set the new boolean value.
   * @param onChangeCallback An optional callback to run after the value changes and settings are saved.
   */
  createToggleSetting(containerEl, name, desc, getValue, setValue, onChangeCallback) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).addToggle((toggle) => toggle.setValue(getValue()).onChange(async (value) => {
      await setValue(value);
      if (onChangeCallback) {
        onChangeCallback();
      }
    }));
  }
  /**
   * Creates a slider setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param limits An object defining min, max, and step for the slider.
   * @param getValue A function to get the current numeric value.
   * @param setValue A function to set the new numeric value.
   */
  createSliderSetting(containerEl, name, desc, limits, getValue, setValue) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).addSlider((slider) => {
      slider.setLimits(limits.min, limits.max, limits.step).setValue(getValue()).setDynamicTooltip().onChange(async (value) => {
        await setValue(value);
      });
    });
  }
  /**
   * Renders the YAML Attribute Generators section.
   * @param containerEl The HTML element to append the section to.
   */
  renderYamlAttributeGenerators(containerEl) {
    var _a2;
    containerEl.createEl("h3", { text: "YAML Attribute Generators" });
    containerEl.createEl("div", { text: "Configure custom YAML attribute generators. Each entry will create a command to generate and insert/update a YAML field in your notes." }).style.marginBottom = "1em";
    const yamlGens = (_a2 = this.plugin.settings.yamlAttributeGenerators) != null ? _a2 : [];
    yamlGens.forEach((gen, idx) => {
      const autoCommandName = gen.attributeName ? `Generate YAML: ${gen.attributeName}` : `YAML Generator #${idx + 1}`;
      new import_obsidian11.Setting(containerEl).setName(autoCommandName).setDesc(`YAML field: ${gen.attributeName}`).addText((text) => this.configureTextInput(text, "YAML Attribute Name", () => gen.attributeName, async (value) => {
        if (this.plugin.settings.yamlAttributeGenerators) {
          this.plugin.settings.yamlAttributeGenerators[idx].attributeName = value != null ? value : "";
          this.plugin.settings.yamlAttributeGenerators[idx].commandName = value ? `Generate YAML: ${value}` : "";
          await this.plugin.saveSettings();
          this.display();
        }
      })).addTextArea((text) => this.configureTextInput(text, "Prompt for LLM", () => gen.prompt, async (value) => {
        if (this.plugin.settings.yamlAttributeGenerators) {
          this.plugin.settings.yamlAttributeGenerators[idx].prompt = value != null ? value : "";
          await this.plugin.saveSettings();
        }
      })).addDropdown((drop) => {
        drop.addOption("clipboard", "Copy to clipboard");
        drop.addOption("metadata", "Insert into metadata");
        drop.setValue(gen.outputMode);
        drop.onChange(async (value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].outputMode = value;
            await this.plugin.saveSettings();
          }
        });
      }).addExtraButton((btn) => {
        btn.setIcon("cross").setTooltip("Delete").onClick(async () => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators.splice(idx, 1);
            await this.plugin.saveSettings();
            this.display();
          }
        });
      });
    });
    new import_obsidian11.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add YAML Attribute Generator").setCta().onClick(async () => {
        if (!this.plugin.settings.yamlAttributeGenerators) this.plugin.settings.yamlAttributeGenerators = [];
        this.plugin.settings.yamlAttributeGenerators.push({
          attributeName: "",
          prompt: "",
          outputMode: "metadata",
          commandName: "New YAML Generator"
        });
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  /**
   * Renders the Model Setting Presets section.
   * @param containerEl The HTML element to append the section to.
   */
  renderModelSettingPresets(containerEl) {
    containerEl.createEl("h3", { text: "Model Setting Presets" });
    containerEl.createEl("div", {
      text: "Presets let you save and quickly apply common model settings (model, temperature, system message, etc). You can add, edit, or remove presets here. In the AI Model Settings panel, you will see buttons for each preset above the model selection. Clicking a preset button will instantly apply those settings. This is useful for switching between different model configurations with one click.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const presetList = this.plugin.settings.modelSettingPresets || [];
    presetList.forEach((preset, idx) => {
      new import_obsidian11.Setting(containerEl).setName("Preset Name").setDesc("Edit the name of this preset").addText((text) => {
        text.setPlaceholder("Preset Name").setValue(preset.name).onChange(async (value) => {
          preset.name = value != null ? value : "";
          await this.plugin.saveSettings();
          this.display();
        });
      });
      new import_obsidian11.Setting(containerEl).setName("Model ID (provider:model)").setDesc("Edit the model for this preset").addText((text) => {
        text.setPlaceholder("Model ID (provider:model)").setValue(preset.selectedModel || "").onChange(async (value) => {
          preset.selectedModel = value != null ? value : "";
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(containerEl).setName("System Message").setDesc("Edit the system message for this preset").addTextArea((text) => {
        text.setPlaceholder("System message").setValue(preset.systemMessage || "").onChange(async (value) => {
          preset.systemMessage = value != null ? value : "";
          await this.plugin.saveSettings();
        });
      });
      this.createSliderSetting(containerEl, "Temperature", "", { min: 0, max: 1, step: 0.1 }, () => {
        var _a2;
        return (_a2 = preset.temperature) != null ? _a2 : 0.7;
      }, async (value) => {
        preset.temperature = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian11.Setting(containerEl).setName("Max Tokens").setDesc("Edit the max tokens for this preset").addText((text) => {
        var _a2;
        text.setPlaceholder("Max tokens").setValue(((_a2 = preset.maxTokens) == null ? void 0 : _a2.toString()) || "").onChange(async (value) => {
          const num = parseInt(value != null ? value : "", 10);
          preset.maxTokens = isNaN(num) ? void 0 : num;
          await this.plugin.saveSettings();
        });
      });
      this.createToggleSetting(containerEl, "Enable Streaming", "", () => {
        var _a2;
        return (_a2 = preset.enableStreaming) != null ? _a2 : true;
      }, async (value) => {
        preset.enableStreaming = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian11.Setting(containerEl).addExtraButton(
        (btn) => btn.setIcon("cross").setTooltip("Delete").onClick(async () => {
          var _a2;
          (_a2 = this.plugin.settings.modelSettingPresets) == null ? void 0 : _a2.splice(idx, 1);
          await this.plugin.saveSettings();
          this.display();
        })
      );
    });
    new import_obsidian11.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Add Preset").setCta().onClick(async () => {
        if (!this.plugin.settings.modelSettingPresets) this.plugin.settings.modelSettingPresets = [];
        this.plugin.settings.modelSettingPresets.push(JSON.parse(JSON.stringify({
          name: `Preset ${this.plugin.settings.modelSettingPresets.length + 1}`,
          selectedModel: this.plugin.settings.selectedModel,
          systemMessage: this.plugin.settings.systemMessage,
          temperature: this.plugin.settings.temperature,
          maxTokens: this.plugin.settings.maxTokens,
          enableStreaming: this.plugin.settings.enableStreaming
        })));
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  /**
   * Renders the Tool Enable/Disable section.
   * @param containerEl The HTML element to append the section to.
   */
  renderToolToggles(containerEl) {
    containerEl.createEl("h3", { text: "Agent Tools" });
    containerEl.createEl("div", {
      text: "Enable or disable individual agent tools. Disabled tools will not be available to the agent or appear in the system prompt.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const tools = createToolInstances(this.app, this.plugin);
    if (!this.plugin.settings.enabledTools) {
      console.log("[AI Assistant] Settings: Initializing enabledTools object.");
      this.plugin.settings.enabledTools = {};
    }
    console.log("[AI Assistant] Settings: Current enabledTools before processing:", JSON.stringify(this.plugin.settings.enabledTools));
    tools.forEach((tool) => {
      if (!tool) {
        console.error("[AI Assistant] Settings: Encountered an undefined tool object in tools array!");
        return;
      }
      console.log(`[AI Assistant] Settings: Processing tool for UI - Name: ${tool.name}, Description: ${tool.description}`);
      if (typeof tool.name === "undefined") {
        console.error("[AI Assistant] Settings: CRITICAL - Tool object has undefined name:", tool);
      }
      this.createToggleSetting(
        containerEl,
        `${tool.name} (${tool.description})`,
        `Enable or disable the "${tool.name}" tool.`,
        () => {
          console.log(`[AI Assistant] Settings: Getting toggle state for tool: ${tool.name}`);
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to get toggle state for tool with undefined name!");
            return false;
          }
          return !!this.plugin.settings.enabledTools && this.plugin.settings.enabledTools[tool.name] !== false;
        },
        async (value) => {
          console.log(`[AI Assistant] Settings: Setting toggle state for tool: ${tool.name} to ${value}`);
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to set toggle state for tool with undefined name! Skipping save.");
            return;
          }
          if (!this.plugin.settings.enabledTools) {
            this.plugin.settings.enabledTools = {};
          }
          this.plugin.settings.enabledTools[tool.name] = value;
          await this.plugin.saveSettings();
          console.log("[AI Assistant] Settings: Saved enabledTools:", JSON.stringify(this.plugin.settings.enabledTools));
        }
      );
    });
  }
  /**
   * Renders the Available Models section with checkboxes for each model.
   * @param containerEl The HTML element to append the section to.
   */
  renderAvailableModelsSection(containerEl) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Available Models",
      async (sectionEl) => {
        sectionEl.createEl("div", {
          text: "Choose which models are available in model selection menus throughout the plugin.",
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em;" }
        });
        const buttonRow = sectionEl.createDiv({ cls: "ai-models-button-row" });
        new import_obsidian11.Setting(buttonRow).addButton((btn) => {
          btn.setButtonText("Refresh Models").setCta().onClick(async () => {
            btn.setButtonText("Refreshing...");
            btn.setDisabled(true);
            try {
              this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
              await this.plugin.saveSettings();
              new import_obsidian11.Notice("Available models refreshed.");
              this.display();
            } catch (e) {
              new import_obsidian11.Notice("Error refreshing models: " + ((e == null ? void 0 : e.message) || e));
            } finally {
              btn.setButtonText("Refresh Models");
              btn.setDisabled(false);
            }
          });
        }).addButton((btn) => {
          btn.setButtonText("All On").onClick(async () => {
            let allModels2 = this.plugin.settings.availableModels || [];
            if (allModels2.length === 0) {
              allModels2 = await getAllAvailableModels(this.plugin.settings);
            }
            if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
            allModels2.forEach((model) => {
              this.plugin.settings.enabledModels[model.id] = true;
            });
            await this.plugin.saveSettings();
            this.display();
          });
        }).addButton((btn) => {
          btn.setButtonText("All Off").onClick(async () => {
            let allModels2 = this.plugin.settings.availableModels || [];
            if (allModels2.length === 0) {
              allModels2 = await getAllAvailableModels(this.plugin.settings);
            }
            if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
            allModels2.forEach((model) => {
              this.plugin.settings.enabledModels[model.id] = false;
            });
            await this.plugin.saveSettings();
            this.display();
          });
        });
        let allModels = this.plugin.settings.availableModels || [];
        if (allModels.length === 0) {
          allModels = await getAllAvailableModels(this.plugin.settings);
        }
        if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
        if (allModels.length === 0) {
          sectionEl.createEl("div", { text: "No models found. Please configure your providers and refresh available models.", cls: "setting-item-description" });
        } else {
          allModels = allModels.slice().sort((a, b) => {
            if (a.provider !== b.provider) {
              return a.provider.localeCompare(b.provider);
            }
            return (a.name || a.id).localeCompare(b.name || b.id);
          });
          allModels.forEach((model) => {
            this.createToggleSetting(
              sectionEl,
              model.name || model.id,
              `Enable or disable "${model.name || model.id}" (${model.id}) in model selection menus.`,
              () => this.plugin.settings.enabledModels[model.id] !== false,
              // default to true
              async (value) => {
                this.plugin.settings.enabledModels[model.id] = value;
                await this.plugin.saveSettings();
              }
            );
          });
        }
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
  /**
   * Display the settings tab.
   * This method orchestrates the rendering of all setting sections.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Assistant Settings" });
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "API Keys & Providers",
      async (sectionEl) => {
        this.createTextSetting(
          sectionEl,
          "OpenAI API Key",
          "Enter your OpenAI API key",
          "Enter your API key",
          () => this.plugin.settings.openaiSettings.apiKey,
          async (value) => {
            this.plugin.settings.openaiSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "OpenAI Base URL",
          "Custom base URL for OpenAI API (optional, leave empty for default)",
          "https://api.openai.com/v1",
          () => this.plugin.settings.openaiSettings.baseUrl || "",
          async (value) => {
            this.plugin.settings.openaiSettings.baseUrl = value;
            await this.plugin.saveSettings();
          },
          { trim: true, undefinedIfEmpty: true }
        );
        this.createTextSetting(
          sectionEl,
          "Anthropic API Key",
          "Enter your Anthropic API key",
          "Enter your API key",
          () => this.plugin.settings.anthropicSettings.apiKey,
          async (value) => {
            this.plugin.settings.anthropicSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "Google API Key",
          "Enter your Google API key",
          "Enter your API key",
          () => this.plugin.settings.geminiSettings.apiKey,
          async (value) => {
            this.plugin.settings.geminiSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "Ollama Server URL",
          "Enter your Ollama server URL (default: http://localhost:11434)",
          "http://localhost:11434",
          () => this.plugin.settings.ollamaSettings.serverUrl,
          async (value) => {
            this.plugin.settings.ollamaSettings.serverUrl = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    this.renderAvailableModelsSection(containerEl);
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Model Setting Presets",
      async (sectionEl) => {
        this.renderModelSettingPresets(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Default AI Model Settings",
      async (sectionEl) => {
        await this.settingsSections.renderAIModelSettings(sectionEl, () => this.display());
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Mode Settings",
      async (sectionEl) => {
        sectionEl.createEl("div", {
          text: "Agent Mode allows the AI to use tools like file creation, reading, and modification. Configure the limits and behavior for tool usage.",
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em;" }
        });
        this.createToggleSetting(
          sectionEl,
          "Enable Agent Mode by Default",
          "Start new conversations with Agent Mode enabled.",
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.enabled) != null ? _b : false;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4 };
            }
            this.plugin.settings.agentMode.enabled = value;
            await this.plugin.saveSettings();
          }
        );
        this.createSliderSetting(
          sectionEl,
          "Max Tool Calls per Conversation",
          "Maximum number of tools the AI can use in a single conversation to prevent runaway execution.",
          { min: 1, max: 50, step: 1 },
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxToolCalls) != null ? _b : 10;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4 };
            }
            this.plugin.settings.agentMode.maxToolCalls = value;
            await this.plugin.saveSettings();
          }
        );
        this.createSliderSetting(
          sectionEl,
          "Tool Execution Timeout (seconds)",
          "Maximum time to wait for each tool to complete before timing out.",
          { min: 5, max: 300, step: 5 },
          () => {
            var _a2, _b;
            return ((_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.timeoutMs) != null ? _b : 3e4) / 1e3;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4 };
            }
            this.plugin.settings.agentMode.timeoutMs = value * 1e3;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Tools",
      async (sectionEl) => {
        this.renderToolToggles(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Content & Chat Customization",
      async (sectionEl) => {
        this.createTextSetting(
          sectionEl,
          "Chat Separator",
          "The string used to separate chat messages.",
          "----",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatSeparator) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatSeparator = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "Chat Start String",
          "The string that indicates where to start taking the note for context.",
          "===START===",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatStartString) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatStartString = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "Chat End String",
          "The string that indicates where to end taking the note for context.",
          "===END===",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatEndString) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatEndString = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.createTextSetting(
          sectionEl,
          "Title Prompt",
          "The prompt used for generating note titles.",
          "You are a title generator...",
          () => this.plugin.settings.titlePrompt,
          async (value) => {
            this.plugin.settings.titlePrompt = value != null ? value : "";
            await this.plugin.saveSettings();
          },
          { isTextArea: true }
        );
        this.createDropdownSetting(
          sectionEl,
          "Title Output Mode",
          "Choose what to do with the generated note title.",
          { "clipboard": "Copy to clipboard", "replace-filename": "Replace note filename", "metadata": "Insert into metadata" },
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.titleOutputMode) != null ? _a2 : "clipboard";
          },
          async (value) => {
            this.plugin.settings.titleOutputMode = value;
            await this.plugin.saveSettings();
          }
        );
        this.createDropdownSetting(
          sectionEl,
          "Summary Output Mode",
          "Choose what to do with the generated note summary.",
          { "clipboard": "Copy to clipboard", "metadata": "Insert into metadata" },
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.summaryOutputMode) != null ? _a2 : "clipboard";
          },
          async (value) => {
            this.plugin.settings.summaryOutputMode = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Note & Data Handling",
      async (sectionEl) => {
        this.createToggleSetting(
          sectionEl,
          "Expand Linked Notes Recursively",
          "If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false;
          },
          async (value) => {
            this.plugin.settings.expandLinkedNotesRecursively = value;
            await this.plugin.saveSettings();
            this.display();
          },
          // Re-render to show/hide slider
          () => this.display()
        );
        if (this.plugin.settings.expandLinkedNotesRecursively) {
          this.createSliderSetting(
            sectionEl,
            "Max Link Expansion Depth",
            "Maximum depth for recursively expanding linked notes (1-3).",
            { min: 1, max: 3, step: 1 },
            () => {
              var _a2;
              return (_a2 = this.plugin.settings.maxLinkExpansionDepth) != null ? _a2 : 2;
            },
            async (value) => {
              this.plugin.settings.maxLinkExpansionDepth = value;
              await this.plugin.saveSettings();
            }
          );
        }
        this.createTextSetting(
          sectionEl,
          "Chat Note Folder",
          "Folder to save exported chat notes (relative to vault root, leave blank for root)",
          "e.g. AI Chats",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatNoteFolder) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatNoteFolder = value != null ? value : "";
            await this.plugin.saveSettings();
          },
          { trim: true }
        );
        this.renderYamlAttributeGenerators(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Plugin Behavior",
      async (sectionEl) => {
        this.createToggleSetting(
          sectionEl,
          "Auto-Open Model Settings",
          "Automatically open the AI model settings panel when the plugin loads.",
          () => this.plugin.settings.autoOpenModelSettings,
          async (value) => {
            this.plugin.settings.autoOpenModelSettings = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Backup Management",
      async (sectionEl) => {
        await this.renderBackupManagement(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    new import_obsidian11.Setting(containerEl).setName("Reset All Settings to Default").setDesc("Reset all plugin settings (except API keys) to their original default values.").addButton((button) => button.setButtonText("Reset").onClick(async () => {
      const { DEFAULT_SETTINGS: DEFAULT_SETTINGS2 } = await Promise.resolve().then(() => (init_types(), types_exports));
      const { DEFAULT_TITLE_PROMPT: DEFAULT_TITLE_PROMPT2 } = await Promise.resolve().then(() => (init_promptConstants(), promptConstants_exports));
      const preservedApiKeys = {
        openai: this.plugin.settings.openaiSettings.apiKey,
        anthropic: this.plugin.settings.anthropicSettings.apiKey,
        gemini: this.plugin.settings.geminiSettings.apiKey
      };
      this.plugin.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS2));
      this.plugin.settings.openaiSettings.apiKey = preservedApiKeys.openai;
      this.plugin.settings.anthropicSettings.apiKey = preservedApiKeys.anthropic;
      this.plugin.settings.geminiSettings.apiKey = preservedApiKeys.gemini;
      this.plugin.settings.titlePrompt = DEFAULT_TITLE_PROMPT2;
      await this.plugin.saveSettings();
      this.display();
      if (typeof this.plugin.activateView === "function") {
        setTimeout(() => {
          this.plugin.activateView(VIEW_TYPE_MODEL_SETTINGS);
        }, 100);
      }
      new import_obsidian11.Notice("All settings (except API keys) reset to default.");
    }));
  }
  /**
   * Renders the Backup Management section.
   * @param containerEl The HTML element to append the section to.
   */
  async renderBackupManagement(containerEl) {
    containerEl.createEl("h3", { text: "Backup Management" });
    containerEl.createEl("div", {
      text: "Manage backups created when files are modified by AI tools. Backups are stored in the plugin data folder, not in your vault.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const backupManager = this.plugin.backupManager;
    const totalBackups = await backupManager.getTotalBackupCount();
    const totalSize = await backupManager.getTotalBackupSize();
    const sizeInKB = Math.round(totalSize / 1024);
    containerEl.createEl("div", {
      text: `Total backups: ${totalBackups} (${sizeInKB} KB)`,
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em; font-weight: bold;" }
    });
    const refreshButton = containerEl.createEl("button", {
      text: "Refresh Backup List",
      cls: "mod-cta"
    });
    refreshButton.style.marginBottom = "1em";
    refreshButton.onclick = () => {
      this.display();
    };
    const backupFiles = await backupManager.getAllBackupFiles();
    if (backupFiles.length === 0) {
      containerEl.createEl("div", {
        text: "No backups found.",
        cls: "setting-item-description"
      });
      return;
    }
    for (const filePath of backupFiles) {
      const backups = await backupManager.getBackupsForFile(filePath);
      if (backups.length === 0) continue;
      const fileSection = containerEl.createDiv({ cls: "backup-file-section" });
      fileSection.createEl("h4", { text: filePath, cls: "backup-file-path" });
      const backupList = fileSection.createDiv({ cls: "backup-list" });
      backups.forEach((backup, index) => {
        const backupItem = backupList.createDiv({ cls: "backup-item" });
        const backupInfo = backupItem.createDiv({ cls: "backup-info" });
        backupInfo.createEl("span", {
          text: `${backup.readableTimestamp} (${Math.round(backup.content.length / 1024)} KB)`,
          cls: "backup-timestamp"
        });
        const backupActions = backupItem.createDiv({ cls: "backup-actions" });
        const restoreBtn = backupActions.createEl("button", {
          text: "Restore",
          cls: "mod-cta"
        });
        restoreBtn.onclick = async () => {
          const confirmed = await this.showConfirmationDialog(
            "Restore Backup",
            `Are you sure you want to restore the backup from ${backup.readableTimestamp}? This will overwrite the current file content.`
          );
          if (confirmed) {
            try {
              const result = await backupManager.restoreBackup(backup);
              if (result.success) {
                new import_obsidian11.Notice(`Successfully restored backup for ${filePath}`);
              } else {
                new import_obsidian11.Notice(`Failed to restore backup: ${result.error}`);
              }
            } catch (error) {
              new import_obsidian11.Notice(`Error restoring backup: ${error.message}`);
            }
          }
        };
        const deleteBtn = backupActions.createEl("button", {
          text: "Delete",
          cls: "mod-warning"
        });
        deleteBtn.onclick = async () => {
          const confirmed = await this.showConfirmationDialog(
            "Delete Backup",
            `Are you sure you want to delete the backup from ${backup.readableTimestamp}?`
          );
          if (confirmed) {
            try {
              await backupManager.deleteSpecificBackup(filePath, backup.timestamp);
              new import_obsidian11.Notice(`Deleted backup for ${filePath}`);
              this.display();
            } catch (error) {
              new import_obsidian11.Notice(`Error deleting backup: ${error.message}`);
            }
          }
        };
        const previewBtn = backupActions.createEl("button", {
          text: "Preview",
          cls: "mod-muted"
        });
        previewBtn.onclick = () => {
          const preview = backup.content.substring(0, 200);
          const truncated = backup.content.length > 200 ? "..." : "";
          new import_obsidian11.Notice(`Preview: ${preview}${truncated}`, 1e4);
        };
      });
      const deleteAllBtn = fileSection.createEl("button", {
        text: `Delete All Backups for ${filePath}`,
        cls: "mod-warning"
      });
      deleteAllBtn.onclick = async () => {
        const confirmed = await this.showConfirmationDialog(
          "Delete All Backups",
          `Are you sure you want to delete all ${backups.length} backups for ${filePath}?`
        );
        if (confirmed) {
          try {
            await backupManager.deleteBackupsForFile(filePath);
            new import_obsidian11.Notice(`Deleted all backups for ${filePath}`);
            this.display();
          } catch (error) {
            new import_obsidian11.Notice(`Error deleting backups: ${error.message}`);
          }
        }
      };
    }
  }
  /**
   * Shows a confirmation dialog
   */
  showConfirmationDialog(title, message) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "modal";
      modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
      const content = modal.createDiv();
      content.className = "modal-content";
      content.style.cssText = `
                background-color: var(--background-primary);
                padding: 2rem;
                border-radius: 8px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;
      content.createEl("h3", { text: title });
      content.createEl("p", { text: message });
      const buttonContainer = content.createDiv();
      buttonContainer.style.cssText = `
                display: flex;
                gap: 1rem;
                justify-content: flex-end;
                margin-top: 1rem;
            `;
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(false);
      };
      const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" });
      confirmBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(true);
      };
      document.body.appendChild(modal);
      modal.onclick = (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          resolve(false);
        }
      };
    });
  }
};

// src/components/chat.ts
var import_obsidian3 = require("obsidian");
init_providers();

// src/ChatHistoryManager.ts
var import_obsidian2 = require("obsidian");
var ChatHistoryManager = class {
  constructor(vault, pluginId, historyFilePath) {
    __publicField(this, "vault");
    __publicField(this, "historyFilePath");
    __publicField(this, "history", []);
    __publicField(this, "isLoaded", false);
    this.vault = vault;
    let effectivePluginId = pluginId;
    if (!pluginId) {
      console.error("CRITICAL: ChatHistoryManager instantiated without pluginId! Using placeholder. This will likely lead to incorrect file paths.");
      effectivePluginId = "unknown-plugin-id-error";
    }
    const fPath = historyFilePath || "chat-history.json";
    this.historyFilePath = (0, import_obsidian2.normalizePath)(`.obsidian/plugins/${effectivePluginId}/${fPath}`);
    console.log("[ChatHistoryManager] Using history file path:", this.historyFilePath);
    if (typeof window !== "undefined" && window.Notice) {
      new window.Notice("[ChatHistoryManager] Using history file path: " + this.historyFilePath);
    }
  }
  async ensureDirectoryExists() {
    const dirPath = this.historyFilePath.substring(0, this.historyFilePath.lastIndexOf("/"));
    if (!dirPath) return;
    try {
      const abstractFile = this.vault.getAbstractFileByPath(dirPath);
      if (abstractFile === null) {
        await this.vault.createFolder(dirPath);
      } else if (!(abstractFile instanceof import_obsidian2.TFolder)) {
        console.error(`Path ${dirPath} exists but is not a folder.`);
        throw new Error(`Path ${dirPath} exists but is not a folder.`);
      }
    } catch (e) {
      if (e.message && e.message.toLowerCase().includes("folder already exists")) {
        return;
      }
      console.error(`Failed to ensure directory ${dirPath} exists:`, e);
      throw e;
    }
  }
  async loadHistory() {
    try {
      const exists = await this.vault.adapter.exists(this.historyFilePath);
      if (exists) {
        const data = await this.vault.adapter.read(this.historyFilePath);
        try {
          this.history = JSON.parse(data);
        } catch (parseError) {
          console.error("Failed to parse chat history:", parseError);
          this.history = [];
        }
      } else {
        this.history = [];
      }
    } catch (e) {
      console.error("Failed to load chat history:", e);
      this.history = [];
    }
    return this.history;
  }
  async addMessage(message) {
    const currentHistory = await this.loadHistory();
    currentHistory.push(message);
    this.history = currentHistory;
    await this.saveHistory();
  }
  async getHistory() {
    return await this.loadHistory();
  }
  async clearHistory() {
    this.history = [];
    await this.saveHistory();
  }
  async deleteMessage(timestamp, sender, content) {
    await this.loadHistory();
    const index = this.history.findIndex(
      (msg) => msg.timestamp === timestamp && msg.sender === sender && msg.content === content
    );
    if (index !== -1) {
      this.history.splice(index, 1);
      await this.saveHistory();
    }
  }
  async updateMessage(timestamp, sender, oldContent, newContent) {
    await this.loadHistory();
    const message = this.history.find(
      (msg) => msg.timestamp === timestamp && msg.sender === sender && msg.content === oldContent
    );
    if (message) {
      message.content = newContent;
      await this.saveHistory();
    } else {
      console.warn("ChatHistoryManager: updateMessage did not find a matching message to update.", { timestamp, sender, oldContent });
    }
  }
  async saveHistory() {
    try {
      await this.ensureDirectoryExists();
      const data = JSON.stringify(this.history, null, 2);
      const abstractTarget = this.vault.getAbstractFileByPath(this.historyFilePath);
      if (abstractTarget instanceof import_obsidian2.TFolder) {
        throw new Error(`Path ${this.historyFilePath} is a directory, not a file.`);
      }
      await this.vault.adapter.write(this.historyFilePath, data);
      if (!abstractTarget || !(abstractTarget instanceof import_obsidian2.TFile)) {
        await this.vault.adapter.exists(this.historyFilePath);
      }
    } catch (e) {
      console.error(`Failed to save history to ${this.historyFilePath}:`, e);
      throw e;
    }
  }
};

// src/components/chat.ts
var VIEW_TYPE_CHAT = "chat-view";
var SettingsModal = class extends import_obsidian3.Modal {
=======
// chat.ts
var import_obsidian4 = require("obsidian");
var VIEW_TYPE_CHAT = "chat-view";
var SettingsModal = class extends import_obsidian4.Modal {
>>>>>>> main
  constructor(app, plugin) {
    super(app);
    __publicField(this, "plugin");
    this.plugin = plugin;
    this.titleEl.setText("AI Model Settings");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-settings-modal");
<<<<<<< HEAD
    contentEl.createEl("h3", { text: "Session Management" });
    new import_obsidian3.Setting(contentEl).setName("Auto-save Sessions").setDesc("Automatically save chat messages to sessions").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSaveSessions).onChange(async (value) => {
      this.plugin.settings.autoSaveSessions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Maximum Sessions").setDesc("Maximum number of chat sessions to keep (oldest will be removed)").addSlider((slider) => slider.setLimits(1, 50, 1).setValue(this.plugin.settings.maxSessions).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxSessions = value;
      if (this.plugin.settings.sessions.length > value) {
        this.plugin.settings.sessions = this.plugin.settings.sessions.sort((a, b) => b.lastUpdated - a.lastUpdated).slice(0, value);
      }
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("AI Provider").setDesc("Choose which AI provider to use").addDropdown((dropdown) => {
      dropdown.addOption("openai", "OpenAI (ChatGPT)").addOption("anthropic", "Anthropic (Claude)").addOption("gemini", "Google (Gemini)").addOption("ollama", "Ollama (Local AI)").setValue(this.plugin.settings.provider).onChange(async (value) => {
=======
    new import_obsidian4.Setting(contentEl).setName("AI Provider").setDesc("Choose which AI provider to use").addDropdown((dropdown) => {
      dropdown.addOption("openai", "OpenAI").addOption("anthropic", "Anthropic (Claude)").addOption("gemini", "Google (Gemini)").addOption("ollama", "Ollama (Local AI)").setValue(this.plugin.settings.provider).onChange(async (value) => {
>>>>>>> main
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.onOpen();
      });
    });
<<<<<<< HEAD
    new import_obsidian3.Setting(contentEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Include Date with System Message").setDesc("Add the current date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeDateWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeTimeWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
      this.plugin.settings.enableObsidianLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
      this.plugin.settings.enableContextNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
=======
    new import_obsidian4.Setting(contentEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Include Date with System Message").setDesc("Add the current date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeDateWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeTimeWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
      this.plugin.settings.enableObsidianLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
      this.plugin.settings.enableContextNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
>>>>>>> main
      text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange(async (value) => {
        this.plugin.settings.contextNotes = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
    });
<<<<<<< HEAD
    new import_obsidian3.Setting(contentEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(contentEl).setName("Reference Current Note").setDesc("Include the content of the current note in the chat context.").addToggle((toggle) => toggle.setValue(this.plugin.settings.referenceCurrentNote).onChange(async (value) => {
=======
    new import_obsidian4.Setting(contentEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Max Tokens").setDesc("Set the maximum length of the model's output").addText((text) => text.setPlaceholder("4000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.maxTokens = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian4.Setting(contentEl).setName("Reference Current Note").setDesc("Include the content of the current note in the chat context.").addToggle((toggle) => toggle.setValue(this.plugin.settings.referenceCurrentNote).onChange(async (value) => {
>>>>>>> main
      this.plugin.settings.referenceCurrentNote = value;
      await this.plugin.saveSettings();
    }));
    contentEl.createEl("h3", { text: `${this.plugin.settings.provider.toUpperCase()} Settings` });
    switch (this.plugin.settings.provider) {
      case "openai": {
        const settings = this.plugin.settings.openaiSettings;
<<<<<<< HEAD
        new import_obsidian3.Setting(contentEl).setName("Model").setDesc("Choose the OpenAI model to use").addDropdown((dropdown) => {
=======
        new import_obsidian4.Setting(contentEl).setName("Model").setDesc("Choose the OpenAI model to use").addDropdown((dropdown) => {
>>>>>>> main
          for (const model of settings.availableModels) {
            dropdown.addOption(model, model);
          }
          dropdown.setValue(settings.model).onChange(async (value) => {
            settings.model = value;
            await this.plugin.saveSettings();
          });
        });
        break;
      }
      case "anthropic": {
        const settings = this.plugin.settings.anthropicSettings;
<<<<<<< HEAD
        new import_obsidian3.Setting(contentEl).setName("Model").setDesc("Choose the Anthropic model to use").addDropdown((dropdown) => {
=======
        new import_obsidian4.Setting(contentEl).setName("Model").setDesc("Choose the Anthropic model to use").addDropdown((dropdown) => {
>>>>>>> main
          for (const model of settings.availableModels) {
            dropdown.addOption(model, model);
          }
          dropdown.setValue(settings.model).onChange(async (value) => {
            settings.model = value;
            await this.plugin.saveSettings();
          });
        });
        break;
      }
      case "gemini": {
        const settings = this.plugin.settings.geminiSettings;
<<<<<<< HEAD
        new import_obsidian3.Setting(contentEl).setName("Model").setDesc("Choose the Gemini model to use").addDropdown((dropdown) => {
=======
        new import_obsidian4.Setting(contentEl).setName("Model").setDesc("Choose the Gemini model to use").addDropdown((dropdown) => {
>>>>>>> main
          for (const model of settings.availableModels) {
            dropdown.addOption(model, model);
          }
          dropdown.setValue(settings.model).onChange(async (value) => {
            settings.model = value;
            await this.plugin.saveSettings();
          });
        });
        break;
      }
      case "ollama": {
        const settings = this.plugin.settings.ollamaSettings;
<<<<<<< HEAD
        new import_obsidian3.Setting(contentEl).setName("Model").setDesc("Choose the Ollama model to use").addDropdown((dropdown) => {
=======
        new import_obsidian4.Setting(contentEl).setName("Model").setDesc("Choose the Ollama model to use").addDropdown((dropdown) => {
>>>>>>> main
          for (const model of settings.availableModels) {
            dropdown.addOption(model, model);
          }
          dropdown.setValue(settings.model).onChange(async (value) => {
            settings.model = value;
            await this.plugin.saveSettings();
          });
        });
        break;
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
<<<<<<< HEAD
var ConfirmationModal = class extends import_obsidian3.Modal {
=======
var ConfirmationModal = class extends import_obsidian4.Modal {
>>>>>>> main
  constructor(app, title, message, onConfirm) {
    super(app);
    __publicField(this, "onConfirm");
    __publicField(this, "message");
    this.titleEl.setText(title);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.marginTop = "16px";
    buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.onConfirm(false);
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: "Delete",
      cls: "mod-warning"
    });
    confirmButton.addEventListener("click", () => {
      this.onConfirm(true);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
<<<<<<< HEAD
var ChatView = class extends import_obsidian3.ItemView {
=======
var ChatService = class {
  constructor(app, view) {
    this.app = app;
    this.view = view;
    __publicField(this, "eventManager");
    __publicField(this, "activeStream", null);
    this.eventManager = new EventManager();
  }
  async sendMessage(content) {
    if (!content.trim()) return;
    try {
      const userMessage = await this.createAndAppendMessage("user", content);
      const assistantMessage = await this.createAndAppendMessage("assistant", "");
      await this.view.streamResponse(assistantMessage, content);
    } catch (error) {
      new import_obsidian4.Notice(`Error: ${error.message}`);
    }
  }
  async createAndAppendMessage(role, content) {
    const messageEl = document.createElement("div");
    messageEl.classList.add("chat-message", role);
    const contentEl = document.createElement("div");
    contentEl.classList.add("message-content");
    contentEl.innerHTML = content;
    messageEl.appendChild(contentEl);
    return messageEl;
  }
  stop() {
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
  }
  destroy() {
    this.stop();
    this.eventManager.cleanup();
  }
};
var ChatView = class extends import_obsidian4.ItemView {
>>>>>>> main
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "messagesContainer");
    __publicField(this, "inputContainer");
<<<<<<< HEAD
    __publicField(this, "activeStream", null);
    __publicField(this, "chatHistoryManager");
=======
    __publicField(this, "eventManager");
    __publicField(this, "chatService");
    __publicField(this, "debouncedSendMessage");
    __publicField(this, "messageHistory", []);
>>>>>>> main
    __publicField(this, "settingsContainer", null);
    __publicField(this, "activeStream", null);
    this.plugin = plugin;
<<<<<<< HEAD
    this.chatHistoryManager = new ChatHistoryManager(this.app.vault, this.plugin.manifest.id, "chat-history.json");
=======
    this.eventManager = new EventManager();
    this.chatService = new ChatService(this.app, this);
    this.debouncedSendMessage = this.debounce(this.chatService.sendMessage.bind(this.chatService), 400);
    this.messagesContainer = createDiv("ai-chat-messages");
    this.inputContainer = createDiv("ai-chat-input-container");
>>>>>>> main
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    let loadedHistory = [];
    try {
      loadedHistory = await this.chatHistoryManager.getHistory();
    } catch (e) {
      new import_obsidian3.Notice("Failed to load chat history.");
      loadedHistory = [];
    }
    contentEl.addClass("ai-chat-view");
    this.createMessagesContainer(contentEl);
    this.createInputArea(contentEl);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    await this.addMessage("assistant", "Hello! How can I help you today?");
  }
  createMessagesContainer(parentEl) {
    this.messagesContainer = parentEl.createDiv("ai-chat-messages");
    this.messagesContainer.style.flex = "1";
    this.messagesContainer.style.overflow = "auto";
    this.messagesContainer.style.padding = "16px";
  }
  createInputArea(parentEl) {
    this.inputContainer = parentEl.createDiv("ai-chat-input-container");
    this.inputContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    this.inputContainer.style.padding = "16px";
    const textarea = this.createChatTextarea();
    const buttonContainer = this.createButtonContainer();
    this.inputContainer.appendChild(textarea);
    this.inputContainer.appendChild(buttonContainer);
  }
  createChatTextarea() {
    const textarea = document.createElement("textarea");
    textarea.addClass("ai-chat-input");
    textarea.placeholder = "Type your message...";
    textarea.rows = 3;
    textarea.style.width = "100%";
    textarea.style.resize = "none";
<<<<<<< HEAD
    textarea.style.border = "1px solid var(--background-modifier-border)";
    textarea.style.borderRadius = "4px";
    textarea.style.padding = "8px";
    textarea.style.backgroundColor = "var(--background-primary)";
    textarea.style.color = "var(--text-normal)";
    const buttonContainer = this.inputContainer.createDiv("ai-chat-buttons");
    buttonContainer.style.marginTop = "8px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.justifyContent = "flex-end";
    const sendButton = buttonContainer.createEl("button", {
      text: "Send",
      cls: "mod-cta"
    });
    const stopButton = buttonContainer.createEl("button", {
      text: "Stop"
    });
    stopButton.style.display = "none";
    const copyAllButton = buttonContainer.createEl("button", {
      text: "Copy All"
    });
    copyAllButton.addEventListener("click", async () => {
      const messages = this.messagesContainer.querySelectorAll(".ai-chat-message");
      let chatContent = "";
      messages.forEach((el, index) => {
        var _a2;
        const content = ((_a2 = el.querySelector(".message-content")) == null ? void 0 : _a2.textContent) || "";
        chatContent += content;
        if (index < messages.length - 1) {
          chatContent += "\n\n" + this.plugin.settings.chatSeparator + "\n\n";
        }
      });
      await this.copyToClipboard(chatContent);
    });
    const clearButton = buttonContainer.createEl("button", {
      text: "Clear Chat"
    });
    const sendMessage = async () => {
      const content = textarea.value.trim();
      if (!content) return;
      textarea.disabled = true;
      sendButton.style.display = "none";
      stopButton.style.display = "block";
      await this.addMessage("user", content);
      textarea.value = "";
      this.activeStream = new AbortController();
      try {
        const provider = createProvider(this.plugin.settings);
        let systemMessage = this.plugin.getSystemMessage();
        if (this.plugin.settings.enableContextNotes && this.plugin.settings.contextNotes) {
          const contextContent = await this.plugin.getContextNotesContent(this.plugin.settings.contextNotes);
          systemMessage += `

Context Notes:
${contextContent}`;
        }
        const messages = [
          { role: "system", content: systemMessage }
        ];
        if (this.plugin.settings.referenceCurrentNote) {
          const currentFile = this.app.workspace.getActiveFile();
          if (currentFile) {
            const currentNoteContent = await this.app.vault.cachedRead(currentFile);
            messages.push({
              role: "system",
              content: `Here is the content of the current note:

${currentNoteContent}`
            });
          }
        }
        const messageElements = this.messagesContainer.querySelectorAll(".ai-chat-message");
        messageElements.forEach((el) => {
          var _a2;
          const role = el.classList.contains("user") ? "user" : "assistant";
          const content2 = ((_a2 = el.querySelector(".message-content")) == null ? void 0 : _a2.textContent) || "";
          messages.push({ role, content: content2 });
        });
        const tempContainer = document.createElement("div");
        tempContainer.addClass("ai-chat-message", "assistant");
        tempContainer.style.marginBottom = "16px";
        tempContainer.style.padding = "12px";
        tempContainer.style.borderRadius = "8px";
        tempContainer.style.backgroundColor = "var(--background-secondary)";
        const contentEl2 = tempContainer.createDiv("message-content");
        this.messagesContainer.appendChild(tempContainer);
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        let responseContent = "";
        await provider.getCompletion(
          messages,
          {
            temperature: this.plugin.settings.temperature,
            maxTokens: this.plugin.settings.maxTokens,
            streamCallback: async (chunk) => {
              responseContent += chunk;
              contentEl2.empty();
              await import_obsidian3.MarkdownRenderer.render(
                this.app,
                responseContent,
                contentEl2,
                "",
                this
              );
              this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            },
            abortController: this.activeStream
          }
        );
        tempContainer.remove();
        if (responseContent.trim() !== "") {
          const messageEl = this.createMessageElement("assistant", responseContent);
          this.messagesContainer.appendChild(messageEl);
          await this.chatHistoryManager.addMessage({
            timestamp: messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            sender: "assistant",
            content: responseContent
          });
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          new import_obsidian3.Notice(`Error: ${error.message}`);
          await this.addMessage("assistant", `Error: ${error.message}`);
        }
      } finally {
        textarea.disabled = false;
        textarea.focus();
        stopButton.style.display = "none";
        sendButton.style.display = "block";
        this.activeStream = null;
      }
    };
    textarea.addEventListener("keydown", (e) => {
=======
    this.eventManager.addEventListener(textarea, "keydown", (e) => {
>>>>>>> main
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.debouncedSendMessage(textarea.value);
        textarea.value = "";
      }
    });
    return textarea;
  }
  createButtonContainer() {
    const container = document.createElement("div");
    container.addClass("ai-chat-buttons");
    container.style.marginTop = "8px";
    container.style.display = "flex";
    container.style.gap = "8px";
    container.style.justifyContent = "flex-end";
    const sendButton = this.createButton("Send", "mod-cta");
    this.eventManager.addEventListener(sendButton, "click", () => {
      const textarea = this.inputContainer.querySelector("textarea");
      if (textarea) {
        this.debouncedSendMessage(textarea.value);
        textarea.value = "";
      }
    });
    const stopButton = this.createButton("Stop");
    stopButton.style.display = "none";
    this.eventManager.addEventListener(stopButton, "click", () => {
      this.chatService.stop();
    });
    const clearButton = this.createButton("Clear Chat");
    this.eventManager.addEventListener(clearButton, "click", () => {
      this.clearChat();
    });
    const settingsButton = this.createButton("Settings");
    this.eventManager.addEventListener(settingsButton, "click", () => {
      new SettingsModal(this.app, this.plugin).open();
    });
    container.appendChild(settingsButton);
    container.appendChild(sendButton);
    container.appendChild(stopButton);
    container.appendChild(clearButton);
    return container;
  }
  createButton(text, cls) {
    const button = document.createElement("button");
    button.setText(text);
    if (cls) button.addClass(cls);
    return button;
  }
  clearChat() {
    this.messagesContainer.empty();
    this.addMessage("assistant", "Chat cleared. How can I help you?");
  }
  updateUIState(state) {
    const textarea = this.inputContainer.querySelector("textarea");
    const sendButton = this.inputContainer.querySelector("button.mod-cta");
    const stopButton = this.inputContainer.querySelector("button:nth-child(3)");
    if (state === "streaming" /* STREAMING */) {
      if (textarea) textarea.disabled = true;
      if (sendButton) sendButton.disabled = true;
      if (stopButton) {
        stopButton.style.display = "block";
        stopButton.disabled = false;
      }
    } else {
      if (textarea) textarea.disabled = false;
      if (sendButton) sendButton.disabled = false;
      if (stopButton) {
        stopButton.style.display = "none";
        stopButton.disabled = true;
      }
<<<<<<< HEAD
    });
    clearButton.addEventListener("click", async () => {
      this.messagesContainer.empty();
      try {
        await this.chatHistoryManager.clearHistory();
        const messageEl = this.createMessageElement("assistant", this.plugin.settings.systemMessage || "Hello! How can I help you today?");
        this.messagesContainer.appendChild(messageEl);
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      } catch (e) {
        new import_obsidian3.Notice("Failed to clear chat history.");
      }
    });
    buttonContainer.insertBefore(settingsButton, clearButton);
    settingsButton.addEventListener("click", () => {
      const settingsModal = new SettingsModal(this.app, this.plugin);
      settingsModal.open();
    });
    if (loadedHistory.length > 0) {
      for (const msg of loadedHistory) {
        if (msg.sender === "user" || msg.sender === "assistant") {
          const messageEl = this.createMessageElement(msg.sender, msg.content);
          messageEl.dataset.timestamp = msg.timestamp;
          this.messagesContainer.appendChild(messageEl);
        }
      }
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
=======
>>>>>>> main
    }
  }
  createActionButton(label, tooltip, callback) {
    const button = document.createElement("button");
    button.addClass("ai-chat-action-button");
    button.setAttribute("aria-label", tooltip);
    const labelEl = document.createElement("span");
    labelEl.textContent = label;
    button.appendChild(labelEl);
    button.addEventListener("click", callback);
    return button;
  }
  async copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
<<<<<<< HEAD
      new import_obsidian3.Notice("Copied to clipboard");
    } catch (error) {
      new import_obsidian3.Notice("Failed to copy to clipboard");
=======
      new import_obsidian4.Notice("Copied to clipboard");
    } catch (error) {
      new import_obsidian4.Notice("Failed to copy to clipboard");
>>>>>>> main
      console.error("Clipboard error:", error);
    }
  }
  async createMessageElement(role, content) {
    const messageEl = document.createElement("div");
    messageEl.addClass("chat-message", role);
    messageEl.dataset.rawContent = content;
<<<<<<< HEAD
    messageEl.dataset.timestamp = (/* @__PURE__ */ new Date()).toISOString();
    import_obsidian3.MarkdownRenderer.render(
      this.app,
      content,
      contentEl,
      "",
      this
    ).catch((error) => {
      console.error("Markdown rendering error:", error);
      contentEl.textContent = content;
    });
    const actionsEl = messageContainer.createDiv("message-actions");
=======
    const contentEl = document.createElement("div");
    contentEl.addClass("message-content");
    await import_obsidian4.MarkdownRenderer.render(this.app, content, contentEl, "", this);
    messageEl.appendChild(contentEl);
    const actionsEl = this.createMessageActions(messageEl, role);
    messageEl.appendChild(actionsEl);
    this.messagesContainer.appendChild(messageEl);
    this.scrollToBottom();
    this.messageHistory.push({ role, content });
    return messageEl;
  }
  createMessageActions(messageEl, role) {
    const actionsEl = document.createElement("div");
    actionsEl.addClass("message-actions");
>>>>>>> main
    actionsEl.style.display = "none";
    actionsEl.style.flexWrap = "wrap";
    actionsEl.style.gap = "8px";
    actionsEl.style.marginTop = "8px";
    messageEl.addEventListener("mouseenter", () => {
      actionsEl.style.display = "flex";
    });
    messageEl.addEventListener("mouseleave", () => {
      actionsEl.style.display = "none";
    });
<<<<<<< HEAD
    actionsEl.style.flexWrap = "wrap";
    actionsEl.style.gap = "8px";
    actionsEl.style.marginTop = "8px";
    actionsEl.appendChild(this.createActionButton("Copy", "Copy message", () => {
      const currentContent = messageEl.dataset.rawContent || "";
      if (currentContent.trim() === "") {
        new import_obsidian3.Notice("No content to copy");
=======
    actionsEl.appendChild(this.createActionButton("copy", "Copy", "Copy message", () => {
      const currentContent = messageEl.dataset.rawContent || "";
      if (currentContent.trim() === "") {
        new import_obsidian4.Notice("No content to copy");
>>>>>>> main
        return;
      }
      this.copyToClipboard(currentContent);
    }));
<<<<<<< HEAD
    actionsEl.appendChild(this.createActionButton("Edit", "Edit message", async () => {
      const wasEditing = contentEl.hasClass("editing");
      if (!wasEditing) {
        const textarea = document.createElement("textarea");
        textarea.value = messageEl.dataset.rawContent || "";
        textarea.style.width = "100%";
        textarea.style.height = `${contentEl.offsetHeight}px`;
        textarea.style.minHeight = "100px";
        contentEl.empty();
        contentEl.appendChild(textarea);
        textarea.focus();
        contentEl.addClass("editing");
      } else {
        const textarea = contentEl.querySelector("textarea");
        if (textarea) {
          const oldContent = messageEl.dataset.rawContent;
          const newContent = textarea.value;
          try {
            await this.chatHistoryManager.updateMessage(
              messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
              messageEl.classList.contains("user") ? "user" : "assistant",
              oldContent || "",
              newContent
            );
            messageEl.dataset.rawContent = newContent;
            contentEl.empty();
            await import_obsidian3.MarkdownRenderer.render(this.app, newContent, contentEl, "", this);
            contentEl.removeClass("editing");
          } catch (e) {
            new import_obsidian3.Notice("Failed to save edited message.");
            messageEl.dataset.rawContent = oldContent || "";
            contentEl.empty();
            await import_obsidian3.MarkdownRenderer.render(this.app, oldContent || "", contentEl, "", this);
            contentEl.removeClass("editing");
          }
        }
      }
    }));
    actionsEl.appendChild(this.createActionButton("Delete", "Delete message", () => {
      const modal = new ConfirmationModal(
        this.app,
        "Delete message",
        "Are you sure you want to delete this message?",
        async (confirmed) => {
          if (confirmed) {
            try {
              await this.chatHistoryManager.deleteMessage(
                messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
                messageEl.classList.contains("user") ? "user" : "assistant",
                messageEl.dataset.rawContent || ""
              );
              messageEl.remove();
            } catch (e) {
              new import_obsidian3.Notice("Failed to delete message from history.");
            }
          }
        }
      );
      modal.open();
    }));
    const regenerateLabel = role === "assistant" ? "Regenerate" : "Regenerate";
    const regenerateTooltip = role === "assistant" ? "Regenerate this response" : "Regenerate AI response";
    actionsEl.appendChild(this.createActionButton(regenerateLabel, regenerateTooltip, () => {
      this.regenerateResponse(messageEl);
    }));
    messageContainer.appendChild(actionsEl);
    return messageEl;
  }
  async addMessage(role, content, isError = false) {
    const messageEl = this.createMessageElement(role, content);
    const uiTimestamp = messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString();
    this.messagesContainer.appendChild(messageEl);
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    try {
      await this.chatHistoryManager.addMessage({
        timestamp: uiTimestamp,
        sender: role,
        content
      });
    } catch (e) {
      new import_obsidian3.Notice("Failed to save chat message: " + e.message);
    }
=======
    actionsEl.appendChild(this.createActionButton("edit", "Edit", "Edit message", () => {
      this.handleMessageEdit(messageEl);
    }));
    actionsEl.appendChild(this.createActionButton("trash", "Delete", "Delete message", () => {
      this.handleMessageDelete(messageEl);
    }));
    if (role === "assistant") {
      actionsEl.appendChild(this.createActionButton("refresh-cw", "Regenerate", "Regenerate response", () => {
        this.handleMessageRegenerate(messageEl);
      }));
    }
    return actionsEl;
  }
  scrollToBottom() {
    this.messagesContainer.scrollTo({
      top: this.messagesContainer.scrollHeight,
      behavior: "smooth"
    });
  }
  getMessageHistory() {
    const messages = [];
    const messageElements = this.messagesContainer.querySelectorAll(".chat-message");
    messageElements.forEach((el) => {
      const role = el.classList.contains("user") ? "user" : "assistant";
      const content = el.dataset.rawContent || "";
      messages.push({ role, content });
    });
    return messages;
  }
  async addMessage(role, content) {
    const messageEl = await this.createMessageElement(role, content);
    this.messagesContainer.appendChild(messageEl);
    this.scrollToBottom();
    this.messageHistory.push({ role, content });
>>>>>>> main
  }
  async onClose() {
    this.chatService.destroy();
    this.eventManager.cleanup();
  }
  handleActiveLeafChange() {
    if (this.plugin.settings.referenceCurrentNote) {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        console.log("Context update not implemented yet");
      }
    }
  }
  debounce(func, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  async sendMessage(content) {
    if (!content.trim()) return;
    this.updateUIState("streaming" /* STREAMING */);
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
    this.activeStream = new AbortController();
    const textarea = this.inputContainer.querySelector("textarea");
    const sendButton = this.inputContainer.querySelector("button.mod-cta");
    if (textarea) textarea.disabled = true;
    if (sendButton) sendButton.disabled = true;
    try {
      const provider = createProvider(this.plugin.settings);
      const messages = await this.getMessageContext();
      await this.addMessage("user", content);
      const assistantContainer = await this.createMessageElement("assistant", "");
      this.messagesContainer.appendChild(assistantContainer);
      let responseContent = "";
      await provider.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        maxTokens: this.plugin.settings.maxTokens,
        streamCallback: async (chunk) => {
          responseContent += chunk;
          const contentEl = assistantContainer.querySelector(".message-content");
          if (contentEl) {
            assistantContainer.dataset.rawContent = responseContent;
            contentEl.empty();
            await import_obsidian4.MarkdownRenderer.render(this.app, responseContent, contentEl, "", this);
            this.scrollToBottom();
          }
        },
        abortController: this.activeStream
      });
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian4.Notice(`Error: ${error.message}`);
        await this.addMessage("assistant", `Error: ${error.message}`);
      }
    } finally {
      this.updateUIState("idle" /* IDLE */);
      if (textarea) {
        textarea.disabled = false;
        textarea.focus();
      }
      if (sendButton) sendButton.disabled = false;
      this.activeStream = null;
    }
  }
  async getMessageContext() {
    const messages = [
      { role: "system", content: this.plugin.getSystemMessage() }
    ];
    if (this.plugin.settings.referenceCurrentNote) {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const currentNoteContent = await this.app.vault.cachedRead(currentFile);
        messages.push({
          role: "system",
          content: `Current note content:

${currentNoteContent}`
        });
      }
    }
    const messageElements = this.messagesContainer.querySelectorAll(".ai-chat-message");
    messageElements.forEach((el) => {
      const role = el.classList.contains("user") ? "user" : "assistant";
      const content = el.dataset.rawContent || "";
      messages.push({ role, content });
    });
    return messages;
  }
  createSettingsPanel() {
    const container = document.createElement("div");
    container.addClass("ai-chat-settings-panel");
    container.createEl("h3", { text: "AI Model Settings" });
    const providerContainer = container.createDiv();
    providerContainer.createEl("label", { text: "AI Provider" });
    const providerSelect = providerContainer.createEl("select");
<<<<<<< HEAD
    providerSelect.createEl("option", { value: "openai", text: "OpenAI (ChatGPT)" });
=======
    providerSelect.createEl("option", { value: "openai", text: "OpenAI" });
>>>>>>> main
    providerSelect.createEl("option", { value: "anthropic", text: "Anthropic (Claude)" });
    providerSelect.createEl("option", { value: "gemini", text: "Google (Gemini)" });
    providerSelect.createEl("option", { value: "ollama", text: "Ollama (Local AI)" });
    providerSelect.value = this.plugin.settings.provider;
    providerSelect.addEventListener("change", async () => {
      this.plugin.settings.provider = providerSelect.value;
      await this.plugin.saveSettings();
      if (this.settingsContainer) {
        this.settingsContainer.replaceWith(this.createSettingsPanel());
      }
    });
    const systemMessageContainer = container.createDiv();
    systemMessageContainer.createEl("label", { text: "System Message" });
    const systemMessageInput = systemMessageContainer.createEl("textarea");
    systemMessageInput.value = this.plugin.settings.systemMessage;
    systemMessageInput.addEventListener("change", async () => {
      this.plugin.settings.systemMessage = systemMessageInput.value;
      await this.plugin.saveSettings();
    });
    const temperatureContainer = container.createDiv();
    temperatureContainer.createEl("label", { text: "Temperature" });
    const temperatureInput = temperatureContainer.createEl("input", { type: "range" });
    temperatureInput.min = "0";
    temperatureInput.max = "1";
    temperatureInput.step = "0.1";
    temperatureInput.value = String(this.plugin.settings.temperature);
    const temperatureValue = temperatureContainer.createSpan();
    temperatureValue.textContent = String(this.plugin.settings.temperature);
    temperatureInput.addEventListener("input", async () => {
      const value = Number(temperatureInput.value);
      temperatureValue.textContent = String(value);
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    });
    const providerSettings = container.createDiv();
    providerSettings.createEl("h4", { text: `${this.plugin.settings.provider.toUpperCase()} Settings` });
    switch (this.plugin.settings.provider) {
      case "openai": {
        const settings = this.plugin.settings.openaiSettings;
        const modelSelect = providerSettings.createEl("select");
        settings.availableModels.forEach((model) => {
          modelSelect.createEl("option", { value: model, text: model });
        });
        modelSelect.value = settings.model;
        modelSelect.addEventListener("change", async () => {
          settings.model = modelSelect.value;
          await this.plugin.saveSettings();
        });
        break;
      }
      case "anthropic": {
        const settings = this.plugin.settings.anthropicSettings;
        const modelSelect = providerSettings.createEl("select");
        settings.availableModels.forEach((model) => {
          modelSelect.createEl("option", { value: model, text: model });
        });
        modelSelect.value = settings.model;
        modelSelect.addEventListener("change", async () => {
          settings.model = modelSelect.value;
          await this.plugin.saveSettings();
        });
        break;
      }
      case "gemini": {
        const settings = this.plugin.settings.geminiSettings;
        const modelSelect = providerSettings.createEl("select");
        settings.availableModels.forEach((model) => {
          modelSelect.createEl("option", { value: model, text: model });
        });
        modelSelect.value = settings.model;
        modelSelect.addEventListener("change", async () => {
          settings.model = modelSelect.value;
          await this.plugin.saveSettings();
        });
        break;
      }
      case "ollama": {
        const settings = this.plugin.settings.ollamaSettings;
        const modelSelect = providerSettings.createEl("select");
        settings.availableModels.forEach((model) => {
          modelSelect.createEl("option", { value: model, text: model });
        });
        modelSelect.value = settings.model;
        modelSelect.addEventListener("change", async () => {
          settings.model = modelSelect.value;
          await this.plugin.saveSettings();
        });
        break;
      }
    }
    return container;
  }
<<<<<<< HEAD
  async regenerateResponse(messageEl) {
    const textarea = this.inputContainer.querySelector("textarea");
    if (textarea) textarea.disabled = true;
    const allMessages = Array.from(this.messagesContainer.querySelectorAll(".ai-chat-message"));
    const currentIndex = allMessages.indexOf(messageEl);
    let userMsgIndex;
    if (messageEl.classList.contains("user")) {
      userMsgIndex = currentIndex;
      messageEl = allMessages[currentIndex + 1];
      if (!(messageEl == null ? void 0 : messageEl.classList.contains("assistant"))) {
        new import_obsidian3.Notice("No AI response found to regenerate");
        if (textarea) textarea.disabled = false;
        return;
      }
    } else {
      userMsgIndex = currentIndex - 1;
      while (userMsgIndex >= 0 && !allMessages[userMsgIndex].classList.contains("user")) {
        userMsgIndex--;
      }
      if (userMsgIndex < 0) {
        new import_obsidian3.Notice("No user message found to regenerate response");
        if (textarea) textarea.disabled = false;
        return;
      }
    }
    const contextMessages = [
      { role: "system", content: this.plugin.getSystemMessage() }
    ];
    if (this.plugin.settings.enableContextNotes && this.plugin.settings.contextNotes) {
      const contextContent = await this.plugin.getContextNotesContent(this.plugin.settings.contextNotes);
      contextMessages[0].content += `

Context Notes:
${contextContent}`;
    }
    if (this.plugin.settings.referenceCurrentNote) {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const currentNoteContent = await this.app.vault.cachedRead(currentFile);
        contextMessages.push({
          role: "system",
          content: `Here is the content of the current note:

${currentNoteContent}`
        });
      }
    }
    for (let i = 0; i <= userMsgIndex; i++) {
      const el = allMessages[i];
      const role = el.classList.contains("user") ? "user" : "assistant";
      const content = el.dataset.rawContent || "";
      contextMessages.push({ role, content });
    }
    const originalTimestamp = messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString();
    const originalContent = messageEl.dataset.rawContent || "";
    const assistantContainer = this.createMessageElement("assistant", "");
    assistantContainer.dataset.timestamp = originalTimestamp;
    this.messagesContainer.insertBefore(assistantContainer, messageEl.nextSibling);
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    messageEl.remove();
    this.activeStream = new AbortController();
    let responseContent = "";
    try {
      const provider = createProvider(this.plugin.settings);
      await provider.getCompletion(
        contextMessages,
        {
          temperature: this.plugin.settings.temperature,
          maxTokens: this.plugin.settings.maxTokens,
          streamCallback: async (chunk) => {
            responseContent += chunk;
            const contentEl = assistantContainer.querySelector(".message-content");
            if (contentEl) {
              assistantContainer.dataset.rawContent = responseContent;
              contentEl.empty();
              await import_obsidian3.MarkdownRenderer.render(
                this.app,
                responseContent,
                contentEl,
                "",
                this
              );
              this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }
          },
          abortController: this.activeStream
        }
      );
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian3.Notice(`Error: ${error.message}`);
        assistantContainer.remove();
      }
    }
    try {
      if (responseContent.trim() !== "") {
        await this.chatHistoryManager.updateMessage(
          originalTimestamp,
          "assistant",
          originalContent,
          responseContent
        );
      }
    } finally {
      if (textarea) {
        textarea.disabled = false;
        textarea.focus();
      }
      this.activeStream = null;
=======
  async handleMessageEdit(messageEl) {
    const currentContent = messageEl.dataset.rawContent || "";
    const contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) return;
    const textarea = document.createElement("textarea");
    textarea.value = currentContent;
    textarea.style.width = "100%";
    textarea.style.minHeight = "100px";
    contentEl.empty();
    contentEl.appendChild(textarea);
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.marginTop = "8px";
    const saveButton = this.createButton("Save", "mod-cta");
    const cancelButton = this.createButton("Cancel");
    saveButton.addEventListener("click", async () => {
      const newContent = textarea.value;
      messageEl.dataset.rawContent = newContent;
      contentEl.empty();
      await import_obsidian4.MarkdownRenderer.render(this.app, newContent, contentEl, "", this);
      buttonContainer.remove();
    });
    cancelButton.addEventListener("click", async () => {
      contentEl.empty();
      await import_obsidian4.MarkdownRenderer.render(this.app, currentContent, contentEl, "", this);
      buttonContainer.remove();
    });
    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(cancelButton);
    contentEl.appendChild(buttonContainer);
    textarea.focus();
  }
  handleMessageDelete(messageEl) {
    new ConfirmationModal(
      this.app,
      "Delete Message",
      "Are you sure you want to delete this message?",
      (confirmed) => {
        if (confirmed) {
          messageEl.remove();
        }
      }
    ).open();
  }
  async handleMessageRegenerate(messageEl) {
    let prevMessage = messageEl.previousElementSibling;
    while (prevMessage && !prevMessage.classList.contains("user")) {
      prevMessage = prevMessage.previousElementSibling;
    }
    if (!prevMessage) {
      new import_obsidian4.Notice("No user message found to regenerate response");
      return;
    }
    const userContent = prevMessage.dataset.rawContent;
    if (!userContent) {
      new import_obsidian4.Notice("Cannot regenerate response: no user message content found");
      return;
    }
    messageEl.remove();
    await this.sendMessage(userContent);
  }
  async streamResponse(messageEl, prompt) {
    const provider = createProvider(this.plugin.settings);
    const messages = await this.getMessageContext();
    let responseContent = "";
    try {
      await provider.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        maxTokens: this.plugin.settings.maxTokens,
        streamCallback: async (chunk) => {
          responseContent += chunk;
          const contentEl = messageEl.querySelector(".message-content");
          if (contentEl) {
            messageEl.dataset.rawContent = responseContent;
            contentEl.empty();
            await import_obsidian4.MarkdownRenderer.render(this.app, responseContent, contentEl, "", this);
            this.scrollToBottom();
          }
        },
        abortController: this.activeStream || void 0
      });
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian4.Notice(`Error: ${error.message}`);
      }
    } finally {
      this.updateUIState("idle" /* IDLE */);
>>>>>>> main
    }
  }
};

<<<<<<< HEAD
// src/components/parseSelection.ts
function parseSelection(selection, chatSeparator, chatBoundaryString) {
  let insideChat = !chatBoundaryString;
  const lines = selection.split("\n");
  let messages = [];
  let currentRole = "user";
  let currentContent = "";
  for (const line of lines) {
    if (chatBoundaryString && line.trim() === chatBoundaryString) {
      if (!insideChat && currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
        currentContent = "";
      }
      insideChat = !insideChat;
      continue;
    }
    if (!insideChat) continue;
    if (line.trim() === chatSeparator) {
      if (currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
      }
      currentRole = currentRole === "user" ? "assistant" : "user";
      currentContent = "";
    } else {
      currentContent += line + "\n";
    }
  }
  if (currentContent.trim()) {
    messages.push({ role: currentRole, content: currentContent.trim() });
  }
  return messages;
}

// src/components/ModelSettingsView.ts
var import_obsidian4 = require("obsidian");
init_providers();
var VIEW_TYPE_MODEL_SETTINGS = "model-settings-view";
var ModelSettingsView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "_onSettingsChange", () => {
      this.onOpen();
    });
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MODEL_SETTINGS2;
=======
// main.ts
var VIEW_TYPE_MODEL_SETTINGS = "model-settings-view";
var ModelSettingsView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MODEL_SETTINGS;
>>>>>>> main
  }
  getDisplayText() {
    return "AI Model Settings";
  }
<<<<<<< HEAD
  getIcon() {
    return "file-sliders";
  }
=======
>>>>>>> main
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "AI Model Settings" });
<<<<<<< HEAD
    new import_obsidian4.Setting(contentEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    contentEl.createEl("h4", { text: "Date Settings" });
    new import_obsidian4.Setting(contentEl).setName("Include Date with System Message").setDesc("Add the current date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeDateWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeTimeWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    contentEl.createEl("h4", { text: "Note Reference Settings" });
    new import_obsidian4.Setting(contentEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
      this.plugin.settings.enableObsidianLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(contentEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
=======
    contentEl.createEl("h3", { text: "Common Settings" });
    new import_obsidian5.Setting(contentEl).setName("AI Provider").setDesc("Choose which AI provider to use").addDropdown((dropdown) => {
      dropdown.addOption("openai", "OpenAI").addOption("anthropic", "Anthropic (Claude)").addOption("gemini", "Google (Gemini)").addOption("ollama", "Ollama (Local AI)").setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.onOpen();
      });
    });
    new import_obsidian5.Setting(contentEl).setName("System Message").setDesc("Message to give the AI context about its role").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Include Date").setDesc("Include current date in system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeDateWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Include Time").setDesc("Include current time in system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
      this.plugin.settings.includeTimeWithSystemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
      this.plugin.settings.enableObsidianLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
>>>>>>> main
      this.plugin.settings.enableContextNotes = value;
      await this.plugin.saveSettings();
    }));
    const contextNotesContainer = contentEl.createDiv("context-notes-container");
    contextNotesContainer.style.marginBottom = "24px";
<<<<<<< HEAD
    new import_obsidian4.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
=======
    new import_obsidian5.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
>>>>>>> main
      text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange(async (value) => {
        this.plugin.settings.contextNotes = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
<<<<<<< HEAD
    });
    contentEl.createEl("h2", { text: "Provider Settings" });
    new import_obsidian4.Setting(contentEl).setName("AI Provider").setDesc("Choose which AI provider to use").addDropdown((dropdown) => {
      dropdown.addOption("openai", "OpenAI (ChatGPT)").addOption("anthropic", "Anthropic (Claude)").addOption("gemini", "Google (Gemini)").addOption("ollama", "Ollama (Local AI)").setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.onOpen();
      });
    });
=======
      this.setupNoteAutocomplete(text.inputEl);
    });
    new import_obsidian5.Setting(contentEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(contentEl).setName("Max Tokens").setDesc("Set the maximum length of the model's output").addText((text) => text.setPlaceholder("4000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.maxTokens = numValue;
        await this.plugin.saveSettings();
      }
    }));
    contentEl.createEl("h3", { text: `${this.plugin.settings.provider.toUpperCase()} Settings` });
>>>>>>> main
    switch (this.plugin.settings.provider) {
      case "openai":
        this.renderOpenAISettings(contentEl);
        break;
      case "anthropic":
        this.renderAnthropicSettings(contentEl);
        break;
      case "gemini":
        this.renderGeminiSettings(contentEl);
        break;
      case "ollama":
        this.renderOllamaSettings(contentEl);
        break;
    }
  }
  renderProviderSettings(containerEl, settings, providerName, testConnectionCallback) {
<<<<<<< HEAD
    new import_obsidian4.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${providerName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
=======
    new import_obsidian5.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${providerName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
>>>>>>> main
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        await testConnectionCallback();
      } catch (error) {
<<<<<<< HEAD
        new import_obsidian4.Notice(`Error: ${error.message}`);
=======
        new import_obsidian5.Notice(`Error: ${error.message}`);
>>>>>>> main
      } finally {
        button.setButtonText("Test");
        button.setDisabled(false);
      }
    }));
    if (settings.lastTestResult) {
      const date = new Date(settings.lastTestResult.timestamp);
      containerEl.createEl("div", {
        text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
        cls: settings.lastTestResult.success ? "success" : "error"
      });
    }
<<<<<<< HEAD
    new import_obsidian4.Setting(containerEl).setName("Model").setDesc(`Choose the ${providerName} model to use`).addDropdown((dropdown) => {
=======
    new import_obsidian5.Setting(containerEl).setName("Model").setDesc(`Choose the ${providerName} model to use`).addDropdown((dropdown) => {
>>>>>>> main
      for (const model of settings.availableModels) {
        dropdown.addOption(model, model);
      }
      dropdown.setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
  renderOpenAISettings(containerEl) {
    this.renderProviderSettings(containerEl, this.plugin.settings.openaiSettings, "OpenAI", async () => {
      const provider = createProvider(this.plugin.settings);
      const result = await provider.testConnection();
      if (result.success && result.models) {
        this.plugin.settings.openaiSettings.availableModels = result.models;
        await this.plugin.saveSettings();
        this.plugin.settings.openaiSettings.lastTestResult = {
          timestamp: Date.now(),
          success: true,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
        this.onOpen();
      } else {
        this.plugin.settings.openaiSettings.lastTestResult = {
          timestamp: Date.now(),
          success: false,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
      }
    });
  }
  renderAnthropicSettings(containerEl) {
    this.renderProviderSettings(containerEl, this.plugin.settings.anthropicSettings, "Anthropic", async () => {
      const provider = createProvider(this.plugin.settings);
      const result = await provider.testConnection();
      if (result.success && result.models) {
        this.plugin.settings.anthropicSettings.availableModels = result.models;
        await this.plugin.saveSettings();
        this.plugin.settings.anthropicSettings.lastTestResult = {
          timestamp: Date.now(),
          success: true,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
        this.onOpen();
      } else {
        this.plugin.settings.anthropicSettings.lastTestResult = {
          timestamp: Date.now(),
          success: false,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
      }
    });
  }
  renderGeminiSettings(containerEl) {
    this.renderProviderSettings(containerEl, this.plugin.settings.geminiSettings, "Gemini", async () => {
      const provider = createProvider(this.plugin.settings);
      const result = await provider.testConnection();
      if (result.success && result.models) {
        this.plugin.settings.geminiSettings.availableModels = result.models;
        await this.plugin.saveSettings();
        this.plugin.settings.geminiSettings.lastTestResult = {
          timestamp: Date.now(),
          success: true,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
        this.onOpen();
      } else {
        this.plugin.settings.geminiSettings.lastTestResult = {
          timestamp: Date.now(),
          success: false,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
      }
    });
  }
  renderOllamaSettings(containerEl) {
    this.renderProviderSettings(containerEl, this.plugin.settings.ollamaSettings, "Ollama", async () => {
      const provider = createProvider(this.plugin.settings);
      const result = await provider.testConnection();
      if (result.success && result.models) {
        this.plugin.settings.ollamaSettings.availableModels = result.models;
        await this.plugin.saveSettings();
        this.plugin.settings.ollamaSettings.lastTestResult = {
          timestamp: Date.now(),
          success: true,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
        this.onOpen();
      } else {
        this.plugin.settings.ollamaSettings.lastTestResult = {
          timestamp: Date.now(),
          success: false,
          message: result.message
        };
<<<<<<< HEAD
        new import_obsidian4.Notice(result.message);
=======
        new import_obsidian5.Notice(result.message);
>>>>>>> main
      }
    });
    containerEl.createEl("div", {
      cls: "setting-item-description",
      text: "To use Ollama:"
    });
    const steps = containerEl.createEl("ol");
    steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
    steps.createEl("li", { text: "Start the Ollama server" });
    steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
    steps.createEl("li", { text: "Test connection to see available models" });
  }
  async onClose() {
  }
<<<<<<< HEAD
};

// src/components/noteUtils.ts
var import_obsidian5 = require("obsidian");
function extractContentUnderHeader(content, headerText) {
  const lines = content.split("\n");
  let foundHeader = false;
  let extractedContent = [];
  let headerLevel = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const headerMatch = line.match(/^(#+)\s+(.*?)$/);
    if (headerMatch) {
      const currentHeaderLevel = headerMatch[1].length;
      const currentHeaderText = headerMatch[2].trim();
      if (foundHeader) {
        if (currentHeaderLevel <= headerLevel) {
          break;
        }
      } else if (currentHeaderText.toLowerCase() === headerText.toLowerCase()) {
        foundHeader = true;
        headerLevel = currentHeaderLevel;
        extractedContent.push(line);
        continue;
      }
    }
    if (foundHeader) {
      extractedContent.push(line);
    }
  }
  return extractedContent.join("\n");
}

// src/components/noteUtils.ts
async function processObsidianLinks(content, app, settings, visitedNotes = /* @__PURE__ */ new Set(), currentDepth = 0) {
  var _a2;
  if (!settings.enableObsidianLinks) return content;
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let processedContent = content;
  while ((match = linkRegex.exec(content)) !== null) {
    if (match && match[0] && match[1]) {
      const parts = match[1].split("|");
      const filePath = parts[0].trim();
      try {
        let file = findFile(app, filePath);
        const headerMatch = filePath.match(/(.*?)#(.*)/);
        let extractedContent = "";
        if (file && file instanceof import_obsidian5.TFile) {
          const noteContent = await app.vault.cachedRead(file);
          if (headerMatch) {
            extractedContent = extractContentUnderHeader(noteContent, headerMatch[2].trim());
          } else {
            extractedContent = noteContent;
          }
          processedContent = processedContent.replace(
            match[0],
            `${match[0]}

---
Note Name: ${filePath}
Content:
${extractedContent}
---
`
          );
        } else {
          new import_obsidian5.Notice(`File not found: ${filePath}. Ensure the file name and path are correct.`);
        }
      } catch (error) {
        new import_obsidian5.Notice(`Error processing link for ${filePath}: ${error.message}`);
      }
    }
  }
  return processedContent;
}
async function processContextNotes(contextNotesText, app) {
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let contextContent = "";
  while ((match = linkRegex.exec(contextNotesText)) !== null) {
    if (match && match[1]) {
      const fileName = match[1].trim();
      try {
        const headerMatch = fileName.match(/(.*?)#(.*)/);
        const baseFileName = headerMatch ? headerMatch[1].trim() : fileName;
        const headerName = headerMatch ? headerMatch[2].trim() : null;
        let file = app.vault.getAbstractFileByPath(baseFileName) || app.vault.getAbstractFileByPath(`${baseFileName}.md`);
        if (!file) {
          const allFiles = app.vault.getFiles();
          file = allFiles.find(
            (f) => f.basename.toLowerCase() === baseFileName.toLowerCase() || f.name.toLowerCase() === `${baseFileName.toLowerCase()}.md`
          ) || null;
        }
        if (file && file instanceof import_obsidian5.TFile) {
          const noteContent = await app.vault.cachedRead(file);
          contextContent += `---
From note: ${file.basename}

`;
          if (headerName) {
            const headerContent = extractContentUnderHeader(noteContent, headerName);
            contextContent += headerContent;
          } else {
            contextContent += noteContent;
          }
          contextContent += "\n\n";
        } else {
          contextContent += `Note not found: ${fileName}

`;
        }
      } catch (error) {
        contextContent += `Error processing note ${fileName}: ${error.message}

`;
      }
    }
  }
  return contextContent;
}
async function processMessages(messages, app, settings) {
  const processedMessages = [];
  if (settings.enableContextNotes && settings.contextNotes) {
    const contextContent = await processContextNotes(settings.contextNotes, app);
    if (contextContent) {
      if (messages.length > 0 && messages[0].role === "system") {
        processedMessages.push({
          role: "system",
          content: `${messages[0].content}

Here is additional context:
${contextContent}`
        });
        messages = messages.slice(1);
      } else {
        processedMessages.push({
          role: "system",
          content: `Here is context for our conversation:
${contextContent}`
        });
      }
    }
  }
  for (const message of messages) {
    const processedContent = await processObsidianLinks(message.content, app, settings, /* @__PURE__ */ new Set());
    processedMessages.push({
      role: message.role,
      content: processedContent
    });
  }
  return processedMessages;
}
async function getContextNotesContent(contextNotesText, app) {
  return processContextNotes(contextNotesText, app);
}

// src/components/systemMessage.ts
function getSystemMessage(settings) {
  let systemMessage = settings.systemMessage;
  if (settings.includeDateWithSystemMessage) {
    const currentDate = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    systemMessage = `${systemMessage}

The current date is ${currentDate}.`;
  }
  if (settings.includeTimeWithSystemMessage) {
    const now = /* @__PURE__ */ new Date();
    const timeZoneOffset = now.getTimezoneOffset();
    const offsetHours = Math.abs(timeZoneOffset) / 60;
    const offsetMinutes = Math.abs(timeZoneOffset) % 60;
    const sign = timeZoneOffset > 0 ? "-" : "+";
    const currentTime = now.toLocaleTimeString();
    const timeZoneString = `UTC${sign}${offsetHours.toString().padStart(2, "0")}:${offsetMinutes.toString().padStart(2, "0")}`;
    systemMessage = `${systemMessage}

The current time is ${currentTime} ${timeZoneString}.`;
  }
  return systemMessage;
}

// src/main.ts
var VIEW_TYPE_MODEL_SETTINGS2 = "model-settings-view";
var MyPlugin = class extends import_obsidian7.Plugin {
=======
  /**
   * Setup autocompletion for notes and headers
   * 
   * @param inputEl The input element to attach autocompletion to
   */
  setupNoteAutocomplete(inputEl) {
    let currentStartPos = 0;
    let currentEndPos = 0;
    let isTypingLink = false;
    let suggestionEl = null;
    const cleanupSuggestions = () => {
      if (suggestionEl && document.body.contains(suggestionEl)) {
        document.body.removeChild(suggestionEl);
        suggestionEl = null;
      }
    };
    inputEl.addEventListener("input", (e) => {
      const cursorPos = inputEl.selectionStart;
      const text = inputEl.value;
      const beforeCursor = text.substring(0, cursorPos);
      const lastOpenBrackets = beforeCursor.lastIndexOf("[[");
      const lastCloseBrackets = beforeCursor.lastIndexOf("]]");
      if (lastOpenBrackets > lastCloseBrackets && lastOpenBrackets !== -1) {
        isTypingLink = true;
        currentStartPos = lastOpenBrackets + 2;
        const afterCursor = text.substring(cursorPos);
        const nextCloseBrackets = afterCursor.indexOf("]]");
        if (nextCloseBrackets !== -1) {
          currentEndPos = cursorPos;
          const linkText = text.substring(currentStartPos, currentEndPos);
          if (linkText.length > 0) {
            cleanupSuggestions();
            this.showNoteSuggestions(inputEl, currentStartPos, currentEndPos);
          }
        }
      } else {
        isTypingLink = false;
        cleanupSuggestions();
      }
    });
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        isTypingLink = false;
        cleanupSuggestions();
      }
    });
    document.addEventListener("click", (e) => {
      if (e.target !== inputEl && suggestionEl && !suggestionEl.contains(e.target)) {
        cleanupSuggestions();
      }
    });
  }
  /**
   * Display note and header suggestions
   * 
   * @param inputEl The input element
   * @param startPos The start position of the link text
   * @param endPos The end position of the link text
   */
  showNoteSuggestions(inputEl, startPos, endPos) {
    const linkText = inputEl.value.substring(startPos, endPos);
    if (linkText.length === 0) return;
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter((file) => {
      return file.basename.toLowerCase().includes(linkText.toLowerCase()) || file.path.toLowerCase().includes(linkText.toLowerCase());
    });
    if (matchingFiles.length === 0) return;
    const suggestionEl = document.createElement("div");
    suggestionEl.className = "note-autocomplete-suggestions";
    suggestionEl.style.position = "fixed";
    suggestionEl.style.zIndex = "1000";
    suggestionEl.style.background = "var(--background-primary)";
    suggestionEl.style.border = "1px solid var(--background-modifier-border)";
    suggestionEl.style.borderRadius = "4px";
    suggestionEl.style.boxShadow = "0 2px 8px var(--background-modifier-box-shadow)";
    suggestionEl.style.maxHeight = "200px";
    suggestionEl.style.width = "300px";
    suggestionEl.style.overflow = "auto";
    suggestionEl.style.padding = "8px";
    const debugInfo = document.createElement("div");
    debugInfo.style.fontSize = "10px";
    debugInfo.style.color = "var(--text-muted)";
    debugInfo.style.marginBottom = "4px";
    debugInfo.style.borderBottom = "1px solid var(--background-modifier-border)";
    debugInfo.textContent = `Searching for: "${linkText}" - Found ${matchingFiles.length} matches`;
    suggestionEl.appendChild(debugInfo);
    const rect = inputEl.getBoundingClientRect();
    const lineHeight = parseInt(getComputedStyle(inputEl).lineHeight) || 20;
    const textUpToCursor = inputEl.value.substring(0, endPos);
    const lines = textUpToCursor.split("\n");
    const lineNumber = lines.length - 1;
    suggestionEl.style.left = `${rect.left}px`;
    suggestionEl.style.top = `${rect.top + (lineNumber + 1) * lineHeight}px`;
    matchingFiles.slice(0, 10).forEach((file) => {
      const item = document.createElement("div");
      item.className = "note-autocomplete-item";
      item.textContent = file.basename;
      item.style.padding = "8px 12px";
      item.style.cursor = "pointer";
      item.style.borderRadius = "4px";
      item.addEventListener("mouseenter", () => {
        item.style.backgroundColor = "var(--background-secondary)";
      });
      item.addEventListener("mouseleave", () => {
        item.style.backgroundColor = "";
      });
      item.addEventListener("click", async () => {
        const replacement = file.basename;
        const newValue = inputEl.value.substring(0, startPos - 2) + "[[" + replacement + "]]" + inputEl.value.substring(endPos + 2);
        inputEl.value = newValue;
        this.plugin.settings.contextNotes = inputEl.value;
        await this.plugin.saveSettings();
        document.body.removeChild(suggestionEl);
        const newPos = startPos - 2 + 2 + replacement.length + 2;
        inputEl.setSelectionRange(newPos, newPos);
        inputEl.focus();
      });
      suggestionEl.appendChild(item);
      this.addHeaderSuggestions(file, suggestionEl, startPos, endPos, inputEl);
    });
    document.body.appendChild(suggestionEl);
  }
  /**
   * Add header suggestions for a file
   * 
   * @param file The file to get headers from
   * @param suggestionEl The suggestion container element
   * @param startPos Start position in the input
   * @param endPos End position in the input
   * @param inputEl The input element
   */
  async addHeaderSuggestions(file, suggestionEl, startPos, endPos, inputEl) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.headings || cache.headings.length === 0) return;
    const separator = document.createElement("div");
    separator.style.height = "1px";
    separator.style.backgroundColor = "var(--background-modifier-border)";
    separator.style.margin = "4px 0";
    suggestionEl.appendChild(separator);
    const headerLabel = document.createElement("div");
    headerLabel.style.fontSize = "10px";
    headerLabel.style.color = "var(--text-muted)";
    headerLabel.style.padding = "2px 12px";
    headerLabel.textContent = "Headers:";
    suggestionEl.appendChild(headerLabel);
    cache.headings.forEach((heading) => {
      const item = document.createElement("div");
      item.className = "note-autocomplete-item";
      const indent = "&nbsp;".repeat((heading.level - 1) * 2);
      item.innerHTML = `${indent}# ${heading.heading}`;
      item.style.padding = "6px 12px";
      item.style.cursor = "pointer";
      item.style.borderRadius = "4px";
      item.addEventListener("mouseenter", () => {
        item.style.backgroundColor = "var(--background-secondary)";
      });
      item.addEventListener("mouseleave", () => {
        item.style.backgroundColor = "";
      });
      item.addEventListener("click", async () => {
        const replacement = `${file.basename}#${heading.heading}`;
        const newValue = inputEl.value.substring(0, startPos - 2) + "[[" + replacement + "]]" + inputEl.value.substring(endPos + 2);
        inputEl.value = newValue;
        this.plugin.settings.contextNotes = inputEl.value;
        await this.plugin.saveSettings();
        document.body.removeChild(suggestionEl);
        const newPos = startPos - 2 + 2 + replacement.length + 2;
        inputEl.setSelectionRange(newPos, newPos);
        inputEl.focus();
      });
      suggestionEl.appendChild(item);
    });
  }
};
var MyPlugin = class extends import_obsidian5.Plugin {
>>>>>>> main
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "modelSettingsView", null);
    __publicField(this, "eventManager");
    __publicField(this, "activeStream", null);
    __publicField(this, "chatState", "idle");
  }
  async onload() {
    debug("Loading AI Assistant plugin");
    this.eventManager = new EventManager();
    await this.loadSettings();
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_MODEL_SETTINGS2,
      (leaf) => new ModelSettingsView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_CHAT,
      (leaf) => new ChatView(leaf, this)
    );
    this.addRibbonIcon("file-sliders", "Open AI Settings", () => {
      this.activateView();
    });
    this.addRibbonIcon("message-square", "Open AI Chat", () => {
      this.activateChatView();
    });
    this.eventManager.registerWorkspaceEvent(
      this.app.workspace,
      "layout-ready",
      () => {
        if (this.settings.autoOpenModelSettings) {
          this.activateView();
        }
      }
    );
    this.addCommand({
      id: "ai-completion",
      name: "Get AI Completion",
      editorCallback: async (editor) => {
<<<<<<< HEAD
        var _a2, _b, _c;
        let text;
        let insertPosition;
        if (editor.somethingSelected()) {
          text = editor.getSelection();
          insertPosition = editor.getCursor("to");
        } else {
          const currentLineNumber = editor.getCursor().line;
          let lines = [];
          for (let i = 0; i <= currentLineNumber; i++) {
            lines.push(editor.getLine(i));
          }
          const chatStartString = this.settings.chatStartString;
          if (chatStartString) {
            const startIdx = lines.findIndex((line) => line.trim() === chatStartString.trim());
            if (startIdx !== -1) {
              lines = lines.slice(startIdx + 1);
            }
          }
          text = lines.join("\n");
          insertPosition = { line: currentLineNumber + 1, ch: 0 };
        }
        console.log("Extracted text for completion:", text);
        const messages = parseSelection(text, this.settings.chatSeparator);
        if (messages.length === 0) {
          new import_obsidian7.Notice("No valid messages found in the selection.");
          return;
        }
        const lineContent = (_a2 = editor.getLine(insertPosition.line)) != null ? _a2 : "";
        let prefix = "";
        if (lineContent.trim() !== "") {
          prefix = "\n";
        }
        editor.replaceRange(`${prefix}
${this.settings.chatSeparator}
`, insertPosition);
        let currentPosition = {
          line: insertPosition.line + (prefix ? 1 : 0) + 2,
          ch: 0
        };
        this.activeStream = new AbortController();
        try {
          const provider = createProvider(this.settings);
          const processedMessages = await this.processMessages([
            { role: "system", content: this.getSystemMessage() },
            ...messages
          ]);
          let bufferedChunk = "";
          const flushBuffer = () => {
            if (bufferedChunk) {
              editor.replaceRange(bufferedChunk, currentPosition);
              currentPosition = editor.offsetToPos(
                editor.posToOffset(currentPosition) + bufferedChunk.length
              );
              bufferedChunk = "";
            }
          };
          await provider.getCompletion(
            processedMessages,
            {
              temperature: this.settings.temperature,
              maxTokens: this.settings.maxTokens,
              streamCallback: (chunk) => {
                bufferedChunk += chunk;
                setTimeout(flushBuffer, 100);
              },
              abortController: this.activeStream
            }
          );
          flushBuffer();
          const endLineContent = (_b = editor.getLine(currentPosition.line)) != null ? _b : "";
          let endPrefix = "";
          if (endLineContent.trim() !== "") {
            endPrefix = "\n";
          }
          editor.replaceRange(`${endPrefix}
${this.settings.chatSeparator}

`, currentPosition);
          const newCursorPos = editor.offsetToPos(
            editor.posToOffset(currentPosition) + (endPrefix ? 1 : 0) + 1 + this.settings.chatSeparator.length + 1
          );
          editor.setCursor(newCursorPos);
        } catch (error) {
          new import_obsidian7.Notice(`Error: ${error.message}`);
          const errLineContent = (_c = editor.getLine(currentPosition.line)) != null ? _c : "";
          let errPrefix = "";
          if (errLineContent.trim() !== "") {
            errPrefix = "\n";
          }
          editor.replaceRange(`Error: ${error.message}
${errPrefix}
${this.settings.chatSeparator}

`, currentPosition);
    } finally {
      this.activeStream = null;
    }
  }
  async onload() {
    await this.loadSettings();
    const pluginDataPath = this.app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
    this.backupManager = new BackupManager(this.app, pluginDataPath);
    await this.backupManager.initialize();
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.registerPluginView(VIEW_TYPE_MODEL_SETTINGS, (leaf) => new ModelSettingsView(leaf, this));
    this.registerPluginView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));
    this.registerCommand({
      id: "show-ai-settings",
      name: "Show AI Settings",
      callback: () => this.activateView(VIEW_TYPE_MODEL_SETTINGS)
    }, "file-sliders", "Open AI Settings");
    this.registerCommand({
      id: "show-ai-chat",
      name: "Show AI Chat",
      callback: () => this.activateView(VIEW_TYPE_CHAT)
    }, "message-square", "Open AI Chat");
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.autoOpenModelSettings) {
        this.activateView(VIEW_TYPE_MODEL_SETTINGS);
=======
        await this.handleEditorCompletion(editor);
>>>>>>> main
      }
    });
    this.registerCommand({
      id: "ai-completion",
      name: "Get AI Completion",
      editorCallback: (editor) => this.handleAICompletion(editor)
    });
    this.registerCommand({
      id: "end-ai-stream",
      name: "End AI Stream",
      callback: () => {
<<<<<<< HEAD
        if (this.activeStream) {
          this.activeStream.abort();
          this.activeStream = null;
          new import_obsidian7.Notice("AI stream ended");
        } else {
          new import_obsidian7.Notice("No active AI stream to end");
        }
=======
        this.stopActiveStream();
>>>>>>> main
      }
    });
    this.registerCommand({
      id: "copy-active-note-name",
      name: "Copy Active Note Name",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const noteName = `[[${activeFile.basename}]]`;
          try {
            await navigator.clipboard.writeText(noteName);
            new import_obsidian7.Notice(`Copied to clipboard: ${noteName}`);
          } catch (error) {
            new import_obsidian7.Notice("Failed to copy to clipboard");
            console.error("Clipboard error:", error);
          }
        } else {
          new import_obsidian7.Notice("No active note found");
        }
      }
    });
    this.registerCommand({
      id: "insert-chat-start-string",
      name: "Insert Chat Start String",
      editorCallback: (editor) => {
        var _a2;
        const chatStartString = (_a2 = this.settings.chatStartString) != null ? _a2 : "";
        if (!chatStartString) {
          new import_obsidian7.Notice("chatStartString is not set in settings.");
          return;
        }
        const cursor = editor.getCursor();
        editor.replaceRange(chatStartString, cursor);
        moveCursorAfterInsert(editor, cursor, chatStartString);
      }
    });
<<<<<<< HEAD
    this.registerCommand({
      id: "generate-note-title",
      name: "Generate Note Title",
      callback: async () => {
        const { generateNoteTitle: generateNoteTitle2 } = await Promise.resolve().then(() => (init_YAMLHandler(), YAMLHandler_exports));
        await generateNoteTitle2(
          this.app,
          this.settings,
          (messages) => this.processMessages(messages)
        );
      }
    });
    this.registerCommand({
      id: "load-chat-note-into-chat",
      name: "Load Chat Note into Chat",
      callback: async () => {
        let file = this.app.workspace.getActiveFile();
        if (!file) {
          showNotice("No active note found. Please open a note to load as chat.");
          return;
        }
        let content = await this.app.vault.read(file);
        const messages = parseSelection(content, this.settings.chatSeparator);
        if (!messages.length) {
          showNotice("No chat messages found in the selected note.");
          return;
        }
        await this.activateChatViewAndLoadMessages(messages);
      }
    });
    this.registerYamlAttributeCommands();
=======
    debug("AI Assistant plugin loaded");
  }
  onunload() {
    debug("Unloading AI Assistant plugin");
    this.stopActiveStream();
    this.eventManager.cleanup();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_MODEL_SETTINGS);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CHAT);
    debug("AI Assistant plugin unloaded");
  }
  stopActiveStream() {
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
      this.chatState = "idle";
      new import_obsidian5.Notice("AI stream ended");
    }
  }
  async activateView(viewType = VIEW_TYPE_MODEL_SETTINGS) {
    this.app.workspace.detachLeavesOfType(viewType);
    const leaf = this.app.workspace.getRightLeaf(false) || this.app.workspace.getLeaf(true);
    await leaf.setViewState({
      type: viewType,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
  async activateChatView() {
    await this.activateView(VIEW_TYPE_CHAT);
  }
  async handleEditorCompletion(editor) {
    let text;
    let insertPosition;
    if (editor.somethingSelected()) {
      text = editor.getSelection();
      insertPosition = editor.getCursor("to");
    } else {
      const lineNumber = editor.getCursor().line + 1;
      const documentText = editor.getValue();
      let startIndex = 0;
      let endIndex = editor.posToOffset({
        line: lineNumber,
        ch: editor.getLine(lineNumber).length
      });
      if (this.settings.chatStartString) {
        const startStringIndex = documentText.indexOf(this.settings.chatStartString);
        if (startStringIndex !== -1) {
          startIndex = startStringIndex + this.settings.chatStartString.length;
        }
      }
      if (this.settings.chatEndString) {
        const endStringIndex = documentText.indexOf(this.settings.chatEndString, startIndex);
        if (endStringIndex !== -1 && endStringIndex < endIndex) {
          endIndex = endStringIndex;
        }
      }
      text = documentText.substring(startIndex, endIndex).trim();
      insertPosition = { line: lineNumber + 1, ch: 0 };
    }
    if (!text) {
      new import_obsidian5.Notice("No text selected or found for completion");
      return;
    }
    await this.processCompletion(editor, text, insertPosition);
  }
  async processCompletion(editor, text, insertPosition) {
    this.stopActiveStream();
    this.activeStream = new AbortController();
    this.chatState = "streaming";
    try {
      const provider = createProvider(this.settings);
      const messages = await this.processMessages([
        { role: "system", content: this.getSystemMessage() },
        { role: "user", content: text }
      ]);
      editor.replaceRange(`

${this.settings.chatSeparator}

`, insertPosition);
      let currentPosition = {
        line: insertPosition.line + 3,
        ch: 0
      };
      let buffer = "";
      const flushBuffer = () => {
        if (buffer) {
          editor.replaceRange(buffer, currentPosition);
          currentPosition = editor.offsetToPos(
            editor.posToOffset(currentPosition) + buffer.length
          );
          buffer = "";
        }
      };
      await provider.getCompletion(messages, {
        temperature: this.settings.temperature,
        maxTokens: this.settings.maxTokens,
        streamCallback: (chunk) => {
          buffer += chunk;
          setTimeout(flushBuffer, 100);
        },
        abortController: this.activeStream
      });
      flushBuffer();
      editor.replaceRange(`

${this.settings.chatSeparator}

`, currentPosition);
      const newCursorPos = editor.offsetToPos(
        editor.posToOffset(currentPosition) + this.settings.chatSeparator.length + 4
      );
      editor.setCursor(newCursorPos);
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian5.Notice(`Error: ${error.message}`);
        editor.replaceRange(`Error: ${error.message}

${this.settings.chatSeparator}

`, insertPosition);
      }
    } finally {
      this.activeStream = null;
      this.chatState = "idle";
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
>>>>>>> main
  }
  /**
   * Register YAML attribute generator commands dynamically based on settings.
   * Unregisters previous commands before registering new ones.
   */
  registerYamlAttributeCommands() {
    if (this._yamlAttributeCommandIds && this._yamlAttributeCommandIds.length > 0) {
      for (const id of this._yamlAttributeCommandIds) {
        this.app.commands.removeCommand(id);
      }
    }
    this._yamlAttributeCommandIds = [];
    if (this.settings.yamlAttributeGenerators && Array.isArray(this.settings.yamlAttributeGenerators)) {
      for (const gen of this.settings.yamlAttributeGenerators) {
        if (!gen.attributeName || !gen.prompt || !gen.commandName) continue;
        const id = `generate-yaml-attribute-${gen.attributeName}`;
        this.registerCommand({
          // Use the new registerCommand
          id,
          name: gen.commandName,
          callback: async () => {
            const { generateYamlAttribute: generateYamlAttribute2 } = await Promise.resolve().then(() => (init_YAMLHandler(), YAMLHandler_exports));
            await generateYamlAttribute2(
              this.app,
              this.settings,
              (messages) => this.processMessages(messages),
              gen.attributeName,
              gen.prompt,
              gen.outputMode
            );
          }
        });
        this._yamlAttributeCommandIds.push(id);
      }
    }
  }
  /**
   * Retrieves the system message based on current plugin settings.
   * @returns The system message string.
   */
  getSystemMessage() {
    return getSystemMessage(this.settings);
  }
<<<<<<< HEAD
  /**
   * Activates and reveals a specific view type in the workspace.
   * @param viewType The type of view to activate.
   * @param reveal Whether to reveal the leaf after setting its view state. Defaults to true.
   */
  async activateView(viewType, reveal = true) {
    this.app.workspace.detachLeavesOfType(viewType);
    let leaf = this.app.workspace.getRightLeaf(false) || this.app.workspace.getLeaf(true);
    await leaf.setViewState({
      type: viewType,
      active: true
    });
    if (reveal) {
      this.app.workspace.revealLeaf(leaf);
    }
  }
  /**
   * Loads plugin settings from data.
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Saves plugin settings to data.
   * Also re-registers YAML attribute commands and emits a settings change event.
   */
  async saveSettings() {
    await this.saveData(this.settings);
    this.registerYamlAttributeCommands();
    this.emitSettingsChange();
  }
  /**
   * Processes an array of messages, potentially adding context notes.
   * @param messages The messages to process.
   * @returns A promise that resolves to the processed messages.
   */
  async processMessages(messages) {
    return processMessages(messages, this.app, this.settings);
  }
  /**
   * Retrieves content from context notes.
   * @param contextNotesText The text containing context note links.
   * @returns A promise that resolves to the combined content of context notes.
   */
  async getContextNotesContent(contextNotesText) {
    return getContextNotesContent(contextNotesText, this.app);
  }
  /**
   * Called when the plugin is unloaded.
   * Unregisters views to prevent issues on reload.
   */
  onunload() {
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_MODEL_SETTINGS);
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_CHAT);
=======
  async processMessages(messages) {
    const processedMessages = [];
    if (this.settings.enableContextNotes && this.settings.contextNotes) {
      const contextContent = await this.processContextNotes(this.settings.contextNotes);
      if (contextContent) {
        if (messages[0].role === "system") {
          processedMessages.push({
            role: "system",
            content: `${messages[0].content}

Here is additional context:
${contextContent}`
          });
          messages = messages.slice(1);
        } else {
          processedMessages.push({
            role: "system",
            content: `Here is context for our conversation:
${contextContent}`
          });
        }
      }
    }
    for (const message of messages) {
      const processedContent = this.settings.enableObsidianLinks ? await this.processObsidianLinks(message.content) : message.content;
      processedMessages.push({
        role: message.role,
        content: processedContent
      });
    }
    return processedMessages;
  }
  async processContextNotes(contextNotesText) {
    const linkRegex = /\[\[(.*?)\]\]/g;
    let match;
    let contextContent = "";
    while ((match = linkRegex.exec(contextNotesText)) !== null) {
      if (match && match[1]) {
        const fileName = match[1].trim();
        try {
          const headerMatch = fileName.match(/(.*?)#(.*)/);
          const baseFileName = headerMatch ? headerMatch[1].trim() : fileName;
          const headerName = headerMatch ? headerMatch[2].trim() : null;
          let file = this.app.vault.getAbstractFileByPath(baseFileName) || this.app.vault.getAbstractFileByPath(`${baseFileName}.md`);
          if (!file) {
            const allFiles = this.app.vault.getFiles();
            file = allFiles.find(
              (f) => f.basename.toLowerCase() === baseFileName.toLowerCase() || f.name.toLowerCase() === `${baseFileName.toLowerCase()}.md`
            ) || null;
          }
          if (file && file instanceof import_obsidian5.TFile) {
            const noteContent = await this.app.vault.cachedRead(file);
            contextContent += `### From note: ${file.basename}

`;
            if (headerName) {
              const headerContent = this.extractContentUnderHeader(noteContent, headerName);
              contextContent += headerContent;
            } else {
              contextContent += noteContent;
            }
            contextContent += "\n\n";
          } else {
            contextContent += `Note not found: ${fileName}

`;
          }
        } catch (error) {
          contextContent += `Error processing note ${fileName}: ${error.message}

`;
        }
      }
    }
    return contextContent;
>>>>>>> main
  }
  extractContentUnderHeader(content, headerName) {
    const lines = content.split("\n");
    let extractedContent = "";
    let isUnderTargetHeader = false;
    let currentHeaderLevel = 0;
    for (const line of lines) {
      const headerMatch = line.match(/^(#{1,6})\s+(.*)$/);
      if (headerMatch) {
        const level = headerMatch[1].length;
        const title = headerMatch[2];
        if (title.toLowerCase() === headerName.toLowerCase()) {
          isUnderTargetHeader = true;
          currentHeaderLevel = level;
          continue;
        }
        if (isUnderTargetHeader && level <= currentHeaderLevel) {
          break;
        }
      }
      if (isUnderTargetHeader) {
        extractedContent += line + "\n";
      }
    }
    return extractedContent.trim();
  }
  async processObsidianLinks(content) {
    if (!this.settings.enableObsidianLinks) return content;
    const linkRegex = /\[\[(.*?)\]\]/g;
    let match;
    let processedContent = content;
    while ((match = linkRegex.exec(content)) !== null) {
      if (match && match[0] && match[1]) {
        const parts = match[1].split("|");
        const filePath = parts[0].trim();
        try {
          const headerMatch = filePath.match(/(.*?)#(.*)/);
          const baseFileName = headerMatch ? headerMatch[1].trim() : filePath;
          const headerName = headerMatch ? headerMatch[2].trim() : null;
          let file = this.app.vault.getAbstractFileByPath(baseFileName) || this.app.vault.getAbstractFileByPath(`${baseFileName}.md`);
          if (!file) {
            const allFiles = this.app.vault.getFiles();
            file = allFiles.find(
              (f) => f.name === filePath || f.name === `${filePath}.md` || f.basename.toLowerCase() === filePath.toLowerCase() || f.path === filePath || f.path === `${filePath}.md`
            ) || null;
          }
          if (file && file instanceof import_obsidian5.TFile) {
            const noteContent = await this.app.vault.cachedRead(file);
            let extractedContent = "";
            if (headerName) {
              extractedContent = this.extractContentUnderHeader(noteContent, headerName);
            } else {
              extractedContent = noteContent;
            }
            processedContent = processedContent.replace(
              match[0],
              `${match[0]}

---
Note Name: ${filePath}
Content:
${extractedContent}
---
`
            );
          } else {
            new import_obsidian5.Notice(`File not found: ${filePath}. Ensure the file name and path are correct.`);
          }
        } catch (error) {
          new import_obsidian5.Notice(`Error processing link for ${filePath}: ${error.message}`);
        }
      }
    }
    return processedContent;
  }
};
<<<<<<< HEAD
__publicField(_MyPlugin, "registeredViewTypes", /* @__PURE__ */ new Set());
var MyPlugin = _MyPlugin;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
=======
>>>>>>> main
