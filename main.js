/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/components/chat/agent/tools/FileSearchTool.ts
var FileSearchTool;
var init_FileSearchTool = __esm({
  "src/components/chat/agent/tools/FileSearchTool.ts"() {
    FileSearchTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_search");
        __publicField(this, "description", "Searches for files within the vault based on a query and specified file types, returning a limited number of results. This tool is useful for quickly locating relevant documents and assets.");
        __publicField(this, "parameters", {
          query: {
            type: "string",
            description: "Search query for files.",
            required: false
          },
          filterType: {
            type: "string",
            enum: ["markdown", "image", "all"],
            description: "Type of files to include.",
            default: "markdown"
          },
          maxResults: {
            type: "number",
            description: "Maximum number of results.",
            default: 10
          }
        });
      }
      async execute(params, context) {
        const { query = "", filterType = "markdown", maxResults = 10 } = params;
        try {
          const allFiles = filterType === "markdown" ? this.app.vault.getMarkdownFiles() : filterType === "image" ? this.app.vault.getFiles().filter((f) => {
            var _a2;
            return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = f.extension) == null ? void 0 : _a2.toLowerCase());
          }) : this.app.vault.getFiles();
          let matchingFiles = [];
          if (query.trim()) {
            const normalizedQuery = query.toLowerCase();
            const queryWords = normalizedQuery.split(/\s+/).filter((word) => word.length > 0);
            for (const file of allFiles) {
              const searchText = `${file.path} ${file.basename}`.toLowerCase();
              const searchTextNormalized = searchText.replace(/_/g, " ");
              if (queryWords.every((word) => searchText.includes(word) || searchTextNormalized.includes(word))) {
                matchingFiles.push(file);
                if (matchingFiles.length >= maxResults) break;
              }
            }
          } else {
            matchingFiles = allFiles.slice(0, maxResults);
          }
          if (matchingFiles.length === 0) {
            return {
              success: false,
              error: `No files found matching query: "${query}"`
            };
          }
          const limitedFiles = matchingFiles.sort((a, b) => {
            var _a2, _b;
            return (((_a2 = b.stat) == null ? void 0 : _a2.mtime) || 0) - (((_b = a.stat) == null ? void 0 : _b.mtime) || 0);
          }).slice(0, maxResults);
          const files = limitedFiles.map((file) => {
            var _a2, _b, _c;
            return {
              path: file.path,
              name: file.name,
              basename: file.basename,
              extension: file.extension,
              size: ((_a2 = file.stat) == null ? void 0 : _a2.size) || 0,
              created: ((_b = file.stat) == null ? void 0 : _b.ctime) || 0,
              modified: ((_c = file.stat) == null ? void 0 : _c.mtime) || 0
            };
          });
          return {
            success: true,
            data: {
              files,
              count: files.length,
              query: query || "all files"
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to search files: ${error.message}`
          };
        }
      }
      getFileFilter(filterType) {
        switch (filterType) {
          case "markdown":
            return (file) => file.extension === "md";
          case "image":
            return (file) => {
              var _a2;
              return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = file.extension) == null ? void 0 : _a2.toLowerCase());
            };
          case "all":
          default:
            return () => true;
        }
      }
    };
  }
});

// src/components/chat/agent/tools/pathValidation.ts
var import_path, PathValidator;
var init_pathValidation = __esm({
  "src/components/chat/agent/tools/pathValidation.ts"() {
    import_path = require("path");
    PathValidator = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "vaultPath");
        this.vaultPath = this.app.vault.adapter.basePath || "";
      }
      /**
       * Validates and normalizes a path to ensure it's within the vault
       * @param inputPath The input path (can be relative to vault or absolute)
       * @returns The normalized vault-relative path or throws an error if invalid
       */
      validateAndNormalizePath(inputPath) {
        if (inputPath === void 0 || inputPath === null || typeof inputPath !== "string") {
          throw new Error("Path must be a string");
        }
        const cleanPath = inputPath.trim();
        if (cleanPath === "" || cleanPath === "." || cleanPath === "./" || cleanPath === "/") {
          return "";
        }
        let normalizedPath;
        if ((0, import_path.isAbsolute)(cleanPath)) {
          const absoluteVaultPath = (0, import_path.normalize)(this.vaultPath);
          const absoluteInputPath = (0, import_path.normalize)(cleanPath);
          if (!absoluteInputPath.startsWith(absoluteVaultPath)) {
            throw new Error(`Path '${cleanPath}' is outside the vault. Only paths within the vault are allowed.`);
          }
          normalizedPath = (0, import_path.relative)(absoluteVaultPath, absoluteInputPath);
        } else {
          normalizedPath = (0, import_path.normalize)(cleanPath);
          if (normalizedPath.startsWith("../") || normalizedPath.includes("/../") || normalizedPath === "..") {
            throw new Error(`Path '${cleanPath}' attempts to access files outside the vault. Only paths within the vault are allowed.`);
          }
        }
        normalizedPath = normalizedPath.replace(/\\/g, "/");
        if (normalizedPath.startsWith("/")) {
          normalizedPath = normalizedPath.substring(1);
        }
        if (normalizedPath === "." || normalizedPath === "./") {
          normalizedPath = "";
        }
        return normalizedPath;
      }
      /**
       * Validates that a path is safe for use within the vault
       * @param inputPath The path to validate
       * @returns True if the path is valid, throws an error otherwise
       */
      validatePath(inputPath) {
        try {
          this.validateAndNormalizePath(inputPath);
          return true;
        } catch (error) {
          throw error;
        }
      }
      /**
       * Gets the vault's base path
       * @returns The absolute path to the vault root
       */
      getVaultPath() {
        return this.vaultPath;
      }
      /**
       * Converts a vault-relative path to an absolute path
       * @param vaultRelativePath The vault-relative path
       * @returns The absolute path
       */
      toAbsolutePath(vaultRelativePath) {
        const normalizedVaultPath = this.validateAndNormalizePath(vaultRelativePath);
        return (0, import_path.join)(this.vaultPath, normalizedVaultPath);
      }
      /**
       * Checks if two paths refer to the same file within the vault
       * @param path1 First path
       * @param path2 Second path
       * @returns True if the paths refer to the same file
       */
      pathsEqual(path1, path2) {
        try {
          const normalized1 = this.validateAndNormalizePath(path1);
          const normalized2 = this.validateAndNormalizePath(path2);
          return normalized1 === normalized2;
        } catch (error) {
          return false;
        }
      }
    };
  }
});

// src/components/chat/agent/tools/FileReadTool.ts
async function readFileDirect(app, filePath) {
  const file = app.vault.getAbstractFileByPath(filePath);
  if (!file || !(file instanceof import_obsidian.TFile)) {
    return `File not found or is not a file: "${filePath}"`;
  }
  try {
    return await app.vault.read(file);
  } catch (err) {
    return `Failed to read file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
var import_obsidian, FileReadTool;
var init_FileReadTool = __esm({
  "src/components/chat/agent/tools/FileReadTool.ts"() {
    import_obsidian = require("obsidian");
    init_pathValidation();
    FileReadTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_read");
        __publicField(this, "description", "Reads and retrieves the content of a specified file from the vault, with an option to limit the maximum file size. This tool is fundamental for accessing and processing file data.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          maxSize: {
            type: "number",
            description: "Maximum file size in bytes.",
            default: 1024 * 1024
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        var _a2, _b, _c;
        const inputPath = params.path || params.filePath;
        const { maxSize = 1024 * 1024 } = params;
        if (inputPath === void 0 || inputPath === null) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file && file instanceof import_obsidian.TFile && ((_a2 = file.stat) == null ? void 0 : _a2.size) && file.stat.size > maxSize) {
            return {
              success: false,
              error: `File too large (${file.stat.size} bytes, max ${maxSize} bytes): ${filePath}`
            };
          }
          let content = await readFileDirect(this.app, filePath);
          if (content.startsWith("File not found") || content.startsWith("Failed to read")) {
            return {
              success: false,
              error: content
            };
          }
          content = content.split("\n").map((line) => line.replace(/\s+$/g, "")).join("\n").replace(/\n{3,}/g, "\n\n").replace(/ {3,}/g, "  ").replace(/-{6,}/g, "-----").trim();
          return {
            success: true,
            data: {
              content,
              filePath,
              size: file instanceof import_obsidian.TFile ? ((_b = file.stat) == null ? void 0 : _b.size) || 0 : 0,
              modified: file instanceof import_obsidian.TFile ? ((_c = file.stat) == null ? void 0 : _c.mtime) || 0 : 0,
              extension: file instanceof import_obsidian.TFile ? file.extension : void 0
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to read file: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/BackupManager.ts
var import_obsidian2, BackupManager;
var init_BackupManager = __esm({
  "src/components/BackupManager.ts"() {
    import_obsidian2 = require("obsidian");
    BackupManager = class {
      // Limit backups to prevent excessive storage
      constructor(app, pluginDataPath) {
        __publicField(this, "app");
        __publicField(this, "backupFilePath");
        __publicField(this, "binaryBackupFolder");
        __publicField(this, "maxBackupsPerFile", 10);
        this.app = app;
        this.backupFilePath = `${pluginDataPath}/backups.json`;
        this.binaryBackupFolder = `${pluginDataPath}/binary-backups`;
      }
      /**
       * Determines if a file is binary based on its extension
       * Uses a whitelist of known text extensions - everything else is treated as binary
       */
      isBinaryFile(filePath) {
        const textExtensions = [
          // Markdown and text
          ".md",
          ".txt",
          ".text",
          ".rtf",
          // Code and markup
          ".js",
          ".ts",
          ".jsx",
          ".tsx",
          ".html",
          ".htm",
          ".css",
          ".scss",
          ".sass",
          ".less",
          ".json",
          ".xml",
          ".yaml",
          ".yml",
          ".toml",
          ".ini",
          ".conf",
          ".config",
          // Programming languages
          ".py",
          ".java",
          ".c",
          ".cpp",
          ".h",
          ".hpp",
          ".cs",
          ".php",
          ".rb",
          ".go",
          ".rs",
          ".swift",
          ".kt",
          ".scala",
          ".clj",
          ".hs",
          ".elm",
          ".dart",
          ".r",
          ".m",
          ".pl",
          ".sh",
          ".bash",
          ".zsh",
          ".fish",
          ".ps1",
          ".bat",
          ".cmd",
          // Web and data
          ".svg",
          ".csv",
          ".tsv",
          ".log",
          ".sql",
          ".graphql",
          ".gql",
          // Documentation
          ".tex",
          ".latex",
          ".bib",
          ".org",
          ".rst",
          ".asciidoc",
          ".adoc",
          // Configuration and other text formats
          ".gitignore",
          ".gitattributes",
          ".editorconfig",
          ".env",
          ".properties",
          // No extension (often text files like README, LICENSE, etc.)
          ""
        ];
        const extension = filePath.toLowerCase().substring(filePath.lastIndexOf("."));
        return !textExtensions.includes(extension);
      }
      /**
       * Generates a unique backup file name for binary files
       */
      generateBinaryBackupPath(filePath, timestamp2) {
        const fileName = filePath.replace(/[\/\\]/g, "_");
        const extension = filePath.substring(filePath.lastIndexOf("."));
        const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf("."));
        return `${this.binaryBackupFolder}/${nameWithoutExt}_${timestamp2}${extension}`;
      }
      /**
       * Creates a backup of a file's current content before modification
       */
      async createBackup(filePath, currentContent) {
        try {
          const backupData = await this.loadBackupData();
          if (!backupData.backups[filePath]) {
            backupData.backups[filePath] = [];
          }
          const timestamp2 = Date.now();
          const readableTimestamp = new Date(timestamp2).toLocaleString();
          const isBinary2 = this.isBinaryFile(filePath);
          let backup;
          if (isBinary2) {
            const file = this.app.vault.getAbstractFileByPath(filePath);
            if (file && file instanceof import_obsidian2.TFile) {
              const fileBuffer = await this.app.vault.readBinary(file);
              const backupFilePath = this.generateBinaryBackupPath(filePath, timestamp2);
              const adapter = this.app.vault.adapter;
              if (!await adapter.exists(this.binaryBackupFolder)) {
                await adapter.mkdir(this.binaryBackupFolder);
              }
              await adapter.writeBinary(backupFilePath, fileBuffer);
              backup = {
                filePath,
                timestamp: timestamp2,
                readableTimestamp,
                isBinary: true,
                fileSize: fileBuffer.byteLength,
                backupFilePath
              };
            } else {
              console.error("Binary file not found or not accessible:", filePath);
              return;
            }
          } else {
            if (currentContent === void 0) {
              const file = this.app.vault.getAbstractFileByPath(filePath);
              if (file && file instanceof import_obsidian2.TFile) {
                currentContent = await this.app.vault.read(file);
              } else {
                console.error("Text file not found or not accessible:", filePath);
                return;
              }
            }
            backup = {
              filePath,
              content: currentContent,
              timestamp: timestamp2,
              readableTimestamp,
              isBinary: false,
              fileSize: currentContent.length
            };
          }
          backupData.backups[filePath].unshift(backup);
          if (backupData.backups[filePath].length > this.maxBackupsPerFile) {
            const removedBackups = backupData.backups[filePath].slice(this.maxBackupsPerFile);
            backupData.backups[filePath] = backupData.backups[filePath].slice(0, this.maxBackupsPerFile);
            for (const removedBackup of removedBackups) {
              if (removedBackup.isBinary && removedBackup.backupFilePath) {
                try {
                  const adapter = this.app.vault.adapter;
                  if (await adapter.exists(removedBackup.backupFilePath)) {
                    await adapter.remove(removedBackup.backupFilePath);
                  }
                } catch (error) {
                  console.error("Failed to clean up old binary backup:", error);
                }
              }
            }
          }
          await this.saveBackupData(backupData);
        } catch (error) {
          console.error("Failed to create backup:", error);
        }
      }
      /**
       * Gets all backups for a specific file
       */
      async getBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          return backupData.backups[filePath] || [];
        } catch (error) {
          console.error("Failed to get backups for file:", error);
          return [];
        }
      }
      /**
       * Gets all files that have backups
       */
      async getAllBackupFiles() {
        try {
          const backupData = await this.loadBackupData();
          return Object.keys(backupData.backups).filter(
            (path) => backupData.backups[path] && backupData.backups[path].length > 0
          );
        } catch (error) {
          console.error("Failed to get backup files:", error);
          return [];
        }
      }
      /**
       * Restores a backup to the vault, overwriting the current file
       */
      async restoreBackup(backup) {
        try {
          const file = this.app.vault.getAbstractFileByPath(backup.filePath);
          if (backup.isBinary) {
            if (!backup.backupFilePath) {
              return { success: false, error: "Binary backup file path is missing" };
            }
            const adapter = this.app.vault.adapter;
            if (!await adapter.exists(backup.backupFilePath)) {
              return { success: false, error: `Backup file not found: ${backup.backupFilePath}` };
            }
            const binaryData = await adapter.readBinary(backup.backupFilePath);
            if (!file) {
              await this.app.vault.createBinary(backup.filePath, binaryData);
              return { success: true };
            }
            if (!(file instanceof import_obsidian2.TFile)) {
              return { success: false, error: `Path is not a file: ${backup.filePath}` };
            }
            await this.app.vault.modifyBinary(file, binaryData);
            return { success: true };
          } else {
            if (!backup.content) {
              return { success: false, error: "Text backup content is missing" };
            }
            if (!file) {
              await this.app.vault.create(backup.filePath, backup.content);
              return { success: true };
            }
            if (!(file instanceof import_obsidian2.TFile)) {
              return { success: false, error: `Path is not a file: ${backup.filePath}` };
            }
            await this.app.vault.modify(file, backup.content);
            return { success: true };
          }
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
      /**
       * Deletes all backups for a specific file
       */
      async deleteBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          const backups = backupData.backups[filePath];
          if (backups) {
            for (const backup of backups) {
              if (backup.isBinary && backup.backupFilePath) {
                try {
                  const adapter = this.app.vault.adapter;
                  if (await adapter.exists(backup.backupFilePath)) {
                    await adapter.remove(backup.backupFilePath);
                  }
                } catch (error) {
                  console.error("Failed to clean up binary backup file:", error);
                }
              }
            }
          }
          delete backupData.backups[filePath];
          await this.saveBackupData(backupData);
        } catch (error) {
          console.error("Failed to delete backups for file:", error);
        }
      }
      /**
       * Deletes a specific backup entry
       */
      async deleteSpecificBackup(filePath, timestamp2) {
        try {
          const backupData = await this.loadBackupData();
          if (backupData.backups[filePath]) {
            const backupToDelete = backupData.backups[filePath].find((b) => b.timestamp === timestamp2);
            if (backupToDelete && backupToDelete.isBinary && backupToDelete.backupFilePath) {
              try {
                const adapter = this.app.vault.adapter;
                if (await adapter.exists(backupToDelete.backupFilePath)) {
                  await adapter.remove(backupToDelete.backupFilePath);
                }
              } catch (error) {
                console.error("Failed to clean up binary backup file:", error);
              }
            }
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp !== timestamp2
            );
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to delete specific backup:", error);
        }
      }
      /**
       * Deletes all backups for all files
       */
      async deleteAllBackups() {
        try {
          const backupData = await this.loadBackupData();
          for (const filePath in backupData.backups) {
            const backups = backupData.backups[filePath];
            if (backups) {
              for (const backup of backups) {
                if (backup.isBinary && backup.backupFilePath) {
                  try {
                    const adapter = this.app.vault.adapter;
                    if (await adapter.exists(backup.backupFilePath)) {
                      await adapter.remove(backup.backupFilePath);
                    }
                  } catch (error) {
                    console.error("Failed to clean up binary backup file:", error);
                  }
                }
              }
            }
          }
          await this.saveBackupData({ backups: {} });
        } catch (error) {
          console.error("Failed to delete all backups:", error);
          throw error;
        }
      }
      /**
       * Checks if content is different from the most recent backup
       */
      async shouldCreateBackup(filePath, newContent) {
        try {
          const backups = await this.getBackupsForFile(filePath);
          if (backups.length === 0) {
            return true;
          }
          const mostRecentBackup = backups[0];
          if (mostRecentBackup.isBinary) {
            return true;
          } else {
            if (newContent === void 0) {
              const file = this.app.vault.getAbstractFileByPath(filePath);
              if (file && file instanceof import_obsidian2.TFile) {
                newContent = await this.app.vault.read(file);
              } else {
                return true;
              }
            }
            return mostRecentBackup.content !== newContent;
          }
        } catch (error) {
          console.error("Failed to check if backup should be created:", error);
          return true;
        }
      }
      /**
       * Loads backup data from the JSON file
       */
      async loadBackupData() {
        try {
          const adapter = this.app.vault.adapter;
          if (await adapter.exists(this.backupFilePath)) {
            const content = await adapter.read(this.backupFilePath);
            const parsed = JSON.parse(content);
            if (parsed && typeof parsed === "object" && parsed.backups) {
              return parsed;
            }
          }
        } catch (error) {
          console.error("Failed to load backup data:", error);
        }
        return { backups: {} };
      }
      /**
       * Saves backup data to the JSON file
       */
      async saveBackupData(backupData) {
        var _a2;
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          try {
            if (!await adapter.exists(backupDir)) {
              await adapter.mkdir(backupDir);
            }
          } catch (mkdirError) {
          }
          const debug3 = (_a2 = window == null ? void 0 : window.aiAssistantPlugin) == null ? void 0 : _a2.debugMode;
          const json2 = debug3 ? JSON.stringify(backupData, null, 2) : JSON.stringify(backupData);
          await adapter.write(this.backupFilePath, json2);
        } catch (error) {
          console.error("Failed to save backup data:", error);
          throw error;
        }
      }
      /**
       * Gets the total number of backups across all files
       */
      async getTotalBackupCount() {
        try {
          const backupData = await this.loadBackupData();
          return Object.values(backupData.backups).reduce((total, backups) => total + backups.length, 0);
        } catch (error) {
          console.error("Failed to get total backup count:", error);
          return 0;
        }
      }
      /**
       * Gets the total size of all backups in bytes (approximate)
       */
      async getTotalBackupSize() {
        try {
          const backupData = await this.loadBackupData();
          let totalSize = 0;
          Object.values(backupData.backups).forEach((backups) => {
            backups.forEach((backup) => {
              if (backup.fileSize) {
                totalSize += backup.fileSize;
              } else if (backup.content) {
                totalSize += backup.content.length;
              }
            });
          });
          return totalSize;
        } catch (error) {
          console.error("Failed to get total backup size:", error);
          return 0;
        }
      }
      /**
       * Initializes the backup system by ensuring the directory exists
       */
      async initialize() {
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          if (!await adapter.exists(backupDir)) {
            await adapter.mkdir(backupDir);
          }
          if (!await adapter.exists(this.binaryBackupFolder)) {
            await adapter.mkdir(this.binaryBackupFolder);
          }
          if (!await adapter.exists(this.backupFilePath)) {
            await this.saveBackupData({ backups: {} });
          }
        } catch (error) {
          console.error("Failed to initialize backup system:", error);
        }
      }
      /**
       * Cleans up old backups to prevent unlimited growth
       * Removes backups older than specified days (default: 30 days)
       */
      async cleanupOldBackups(maxDays = 30) {
        try {
          const backupData = await this.loadBackupData();
          const cutoffTime = Date.now() - maxDays * 24 * 60 * 60 * 1e3;
          let cleaned = false;
          for (const filePath in backupData.backups) {
            const originalLength = backupData.backups[filePath].length;
            const removedBackups = backupData.backups[filePath].filter(
              (backup) => backup.timestamp <= cutoffTime
            );
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp > cutoffTime
            );
            if (backupData.backups[filePath].length < originalLength) {
              cleaned = true;
              for (const removedBackup of removedBackups) {
                if (removedBackup.isBinary && removedBackup.backupFilePath) {
                  try {
                    const adapter = this.app.vault.adapter;
                    if (await adapter.exists(removedBackup.backupFilePath)) {
                      await adapter.remove(removedBackup.backupFilePath);
                    }
                  } catch (error) {
                    console.error("Failed to clean up old binary backup:", error);
                  }
                }
              }
            }
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
          }
          if (cleaned) {
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to cleanup old backups:", error);
        }
      }
    };
  }
});

// src/components/chat/agent/tools/FileWriteTool.ts
async function createFileWithParents(app, filePath, content = "") {
  const parts = filePath.split("/");
  parts.pop();
  let current = "";
  for (const part of parts) {
    current = current ? `${current}/${part}` : part;
    if (current && !app.vault.getAbstractFileByPath(current)) {
      try {
        await app.vault.createFolder(current);
      } catch (err) {
        if (!/already exists/i.test((err == null ? void 0 : err.message) || "")) {
          return `Failed to create parent folder: ${(err == null ? void 0 : err.message) || err}`;
        }
      }
    }
  }
  try {
    await app.vault.create(filePath, content);
    return `Created file '${filePath}'.`;
  } catch (err) {
    return `Failed to create file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
async function createFileDirect(app, filePath, content = "") {
  try {
    await app.vault.create(filePath, content);
    return `Created file '${filePath}'.`;
  } catch (err) {
    return `Failed to create file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
async function writeFileDirect(app, filePath, content) {
  const file = app.vault.getAbstractFileByPath(filePath);
  if (!file || !(file instanceof import_obsidian3.TFile)) {
    return `File not found or is not a file: "${filePath}"`;
  }
  try {
    await app.vault.modify(file, content);
    return `Wrote to file '${filePath}'.`;
  } catch (err) {
    return `Failed to write file: ${(err == null ? void 0 : err.message) || err}`;
  }
}
var import_obsidian3, FileWriteTool;
var init_FileWriteTool = __esm({
  "src/components/chat/agent/tools/FileWriteTool.ts"() {
    import_obsidian3 = require("obsidian");
    init_BackupManager();
    init_pathValidation();
    FileWriteTool = class {
      constructor(app, backupManager) {
        this.app = app;
        __publicField(this, "name", "file_write");
        __publicField(this, "description", "Writes or modifies the content of a file in the vault, with options for creating new files, backing up existing ones, and creating parent directories. This tool is essential for managing file content.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          content: {
            type: "string",
            description: "Content to write.",
            required: true
          },
          createIfNotExists: {
            type: "boolean",
            description: "Create file if it doesn't exist.",
            default: true
          },
          backup: {
            type: "boolean",
            description: "Create backup before modifying.",
            default: true
          },
          createParentFolders: {
            type: "boolean",
            description: "Create parent folders if they don't exist.",
            required: true
          }
        });
        __publicField(this, "backupManager");
        __publicField(this, "pathValidator");
        const defaultPath = app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
        this.backupManager = backupManager || new BackupManager(app, defaultPath);
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const inputPath = params.path || params.filePath || params.filename;
        const { content, createIfNotExists = true, backup = true, createParentFolders } = params;
        if (inputPath === void 0 || inputPath === null) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        if (typeof createParentFolders !== "boolean") {
          return {
            success: false,
            error: "createParentFolders parameter is required and must be boolean"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (content === void 0 || content === null) {
          return {
            success: false,
            error: "content parameter is required"
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            if (!createIfNotExists) {
              return {
                success: false,
                error: `File not found and createIfNotExists is false: ${filePath}`
              };
            }
            let result2;
            if (createParentFolders) {
              result2 = await createFileWithParents(this.app, filePath, content);
            } else {
              const parentPath = filePath.split("/").slice(0, -1).join("/");
              if (parentPath && !this.app.vault.getAbstractFileByPath(parentPath)) {
                return {
                  success: false,
                  error: `Parent folder does not exist: ${parentPath}`
                };
              }
              result2 = await createFileDirect(this.app, filePath, content);
            }
            if (result2.startsWith("Failed to create")) {
              return {
                success: false,
                error: result2
              };
            }
            return {
              success: true,
              data: {
                action: "created",
                filePath,
                size: content.length
              }
            };
          }
          if (!(file instanceof import_obsidian3.TFile)) {
            return {
              success: false,
              error: `Path is not a file: ${filePath}`
            };
          }
          let originalContent = void 0;
          if (backup || true) {
            originalContent = await this.app.vault.read(file);
          }
          if (backup) {
            const shouldBackup = await this.backupManager.shouldCreateBackup(filePath, content);
            if (shouldBackup) {
              await this.backupManager.createBackup(filePath, originalContent);
            }
          }
          if (originalContent === content) {
            return {
              success: true,
              data: {
                action: "unchanged",
                filePath,
                size: content.length,
                backupCreated: backup
              }
            };
          }
          const result = await writeFileDirect(this.app, filePath, content);
          if (result.startsWith("Failed to write")) {
            return {
              success: false,
              error: result
            };
          }
          return {
            success: true,
            data: {
              action: "modified",
              filePath,
              size: content.length,
              backupCreated: backup
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to write file: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/chat/filediffhandler.ts
function createSuggestionBlock(suggestionText) {
  return `\`\`\`suggestion
${suggestionText}
\`\`\``;
}
async function insertFileChangeSuggestion(vault, file, suggestionText, position) {
  const content = await vault.read(file);
  const lines = content.split("\n");
  const suggestionBlock = createSuggestionBlock(suggestionText);
  if (position !== void 0 && position >= 0 && position <= lines.length) {
    lines.splice(position, 0, suggestionBlock);
  } else {
    lines.push(suggestionBlock);
  }
  await vault.modify(file, lines.join("\n"));
}
function showFileChangeSuggestionsModal(app, suggestions) {
  new FileChangeSuggestionsModal(app, suggestions).open();
}
function formatSuggestionForDisplay(suggestionText) {
  const html = suggestionText.split("\n").map((line) => {
    if (line.startsWith("+")) return `<span class="suggestion-add">${line}</span>`;
    if (line.startsWith("-")) return `<span class="suggestion-remove">${line}</span>`;
    return line;
  }).join("<br>");
  return `<pre>${html}</pre>`;
}
var import_obsidian4, FileChangeSuggestionsModal;
var init_filediffhandler = __esm({
  "src/components/chat/filediffhandler.ts"() {
    import_obsidian4 = require("obsidian");
    FileChangeSuggestionsModal = class extends import_obsidian4.Modal {
      constructor(app, suggestions) {
        super(app);
        __publicField(this, "suggestions");
        this.suggestions = suggestions;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("ai-assistant-modal");
        contentEl.createEl("h2", { text: "File Change Suggestions" });
        this.suggestions.forEach((s) => {
          const container = contentEl.createDiv("suggestion-container");
          container.createEl("h4", { text: s.file.path });
          container.createEl("pre", { text: s.suggestionText });
          const btnRow = container.createDiv("suggestion-btn-row");
          const acceptBtn = btnRow.createEl("button", { text: "Accept" });
          const rejectBtn = btnRow.createEl("button", { text: "Reject" });
          acceptBtn.onclick = () => {
            var _a2;
            (_a2 = s.onAccept) == null ? void 0 : _a2.call(s);
            new import_obsidian4.Notice("Suggestion accepted");
            this.close();
          };
          rejectBtn.onclick = () => {
            var _a2;
            (_a2 = s.onReject) == null ? void 0 : _a2.call(s);
            new import_obsidian4.Notice("Suggestion rejected");
            this.close();
          };
        });
      }
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/agent/tools/FileDiffTool.ts
var import_obsidian5, FileDiffTool;
var init_FileDiffTool = __esm({
  "src/components/chat/agent/tools/FileDiffTool.ts"() {
    import_obsidian5 = require("obsidian");
    init_filediffhandler();
    init_pathValidation();
    FileDiffTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_diff");
        __publicField(this, "description", "Manages file changes: compares content, applies modifications, or presents suggestions for user review. This tool is essential for precise file manipulation and collaborative editing workflows.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          originalContent: {
            type: "string",
            description: "Original content for comparison.",
            required: false
          },
          suggestedContent: {
            type: "string",
            description: "New content for the file.",
            required: true
          },
          action: {
            type: "string",
            enum: ["compare", "apply", "suggest"],
            description: "Action: compare, apply, or suggest changes.",
            default: "suggest"
          },
          insertPosition: {
            type: "number",
            description: "Line number for suggestion insertion.",
            required: false
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const inputPath = params.path || params.filePath;
        const suggestedContent = params.suggestedContent || params.text;
        const { originalContent, action = "suggest", insertPosition } = params;
        if (inputPath === void 0 || inputPath === null) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (!suggestedContent) {
          return {
            success: false,
            error: "suggestedContent parameter is required"
          };
        }
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file || !(file instanceof import_obsidian5.TFile)) {
            return {
              success: false,
              error: `File not found: ${filePath}`
            };
          }
          const currentContent = originalContent || await this.app.vault.read(file);
          switch (action) {
            case "compare":
              return this.compareFiles(currentContent, suggestedContent, filePath);
            case "apply":
              return this.applyChanges(file, suggestedContent);
            case "suggest":
            default:
              return this.showSuggestion(file, currentContent, suggestedContent, insertPosition);
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to process file diff: ${error.message}`
          };
        }
      }
      compareFiles(originalContent, suggestedContent, filePath) {
        const diff = this.generateDiff(originalContent, suggestedContent);
        return {
          success: true,
          data: {
            action: "compare",
            filePath,
            diff,
            formattedDiff: formatSuggestionForDisplay(diff),
            hasChanges: diff.length > 0
          }
        };
      }
      async applyChanges(file, suggestedContent) {
        try {
          await this.app.vault.modify(file, suggestedContent);
          return {
            success: true,
            data: {
              action: "apply",
              filePath: file.path,
              size: suggestedContent.length
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to apply changes: ${error.message}`
          };
        }
      }
      async showSuggestion(file, originalContent, suggestedContent, insertPosition) {
        const diff = this.generateDiff(originalContent, suggestedContent);
        if (diff.length === 0) {
          return {
            success: true,
            data: {
              action: "suggest",
              filePath: file.path,
              message: "No changes detected"
            }
          };
        }
        try {
          const suggestion = {
            file,
            suggestionText: diff,
            onAccept: () => {
              this.app.vault.modify(file, suggestedContent);
            },
            onReject: () => {
            }
          };
          showFileChangeSuggestionsModal(this.app, [suggestion]);
          if (insertPosition !== void 0) {
            await insertFileChangeSuggestion(this.app.vault, file, diff, insertPosition);
          }
          return {
            success: true,
            data: {
              action: "suggest",
              filePath: file.path,
              diff,
              suggestionInserted: insertPosition !== void 0
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to show suggestion: ${error.message}`
          };
        }
      }
      generateDiff(original, suggested) {
        const originalLines = original.split("\n");
        const suggestedLines = suggested.split("\n");
        const diff = [];
        const maxLines = Math.max(originalLines.length, suggestedLines.length);
        for (let i = 0; i < maxLines; i++) {
          const originalLine = originalLines[i] || "";
          const suggestedLine = suggestedLines[i] || "";
          if (originalLine !== suggestedLine) {
            if (originalLine && !suggestedLine) {
              diff.push(`-${originalLine}`);
            } else if (!originalLine && suggestedLine) {
              diff.push(`+${suggestedLine}`);
            } else if (originalLine !== suggestedLine) {
              diff.push(`-${originalLine}`);
              diff.push(`+${suggestedLine}`);
            }
          }
        }
        return diff.join("\n");
      }
    };
  }
});

// src/components/chat/agent/tools/FileMoveTool.ts
var import_obsidian6, FileMoveTool;
var init_FileMoveTool = __esm({
  "src/components/chat/agent/tools/FileMoveTool.ts"() {
    import_obsidian6 = require("obsidian");
    init_pathValidation();
    FileMoveTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_move");
        __publicField(this, "description", "Relocates or renames files within the vault, providing options to create necessary directories and handle existing files. This tool is vital for organizing and restructuring content.");
        __publicField(this, "parameters", {
          sourcePath: {
            type: "string",
            description: "Path of the source file.",
            required: true
          },
          destinationPath: {
            type: "string",
            description: "New path for the file.",
            required: true
          },
          createFolders: {
            type: "boolean",
            description: "Create parent folders if they don't exist.",
            default: true
          },
          overwrite: {
            type: "boolean",
            description: "Overwrite destination if it exists.",
            default: false
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        let inputSourcePath = params.sourcePath;
        let inputDestinationPath = params.destinationPath;
        if (!inputSourcePath && params.path) inputSourcePath = params.path;
        if (!inputDestinationPath && (params.new_path || params.newPath)) inputDestinationPath = params.new_path || params.newPath;
        const { createFolders = true, overwrite = false } = params;
        if (inputSourcePath === void 0 || inputSourcePath === null || inputDestinationPath === void 0 || inputDestinationPath === null) {
          return {
            success: false,
            error: "Both sourcePath and destinationPath parameters are required (aliases: path, new_path, newPath)"
          };
        }
        let sourcePath;
        let destinationPath;
        try {
          sourcePath = this.pathValidator.validateAndNormalizePath(inputSourcePath);
          destinationPath = this.pathValidator.validateAndNormalizePath(inputDestinationPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        try {
          const sourceFile = this.app.vault.getAbstractFileByPath(sourcePath);
          if (!sourceFile) {
            return {
              success: false,
              error: `Source file not found: ${sourcePath}`
            };
          }
          if (!(sourceFile instanceof import_obsidian6.TFile)) {
            return {
              success: false,
              error: `Source path is not a file: ${sourcePath}`
            };
          }
          const destinationExists = this.app.vault.getAbstractFileByPath(destinationPath);
          if (destinationExists && !overwrite) {
            return {
              success: false,
              error: `Destination already exists and overwrite is not enabled: ${destinationPath}`
            };
          }
          const lastSlashIndex = destinationPath.lastIndexOf("/");
          const destinationFolder = lastSlashIndex !== -1 ? destinationPath.substring(0, lastSlashIndex) : "";
          if (destinationFolder && createFolders) {
            const folderExists = this.app.vault.getAbstractFileByPath(destinationFolder);
            if (!folderExists) {
              await this.app.vault.createFolder(destinationFolder);
            } else if (!(folderExists instanceof import_obsidian6.TFolder)) {
              return {
                success: false,
                error: `Destination parent path is not a folder: ${destinationFolder}`
              };
            }
          }
          await this.app.fileManager.renameFile(sourceFile, destinationPath);
          return {
            success: true,
            data: {
              action: "moved",
              sourcePath,
              destinationPath
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to move file: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }
    };
  }
});

// src/components/chat/agent/tools/ThoughtTool.ts
var ThoughtTool;
var init_ThoughtTool = __esm({
  "src/components/chat/agent/tools/ThoughtTool.ts"() {
    ThoughtTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "thought");
        __publicField(this, "description", 'Record AI reasoning and suggest next tool. When nextTool is "finished", include final response in thought parameter. When planning, check the file list tool for available files and folders.');
        __publicField(this, "parameters", {
          thought: {
            type: "string",
            description: "The reasoning step to record",
            required: true
          },
          nextTool: {
            type: "string",
            description: 'Next tool name or "finished" if complete. ALWAYS use "finished" to indicate no further action is needed.',
            required: true
          },
          nextActionDescription: {
            type: "string",
            description: "Brief description of next step",
            required: true
          }
        });
      }
      async execute(params, context) {
        var _a2;
        if (context && context.plugin && typeof context.plugin.debugLog === "function") {
          context.plugin.debugLog("info", "[ThoughtTool] execute called", { params, context });
        }
        const actualParams = params.parameters || params;
        if ((!actualParams.thought || actualParams.thought.trim().length === 0) && actualParams.reasoning) {
          if (context && context.plugin && typeof context.plugin.debugLog === "function") {
            context.plugin.debugLog("debug", "[ThoughtTool] Aliasing reasoning to thought", { params: actualParams });
          }
          actualParams.thought = actualParams.reasoning;
        }
        if (!actualParams.thought || typeof actualParams.thought !== "string" || actualParams.thought.trim().length === 0) {
          if (context && context.plugin && typeof context.plugin.debugLog === "function") {
            context.plugin.debugLog("warn", "[ThoughtTool] Missing or invalid thought parameter", { params: actualParams });
          }
          return { success: false, error: 'Parameter "thought" is required and must be a non-empty string.' };
        }
        if (!actualParams.nextTool || typeof actualParams.nextTool !== "string" || actualParams.nextTool.trim().length === 0) {
          return {
            success: false,
            error: 'Parameter "nextTool" is required and must be a non-empty string.'
          };
        }
        const thought = actualParams.thought.trim();
        const nextTool = actualParams.nextTool.trim();
        const nextActionDescription = ((_a2 = actualParams.nextActionDescription) == null ? void 0 : _a2.trim()) || void 0;
        const finished = nextTool.toLowerCase() === "finished";
        const step = typeof actualParams.step === "number" && actualParams.step > 0 ? actualParams.step : void 0;
        const totalSteps = typeof actualParams.totalSteps === "number" && actualParams.totalSteps > 0 ? actualParams.totalSteps : void 0;
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const stepInfo = step && totalSteps ? `Step ${step}/${totalSteps}` : step ? `Step ${step}` : "";
        const formattedThought = this.renderThought({
          thought,
          stepInfo,
          timestamp: timestamp2,
          nextTool,
          nextActionDescription,
          finished
        });
        if (context && context.plugin && typeof context.plugin.debugLog === "function") {
          context.plugin.debugLog("info", "[ThoughtTool] ThoughtTool execution complete", { result: { thought: actualParams.thought } });
        }
        return {
          success: true,
          data: {
            thought,
            step,
            totalSteps,
            timestamp: timestamp2,
            nextTool,
            nextActionDescription,
            finished,
            formattedThought
          }
        };
      }
      /**
       * Render a thought in a visually distinct, concise format for MCP tool output.
       * Enhanced to include next tool information and completion status.
       * @param opts - Rendering options
       * @returns Formatted string
       */
      renderThought(opts) {
        const { thought, stepInfo, nextTool, finished } = opts;
        const statusEmoji = finished ? "\u2705" : "\u{1F914}";
        const stepPrefix = stepInfo ? `${stepInfo} ` : "";
        const header = `${statusEmoji} ${stepPrefix}${finished ? "Complete" : `\u2192 ${nextTool}`}`;
        return `${header}
> ${thought}`;
      }
    };
  }
});

// src/components/chat/agent/tools/FileListTool.ts
var import_obsidian7, FileListTool;
var init_FileListTool = __esm({
  "src/components/chat/agent/tools/FileListTool.ts"() {
    import_obsidian7 = require("obsidian");
    init_pathValidation();
    FileListTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_list");
        __publicField(this, "description", "Retrieves a comprehensive list of files and folders within a specified directory, offering options for recursive traversal. This tool is crucial for understanding project structure and navigating the file system.");
        __publicField(this, "parameters", {
          path: { type: "string", description: "Path to the folder.", required: false },
          recursive: { type: "boolean", description: "List files recursively.", default: false },
          maxResults: { type: "number", description: "Maximum number of results to return.", default: 100 }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const inputPath = params.path || params.folderPath || params.folder || "";
        const { recursive = false, maxResults = 100 } = params;
        let folderPath;
        try {
          folderPath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        const vault = this.app.vault;
        let folder;
        if (folderPath === "" || folderPath === "/") {
          folder = vault.getRoot();
        } else {
          folder = vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            const allFolders = vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian7.TFolder);
            const match = allFolders.find((f) => f.path.toLowerCase() === folderPath.toLowerCase());
            if (match) folder = match;
          }
        }
        if (!folder || !(folder instanceof import_obsidian7.TFolder)) {
          return {
            success: false,
            error: "Folder not found: " + (folderPath || "(root)")
          };
        }
        const itemsList = [];
        let totalItems = 0;
        const walk = (currentFolder, indent = "", remainingLimit = maxResults) => {
          if (totalItems >= maxResults || remainingLimit <= 0) {
            return;
          }
          const files = currentFolder.children.filter((child) => child instanceof import_obsidian7.TFile);
          const folders = currentFolder.children.filter((child) => child instanceof import_obsidian7.TFolder);
          const folderCount = recursive ? folders.length : 0;
          const fileSlots = Math.max(1, Math.floor(remainingLimit / Math.max(1, folderCount + 1)));
          let filesAdded = 0;
          for (const file of files) {
            if (totalItems >= maxResults || filesAdded >= fileSlots) {
              break;
            }
            itemsList.push(`${indent}\u{1F4C4}${file.name}`);
            totalItems++;
            filesAdded++;
          }
          if (recursive && folderCount > 0) {
            const remainingAfterFiles = remainingLimit - filesAdded;
            const perFolderLimit = Math.max(1, Math.floor(remainingAfterFiles / folderCount));
            for (const subfolder of folders) {
              if (totalItems >= maxResults) {
                break;
              }
              itemsList.push(`${indent}\u{1F4C1}${subfolder.name}/(`);
              totalItems++;
              walk(subfolder, indent + "  ", perFolderLimit);
              if (totalItems < maxResults) {
                itemsList.push(`${indent})`);
              }
            }
          } else {
            for (const subfolder of folders) {
              if (totalItems >= maxResults) {
                break;
              }
              itemsList.push(`${indent}\u{1F4C1}${subfolder.name}/(`);
              totalItems++;
              itemsList.push(`${indent})`);
            }
          }
        };
        try {
          walk(folder);
          const truncated = totalItems >= maxResults;
          const listing = itemsList.join(",\n");
          return {
            success: true,
            data: {
              items: listing,
              count: totalItems,
              path: folderPath,
              recursive,
              maxResults,
              truncated
            }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
    };
  }
});

// src/components/chat/agent/tools/FileRenameTool.ts
var import_obsidian8, FileRenameTool;
var init_FileRenameTool = __esm({
  "src/components/chat/agent/tools/FileRenameTool.ts"() {
    import_obsidian8 = require("obsidian");
    init_pathValidation();
    FileRenameTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_rename");
        __publicField(this, "description", "Renames a file within the vault, allowing for simple name changes without altering its directory. This tool is useful for maintaining consistent naming conventions and improving file organization.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          newName: {
            type: "string",
            description: "New name for the file.",
            required: true
          },
          overwrite: {
            type: "boolean",
            description: "Overwrite if a file with the new name exists.",
            default: false
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const { path: inputPath, newName, newPath, overwrite = false } = params;
        const finalNewName = newName || newPath;
        if (inputPath === void 0 || inputPath === null || finalNewName === void 0 || finalNewName === null) {
          return {
            success: false,
            error: "Both path and newName (or newPath) parameters are required"
          };
        }
        let path;
        try {
          path = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        try {
          const vault = this.app.vault;
          const file = vault.getAbstractFileByPath(path);
          if (!file || !(file instanceof import_obsidian8.TFile)) {
            return {
              success: false,
              error: "File not found: " + path
            };
          }
          const parent = file.parent;
          if (!parent) {
            return {
              success: false,
              error: "Parent folder not found for file: " + path
            };
          }
          const newPathFull = parent.path ? `${parent.path}/${finalNewName}` : finalNewName;
          if (!overwrite && vault.getAbstractFileByPath(newPathFull)) {
            return {
              success: false,
              error: "A file with the new name already exists: " + newPathFull
            };
          }
          await vault.rename(file, newPathFull);
          return {
            success: true,
            data: { oldPath: path, newPath: newPathFull }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
    };
  }
});

// src/components/chat/agent/tools/VaultTreeTool.ts
var import_obsidian9, VaultTreeTool;
var init_VaultTreeTool = __esm({
  "src/components/chat/agent/tools/VaultTreeTool.ts"() {
    import_obsidian9 = require("obsidian");
    init_pathValidation();
    VaultTreeTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "vault_tree");
        __publicField(this, "description", "Generates a hierarchical tree view of the vault structure, showing only folders and their organization in a visual tree format. Perfect for understanding the overall vault organization.");
        __publicField(this, "parameters", {
          path: { type: "string", description: "Starting path for the tree (defaults to vault root)", required: false },
          maxDepth: { type: "number", description: "Maximum depth to traverse", default: 10 },
          maxItems: { type: "number", description: "Maximum total items to include", default: 200 },
          showFolders: { type: "boolean", description: "Whether to include folders in the tree", default: true }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const {
          path = "",
          maxDepth = 10,
          maxItems = 200,
          showFolders = true
        } = params;
        let startPath;
        try {
          startPath = this.pathValidator.validateAndNormalizePath(path);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        const vault = this.app.vault;
        let startFolder;
        if (startPath === "" || startPath === "/") {
          startFolder = vault.getRoot();
        } else {
          startFolder = vault.getAbstractFileByPath(startPath);
        }
        if (!startFolder || !(startFolder instanceof import_obsidian9.TFolder)) {
          return {
            success: false,
            error: "Folder not found: " + (startPath || "(root)")
          };
        }
        const treeLines = [];
        let totalItems = 0;
        let truncated = false;
        const buildTree = (folder, prefix = "", depth = 0) => {
          if (depth > maxDepth || totalItems >= maxItems) {
            if (totalItems >= maxItems) {
              truncated = true;
            }
            return;
          }
          if (depth > 0 && showFolders) {
            const itemCount = folder.children.length;
            treeLines.push(`${prefix}\u{1F4C1}${folder.name}/(${itemCount} items)`);
            totalItems++;
            if (totalItems >= maxItems) {
              truncated = true;
              return;
            }
          }
          const children = [...folder.children];
          children.sort((a, b) => {
            if (a instanceof import_obsidian9.TFolder && b instanceof import_obsidian9.TFile) return -1;
            if (a instanceof import_obsidian9.TFile && b instanceof import_obsidian9.TFolder) return 1;
            return a.name.localeCompare(b.name);
          });
          const filteredChildren = children.filter((child) => {
            if (child instanceof import_obsidian9.TFolder) return showFolders;
            return false;
          });
          filteredChildren.forEach((child, index) => {
            if (totalItems >= maxItems) {
              truncated = true;
              return;
            }
            const newPrefix = depth > 0 ? prefix + "  " : "";
            if (child instanceof import_obsidian9.TFile) {
            } else if (child instanceof import_obsidian9.TFolder) {
              buildTree(child, newPrefix, depth + 1);
            }
          });
        };
        try {
          if (startPath === "" || startPath === "/") {
            const rootItemCount = startFolder.children.length;
            treeLines.push(`\u{1F4C1}Vault Root/(${rootItemCount} items)`);
            totalItems++;
          }
          buildTree(startFolder, "", startPath === "" || startPath === "/" ? 0 : -1);
          const tree = treeLines.join(",\n");
          const stats = {
            totalItems,
            maxDepth,
            maxItems,
            truncated,
            startPath: startPath || "/",
            showFolders
          };
          return {
            success: true,
            data: {
              tree,
              stats,
              // Legacy format for compatibility
              items: tree,
              count: totalItems,
              path: startPath || "/"
            }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
      getFileIcon(extension) {
        const iconMap = {
          "md": "\u{1F4DD}",
          "txt": "\u{1F4C4}",
          "pdf": "\u{1F4D5}",
          "doc": "\u{1F4D8}",
          "docx": "\u{1F4D8}",
          "xls": "\u{1F4CA}",
          "xlsx": "\u{1F4CA}",
          "ppt": "\u{1F4CA}",
          "pptx": "\u{1F4CA}",
          "png": "\u{1F5BC}\uFE0F",
          "jpg": "\u{1F5BC}\uFE0F",
          "jpeg": "\u{1F5BC}\uFE0F",
          "gif": "\u{1F5BC}\uFE0F",
          "svg": "\u{1F5BC}\uFE0F",
          "mp3": "\u{1F3B5}",
          "wav": "\u{1F3B5}",
          "mp4": "\u{1F3AC}",
          "avi": "\u{1F3AC}",
          "zip": "\u{1F4E6}",
          "rar": "\u{1F4E6}",
          "json": "\u2699\uFE0F",
          "yaml": "\u2699\uFE0F",
          "yml": "\u2699\uFE0F",
          "css": "\u{1F3A8}",
          "js": "\u26A1",
          "ts": "\u26A1",
          "html": "\u{1F310}",
          "xml": "\u{1F310}"
        };
        return iconMap[extension.toLowerCase()] || "\u{1F4C4}";
      }
    };
  }
});

// src/components/chat/agent/tools/FileDeleteTool.ts
var import_obsidian10, FileDeleteTool;
var init_FileDeleteTool = __esm({
  "src/components/chat/agent/tools/FileDeleteTool.ts"() {
    import_obsidian10 = require("obsidian");
    init_BackupManager();
    init_pathValidation();
    FileDeleteTool = class {
      constructor(app, backupManager) {
        this.app = app;
        __publicField(this, "name", "file_delete");
        __publicField(this, "description", "Safely deletes files or folders from the vault by moving them to a .trash folder (default) or permanently deleting them. The trash option provides safer file management and allows restoration. For folders, creates backups of all contained files before deletion.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file or folder to delete.",
            required: true
          },
          backup: {
            type: "boolean",
            description: "Create backup before deletion.",
            default: true
          },
          confirmDeletion: {
            type: "boolean",
            description: "Extra confirmation that deletion is intended.",
            default: true
          },
          useTrash: {
            type: "boolean",
            description: "Move to .trash folder instead of permanent deletion (default: true for safety).",
            default: true
          }
        });
        __publicField(this, "backupManager");
        __publicField(this, "pathValidator");
        const defaultPath = app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
        this.backupManager = backupManager || new BackupManager(app, defaultPath);
        this.pathValidator = new PathValidator(app);
      }
      async execute(params, context) {
        const inputPath = params.path || params.filePath;
        const { backup = true, confirmDeletion = true, useTrash = true } = params;
        if (inputPath === void 0 || inputPath === null) {
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (confirmDeletion !== true) {
          return {
            success: false,
            error: "confirmDeletion must be set to true to proceed with deletion. This is a safety measure."
          };
        }
        try {
          const target = this.app.vault.getAbstractFileByPath(filePath);
          if (!target) {
            return {
              success: false,
              error: `File or folder not found: ${filePath}`
            };
          }
          let backupCreated = false;
          let totalSize = 0;
          let backupCount = 0;
          if (target instanceof import_obsidian10.TFile) {
            let originalContent = "";
            if (backup) {
              try {
                originalContent = await this.app.vault.read(target);
                await this.backupManager.createBackup(filePath, originalContent);
                backupCreated = true;
                backupCount = 1;
              } catch (backupError) {
                return {
                  success: false,
                  error: `Failed to create backup before deletion: ${backupError.message}`
                };
              }
            }
            let actionTaken = "";
            let trashPath = "";
            if (useTrash) {
              try {
                trashPath = await this.moveToTrash(target, filePath);
                actionTaken = "moved to trash";
              } catch (trashError) {
                return {
                  success: false,
                  error: `Failed to move file to trash: ${trashError.message}`
                };
              }
            } else {
              try {
                await this.app.vault.delete(target);
                actionTaken = "permanently deleted";
              } catch (deleteError) {
                if (deleteError.message && deleteError.message.includes("EPERM")) {
                  try {
                    await this.app.vault.adapter.remove(filePath);
                    actionTaken = "permanently deleted";
                  } catch (adapterError) {
                    return {
                      success: false,
                      error: `Failed to delete file (tried multiple methods): ${deleteError.message}. Adapter error: ${adapterError.message}`
                    };
                  }
                } else {
                  return {
                    success: false,
                    error: `Failed to delete file: ${deleteError.message}`
                  };
                }
              }
            }
            totalSize = originalContent.length;
            return {
              success: true,
              data: {
                action: actionTaken,
                type: "file",
                filePath,
                trashPath: useTrash ? trashPath : void 0,
                size: totalSize,
                backupCreated,
                backupCount,
                message: `File '${filePath}' has been ${actionTaken}${backupCreated ? " (backup created)" : ""}${useTrash ? `. Location: ${trashPath}` : ""}.`
              }
            };
          } else if (target instanceof import_obsidian10.TFolder) {
            if (backup) {
              try {
                const result = await this.createFolderBackups(target, "");
                backupCreated = result.backupCreated;
                backupCount = result.backupCount;
                totalSize = result.totalSize;
              } catch (backupError) {
                return {
                  success: false,
                  error: `Failed to create backups before folder deletion: ${backupError.message}`
                };
              }
            }
            let actionTaken = "";
            let trashPath = "";
            if (useTrash) {
              try {
                trashPath = await this.moveToTrash(target, filePath);
                actionTaken = "moved to trash";
              } catch (trashError) {
                return {
                  success: false,
                  error: `Failed to move folder to trash: ${trashError.message}`
                };
              }
            } else {
              try {
                await this.app.vault.delete(target);
                actionTaken = "permanently deleted";
              } catch (deleteError) {
                if (deleteError.message && deleteError.message.includes("EPERM")) {
                  try {
                    await this.app.vault.adapter.rmdir(filePath, true);
                    actionTaken = "permanently deleted";
                  } catch (adapterError) {
                    try {
                      await this.recursivelyDeleteFolder(target);
                      actionTaken = "permanently deleted";
                    } catch (recursiveError) {
                      return {
                        success: false,
                        error: `Failed to delete folder (tried multiple methods): ${deleteError.message}. Last attempt: ${recursiveError.message}`
                      };
                    }
                  }
                } else {
                  return {
                    success: false,
                    error: `Failed to delete folder: ${deleteError.message}`
                  };
                }
              }
            }
            return {
              success: true,
              data: {
                action: actionTaken,
                type: "folder",
                filePath,
                trashPath: useTrash ? trashPath : void 0,
                size: totalSize,
                backupCreated,
                backupCount,
                message: `Folder '${filePath}' has been ${actionTaken}${backupCreated ? ` (${backupCount} files backed up)` : ""}${useTrash ? `. Location: ${trashPath}` : ""}.`
              }
            };
          } else {
            return {
              success: false,
              error: `Unsupported file type: ${filePath}`
            };
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to delete: ${error.message}`
          };
        }
      }
      /**
       * Recursively creates backups for all files in a folder
       */
      async createFolderBackups(folder, basePath) {
        let backupCount = 0;
        let totalSize = 0;
        let anyBackupCreated = false;
        for (const child of folder.children) {
          if (child instanceof import_obsidian10.TFile) {
            try {
              const content = await this.app.vault.read(child);
              const childPath = basePath ? `${basePath}/${child.name}` : child.path;
              await this.backupManager.createBackup(childPath, content);
              backupCount++;
              totalSize += content.length;
              anyBackupCreated = true;
            } catch (error) {
              console.error(`Failed to backup file ${child.path}:`, error);
            }
          } else if (child instanceof import_obsidian10.TFolder) {
            const subResult = await this.createFolderBackups(child, basePath ? `${basePath}/${child.name}` : child.path);
            backupCount += subResult.backupCount;
            totalSize += subResult.totalSize;
            if (subResult.backupCreated) {
              anyBackupCreated = true;
            }
          }
        }
        return {
          backupCreated: anyBackupCreated,
          backupCount,
          totalSize
        };
      }
      /**
       * Recursively deletes a folder by deleting all its contents first
       * This is a fallback method for Windows permission issues
       */
      async recursivelyDeleteFolder(folder) {
        for (const child of [...folder.children]) {
          if (child instanceof import_obsidian10.TFile) {
            try {
              await this.app.vault.delete(child);
            } catch (error) {
              await this.app.vault.adapter.remove(child.path);
            }
          } else if (child instanceof import_obsidian10.TFolder) {
            await this.recursivelyDeleteFolder(child);
          }
        }
        try {
          await this.app.vault.delete(folder);
        } catch (error) {
          await this.app.vault.adapter.rmdir(folder.path, false);
        }
      }
      /**
       * Ensures the .trash folder exists in the vault root
       */
      async ensureTrashFolderExists() {
        const trashPath = ".trash";
        const existingTrash = this.app.vault.getAbstractFileByPath(trashPath);
        if (!existingTrash) {
          await this.app.vault.createFolder(trashPath);
        } else if (!(existingTrash instanceof import_obsidian10.TFolder)) {
          throw new Error('A file named ".trash" already exists - cannot create trash folder');
        }
        return trashPath;
      }
      /**
       * Generates a unique name for the trash item to avoid conflicts
       */
      generateTrashName(originalPath) {
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
        const basename = originalPath.split("/").pop() || "unknown";
        const extension = basename.includes(".") ? "" : "";
        const nameWithoutExt = basename.replace(/\.[^/.]+$/, "");
        const ext = basename.includes(".") ? basename.substring(basename.lastIndexOf(".")) : "";
        return `${nameWithoutExt}_deleted_${timestamp2}${ext}`;
      }
      /**
       * Moves a file or folder to the trash folder instead of permanently deleting it
       */
      async moveToTrash(target, originalPath) {
        const trashPath = await this.ensureTrashFolderExists();
        const trashName = this.generateTrashName(originalPath);
        const destinationPath = `${trashPath}/${trashName}`;
        await this.app.fileManager.renameFile(target, destinationPath);
        return destinationPath;
      }
    };
  }
});

// src/components/chat/agent/tools/toolcollect.ts
function getAllToolClasses() {
  return [
    FileSearchTool,
    FileReadTool,
    FileWriteTool,
    FileDiffTool,
    FileMoveTool,
    ThoughtTool,
    FileListTool,
    FileRenameTool,
    VaultTreeTool,
    FileDeleteTool
  ];
}
function getToolMetadata() {
  const mockApp = {
    vault: {
      configDir: "",
      adapter: {
        basePath: "/mock/vault/path"
      },
      getAbstractFileByPath: () => null,
      read: () => Promise.resolve(""),
      create: () => Promise.resolve(null),
      modify: () => Promise.resolve()
    }
  };
  const metadata = getAllToolClasses().map((ToolClass) => {
    let instance;
    try {
      instance = new ToolClass();
    } catch (e) {
      try {
        instance = new ToolClass(void 0, void 0);
      } catch (e2) {
        try {
          instance = new ToolClass(mockApp);
        } catch (e3) {
          try {
            instance = new ToolClass(mockApp, void 0);
          } catch (e4) {
            console.warn(`Failed to instantiate tool class ${ToolClass.name} for metadata:`, e4);
            return void 0;
          }
        }
      }
    }
    if (!instance || !instance.name || !instance.description || !instance.parameters) {
      console.warn(`Tool instance missing required properties:`, {
        name: instance == null ? void 0 : instance.name,
        description: instance == null ? void 0 : instance.description,
        parameters: instance == null ? void 0 : instance.parameters
      });
      return void 0;
    }
    let parameterDescriptions = {};
    let parameterRequired = {};
    if (instance.parameters && typeof instance.parameters === "object") {
      for (const [param, value] of Object.entries(instance.parameters)) {
        if (value && typeof value === "object") {
          if ("description" in value) {
            parameterDescriptions[param] = typeof value.description === "string" ? value.description : "";
          }
          if ("required" in value) {
            parameterRequired[param] = Boolean(value.required);
          }
        }
      }
    }
    return {
      name: instance.name,
      description: instance.description,
      parameters: instance.parameters,
      parameterDescriptions,
      parameterRequired
    };
  });
  const filteredMetadata = metadata.filter((item) => !!item);
  console.log("[toolcollect] getToolMetadata result:", filteredMetadata.map((m) => m.name));
  return filteredMetadata;
}
function getAllToolNames() {
  return getToolMetadata().map((tool) => tool.name);
}
function createToolInstances(app, plugin) {
  if (plugin && typeof plugin.debugLog === "function") {
    plugin.debugLog("info", "[toolcollect] createToolInstances called");
  }
  const toolClasses = getAllToolClasses();
  const tools = toolClasses.map((ToolClass) => {
    const instance = plugin && (ToolClass.name === "FileWriteTool" || ToolClass.name === "FileDeleteTool") ? new ToolClass(app, plugin.backupManager) : new ToolClass(app);
    return instance;
  });
  if (plugin && typeof plugin.debugLog === "function") {
    plugin.debugLog("debug", "[toolcollect] Tool instances created", { count: tools.length });
  }
  return tools;
}
var init_toolcollect = __esm({
  "src/components/chat/agent/tools/toolcollect.ts"() {
    init_FileSearchTool();
    init_FileReadTool();
    init_FileWriteTool();
    init_FileDiffTool();
    init_FileMoveTool();
    init_ThoughtTool();
    init_FileListTool();
    init_FileRenameTool();
    init_VaultTreeTool();
    init_FileDeleteTool();
  }
});

// src/promptConstants.ts
var promptConstants_exports = {};
__export(promptConstants_exports, {
  AGENT_SYSTEM_PROMPT: () => AGENT_SYSTEM_PROMPT,
  AGENT_SYSTEM_PROMPT_TEMPLATE: () => AGENT_SYSTEM_PROMPT_TEMPLATE,
  DEFAULT_GENERAL_SYSTEM_PROMPT: () => DEFAULT_GENERAL_SYSTEM_PROMPT,
  DEFAULT_SUMMARY_PROMPT: () => DEFAULT_SUMMARY_PROMPT,
  DEFAULT_TITLE_PROMPT: () => DEFAULT_TITLE_PROMPT,
  DEFAULT_YAML_SYSTEM_MESSAGE: () => DEFAULT_YAML_SYSTEM_MESSAGE,
  buildAgentSystemPrompt: () => buildAgentSystemPrompt,
  getDynamicToolList: () => getDynamicToolList
});
function buildAgentSystemPrompt(enabledTools, customTemplate) {
  if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
    window.aiAssistantPlugin.debugLog("debug", "[promptConstants] buildAgentSystemPrompt called", { enabledTools, customTemplate });
  }
  const toolList = getDynamicToolList(enabledTools);
  const toolDescriptions = toolList.map((tool, idx) => {
    let paramDesc = "";
    if (tool.parameterDescriptions && Object.keys(tool.parameterDescriptions).length > 0) {
      paramDesc = "\n    Parameters:\n" + Object.entries(tool.parameterDescriptions).map(([param, desc]) => `      - ${param}: ${desc}`).join("\n");
    }
    return `${idx + 1}. ${tool.name} - ${tool.description}${paramDesc}`;
  }).join("\n");
  const template = customTemplate || AGENT_SYSTEM_PROMPT_TEMPLATE;
  return template.replace("{{TOOL_DESCRIPTIONS}}", toolDescriptions);
}
var DEFAULT_TITLE_PROMPT, DEFAULT_SUMMARY_PROMPT, DEFAULT_GENERAL_SYSTEM_PROMPT, getDynamicToolList, AGENT_SYSTEM_PROMPT_TEMPLATE, AGENT_SYSTEM_PROMPT, DEFAULT_YAML_SYSTEM_MESSAGE;
var init_promptConstants = __esm({
  "src/promptConstants.ts"() {
    init_toolcollect();
    DEFAULT_TITLE_PROMPT = "You are a title generator. You will give succinct titles that do not contain backslashes, forward slashes, or colons. Only generate a title as your response.";
    DEFAULT_SUMMARY_PROMPT = "Summarize the note content in 1-2 sentences, focusing on the main ideas and purpose.";
    DEFAULT_GENERAL_SYSTEM_PROMPT = "You are a helpful assistant in an Obsidian Vault.";
    getDynamicToolList = (enabledTools) => {
      if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
        window.aiAssistantPlugin.debugLog("debug", "[promptConstants] getDynamicToolList called", { enabledTools });
      }
      const toolMetadata = getToolMetadata();
      return toolMetadata.filter((tool) => tool.name === "thought" || !enabledTools || enabledTools[tool.name] !== false).map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters,
        parameterDescriptions: tool.parameterDescriptions
      }));
    };
    AGENT_SYSTEM_PROMPT_TEMPLATE = `
- You are an AI assistant in an Obsidian Vault with access to powerful tools for vault management. ALWAYS start by using the 'thought' tool to outline your plan before executing actions, and at the end of the task. ALWAYS use relative path from vault root
ALWAYS reason about tool results before proceeding. Respond ONLY with a JSON object

Available tools:
{{TOOL_DESCRIPTIONS}}

When using tools, respond ONLY with a JSON object using this parameter framework:
{
  "action": "tool_name", // thought, file_search, file_read, etc.
  "parameters": { 
    /* other tool-specific parameters */
  },
  "requestId": "unique_id"
}
  example:
  {
  "action": "thought",
  "parameters": {
    "thought": "...",
    "nextTool": "finished",
    "nextActionDescription": "..."
  }
}
`;
    AGENT_SYSTEM_PROMPT = buildAgentSystemPrompt();
    DEFAULT_YAML_SYSTEM_MESSAGE = "You are an assistant that generates YAML attribute values for Obsidian notes. Read the note and generate a value for the specified YAML field. Only output the value, not the key or extra text.";
  }
});

// src/types/settings.ts
var DEFAULT_SETTINGS;
var init_settings = __esm({
  "src/types/settings.ts"() {
    init_promptConstants();
    DEFAULT_SETTINGS = {
      referenceCurrentNote: false,
      provider: "openai",
      selectedModel: void 0,
      availableModels: [],
      openaiSettings: {
        apiKey: "",
        model: "gpt-4.1",
        availableModels: []
      },
      anthropicSettings: {
        apiKey: "",
        model: "claude-3-5-sonnet-latest",
        availableModels: []
      },
      geminiSettings: {
        apiKey: "",
        model: "gemini-2.5-flash-preview-05-20",
        availableModels: []
      },
      ollamaSettings: {
        serverUrl: "http://localhost:11434",
        model: "llama2",
        availableModels: []
      },
      systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
      temperature: 0.7,
      maxTokens: 1e3,
      includeDateWithSystemMessage: false,
      includeTimeWithSystemMessage: false,
      enableStreaming: true,
      autoOpenModelSettings: false,
      enableObsidianLinks: true,
      titleOutputMode: "clipboard",
      summaryOutputMode: "clipboard",
      chatSeparator: "----",
      chatStartString: void 0,
      chatEndString: void 0,
      enableContextNotes: false,
      contextNotes: "",
      titlePrompt: DEFAULT_TITLE_PROMPT,
      summaryPrompt: DEFAULT_SUMMARY_PROMPT,
      maxSessions: 10,
      autoSaveSessions: true,
      sessions: [],
      activeSessionId: void 0,
      expandLinkedNotesRecursively: false,
      maxLinkExpansionDepth: 2,
      chatNoteFolder: "",
      // Default to vault root
      yamlAttributeGenerators: [
        {
          attributeName: "summary",
          prompt: DEFAULT_SUMMARY_PROMPT,
          outputMode: "metadata",
          commandName: "Generate YAML: summary"
        }
      ],
      providerConfigExpanded: {
        openai: false,
        anthropic: false,
        gemini: false,
        ollama: false
      },
      generalSectionsExpanded: {
        "AI Model Settings": true,
        "Date Settings": true,
        "Note Reference Settings": true,
        "Provider Configuration": true,
        // For the main group of provider configs
        "AI Model Configuration": true
      },
      apiKeysExpanded: {},
      modelManagementExpanded: {},
      agentConfigExpanded: {},
      contentChatExpanded: {},
      dataHandlingExpanded: {},
      pluginBehaviorExpanded: {},
      backupManagementExpanded: {},
      modelSettingPresets: [
        {
          name: "Default",
          selectedModel: void 0,
          systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
          temperature: 0.7,
          maxTokens: 1e3,
          enableStreaming: true
        }
      ],
      customAgentSystemMessage: void 0,
      // Use default agent system message
      uiBehavior: {
        collapseOldReasoning: true,
        showCompletionNotifications: true,
        includeReasoningInExports: true
      },
      enabledTools: {},
      enabledModels: {},
      debugMode: false,
      agentMode: {
        enabled: false,
        maxToolCalls: 10,
        timeoutMs: 3e4,
        maxIterations: 10
      }
    };
  }
});

// src/types/index.ts
var types_exports = {};
__export(types_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS
});
var init_types = __esm({
  "src/types/index.ts"() {
    init_settings();
  }
});

// src/utils/pluginUtils.ts
function registerCommand(plugin, options, ribbonIcon, ribbonTitle) {
  plugin.addCommand(options);
  if (ribbonIcon && ribbonTitle) {
    plugin.addRibbonIcon(ribbonIcon, ribbonTitle, options.callback || (() => {
    }));
  }
}
var init_pluginUtils = __esm({
  "src/utils/pluginUtils.ts"() {
  }
});

// src/components/chat/Buttons.ts
function createActionButton(label, tooltip, callback) {
  const button = document.createElement("button");
  button.addClass("ai-chat-action-button");
  button.setAttribute("aria-label", tooltip);
  const labelEl = document.createElement("span");
  labelEl.textContent = label;
  button.appendChild(labelEl);
  button.addEventListener("click", callback);
  return button;
}
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
  } catch (error) {
  }
}
var import_obsidian12, Buttons;
var init_Buttons = __esm({
  "src/components/chat/Buttons.ts"() {
    import_obsidian12 = require("obsidian");
    Buttons = class extends import_obsidian12.Component {
      constructor() {
        super();
        __publicField(this, "container");
        __publicField(this, "sendButton");
        __publicField(this, "stopButton");
        __publicField(this, "clearButton");
        __publicField(this, "settingsButton");
        this.container = document.createElement("div");
        this.container.addClass("ai-chat-buttons");
        this.sendButton = new import_obsidian12.ButtonComponent(this.container).setButtonText("Send").setClass("mod-cta");
        this.sendButton.buttonEl.addClass("hidden-button");
        this.stopButton = new import_obsidian12.ButtonComponent(this.container).setButtonText("Stop");
        this.stopButton.buttonEl.addClass("hidden-button");
        this.clearButton = new import_obsidian12.ButtonComponent(this.container).setButtonText("Clear");
        this.clearButton.buttonEl.addClass("hidden-button");
        this.settingsButton = new import_obsidian12.ButtonComponent(this.container).setButtonText("Settings");
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Get the button container element
       */
      getContainer() {
        return this.container;
      }
      getSendButton() {
        return this.sendButton;
      }
      getStopButton() {
        return this.stopButton;
      }
      getClearButton() {
        return this.clearButton;
      }
      getSettingsButton() {
        return this.settingsButton;
      }
      showSendButton() {
        this.sendButton.buttonEl.removeClass("hidden-button");
      }
      hideSendButton() {
        this.sendButton.buttonEl.addClass("hidden-button");
      }
      showStopButton() {
        this.stopButton.buttonEl.removeClass("hidden-button");
      }
      hideStopButton() {
        this.stopButton.buttonEl.addClass("hidden-button");
      }
      showClearButton() {
        this.clearButton.buttonEl.removeClass("hidden-button");
      }
      hideClearButton() {
        this.clearButton.buttonEl.addClass("hidden-button");
      }
      showSettingsButton() {
        this.settingsButton.buttonEl.removeClass("hidden-button");
      }
      hideSettingsButton() {
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Create action buttons for messages (copy, edit, delete, regenerate)
       */
      createMessageActions(buttons) {
        const actionsContainer = document.createElement("div");
        actionsContainer.addClass("message-actions");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          actionsContainer.appendChild(button);
        });
        return actionsContainer;
      }
      /**
       * Create the main chat control buttons (send, stop, copy all, clear, settings)
       */
      createChatControls(buttons) {
        const controlsContainer = document.createElement("div");
        controlsContainer.addClass("ai-chat-buttons");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          if (config.isHidden) {
            button.addClass("hidden-button");
          }
          controlsContainer.appendChild(button);
        });
        return controlsContainer;
      }
      /**
       * Create a single button with the given configuration
       */
      createButton(config) {
        const button = document.createElement("button");
        button.addClass("ai-chat-action-button");
        if (config.className) {
          button.addClass(config.className);
        }
        button.setAttribute("aria-label", config.tooltip);
        const labelEl = document.createElement("span");
        labelEl.textContent = config.label;
        button.appendChild(labelEl);
        button.addEventListener("click", config.onClick);
        return button;
      }
      /**
       * Show or hide a specific button in a container
       */
      toggleButton(container, label, show) {
        const button = container.querySelector(`[aria-label="${label}"]`);
        if (button instanceof HTMLElement) {
          show ? button.removeClass("hidden-button") : button.addClass("hidden-button");
        }
      }
    };
  }
});

// src/components/chat/agent/ToolRichDisplay.ts
var import_obsidian13, ToolRichDisplay;
var init_ToolRichDisplay = __esm({
  "src/components/chat/agent/ToolRichDisplay.ts"() {
    import_obsidian13 = require("obsidian");
    ToolRichDisplay = class _ToolRichDisplay extends import_obsidian13.Component {
      constructor(options) {
        super();
        __publicField(this, "element");
        __publicField(this, "options");
        this.options = options;
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[ToolRichDisplay] constructor called", { options });
        }
        this.element = this.createToolDisplay();
      }
      getElement() {
        return this.element;
      }
      createToolDisplay() {
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[ToolRichDisplay] createToolDisplay called", { command: this.options.command, result: this.options.result });
        }
        return _ToolRichDisplay.createDisplayElement(this.options.command, this.options.result, {
          onRerun: this.options.onRerun,
          onCopy: this.options.onCopy
        });
      }
      getToolIcon() {
        const iconMap = {
          "file_search": "\u{1F50D}",
          "file_read": "\u{1F4D6}",
          "file_write": "\u270D\uFE0F",
          "file_diff": "\u{1F504}",
          "file_move": "\u{1F4C1}",
          "file_rename": "\u{1F3F7}\uFE0F",
          "file_list": "\u{1F4CB}",
          "thought": "\u{1F9E0}"
        };
        return iconMap[this.options.command.action] || "\u{1F527}";
      }
      getToolDisplayName() {
        const nameMap = {
          "file_search": "File Search",
          "file_read": "File Read",
          "file_write": "File Write",
          "file_diff": "File Diff",
          "file_move": "File Move",
          "file_rename": "File Rename",
          "file_list": "File List",
          "thought": "Thought Process"
        };
        return nameMap[this.options.command.action] || this.options.command.action;
      }
      formatParameters() {
        const params = this.options.command.parameters;
        const formatted = Object.entries(params).map(([key, value]) => `${key}: ${typeof value === "string" && value.length > 50 ? value.substring(0, 50) + "..." : JSON.stringify(value)}`).join(", ");
        return `<code>${formatted}</code>`;
      }
      getResultSummary() {
        if (!this.options.result.success) {
          return `<span class="tool-error">${this.options.result.error || "Unknown error"}</span>`;
        }
        const data = this.options.result.data;
        if (this.options.command.action === "file_write" && data) {
          const action = data.action || "modified";
          const filePath = data.filePath || "unknown file";
          const size = data.size ? ` (${data.size} bytes)` : "";
          if (action === "created") {
            return `<span class="tool-success">\u{1F4DD} Created file: <strong>${filePath}</strong>${size}</span>`;
          } else {
            return `<span class="tool-success">\u{1F4BE} Saved file: <strong>${filePath}</strong>${size}</span>`;
          }
        }
        if (this.options.command.action === "file_read" && data) {
          const filePath = data.filePath || this.options.command.parameters.path;
          const size = data.content ? ` (${data.content.length} chars)` : "";
          return `<span class="tool-success">\u{1F4D6} Read file: <strong>${filePath}</strong>${size}</span>`;
        }
        if (this.options.command.action === "file_search" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          return `<span class="tool-success">\u{1F50D} Found ${count} file${count !== 1 ? "s" : ""}</span>`;
        }
        if (this.options.command.action === "file_list" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          const path = data.path || this.options.command.parameters.path;
          return `<span class="tool-success">\u{1F4CB} Listed ${count} file${count !== 1 ? "s" : ""} in <strong>${path}</strong></span>`;
        }
        if (this.options.command.action === "file_move" && data) {
          const from = this.options.command.parameters.sourcePath;
          const to = this.options.command.parameters.destinationPath;
          return `<span class="tool-success">\u{1F4C1} Moved <strong>${from}</strong> \u2192 <strong>${to}</strong></span>`;
        }
        if (this.options.command.action === "file_rename" && data) {
          const oldName = this.options.command.parameters.path;
          const newName = this.options.command.parameters.newName;
          return `<span class="tool-success">\u{1F3F7}\uFE0F Renamed <strong>${oldName}</strong> \u2192 <strong>${newName}</strong></span>`;
        }
        if (this.options.command.action === "thought" && data) {
          const thought = data.thought || data.reasoning || "";
          return `<span class="tool-success">\u{1F9E0} ${thought}</span>`;
        }
        if (typeof data === "string") {
          return data;
        }
        if (Array.isArray(data)) {
          return `${data.length} items returned`;
        }
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data);
          return `Object with ${keys.length} properties`;
        }
        return "Success";
      }
      getDetailedResult() {
        if (!this.options.result.success) {
          return this.options.result.error || "Unknown error occurred";
        }
        if (this.options.result.data) {
          return typeof this.options.result.data === "string" ? this.options.result.data : JSON.stringify(this.options.result.data, null, 2);
        }
        return null;
      }
      /**
       * Update the display with new tool result
       */
      updateResult(result) {
        this.options.result = result;
        const newElement = _ToolRichDisplay.createDisplayElement(this.options.command, this.options.result, {
          onRerun: this.options.onRerun,
          onCopy: this.options.onCopy
        });
        this.element.replaceWith(newElement);
        this.element = newElement;
      }
      /**
      * Convert the tool display to markdown format for saving to notes
      */
      toMarkdown() {
        const { command, result } = this.options;
        const status = result.success ? "\u2705" : "\u274C";
        const toolName = this.getToolDisplayName();
        const icon = this.getToolIcon();
        let markdown = `
### ${icon} ${toolName} ${status}

`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          markdown += `**Parameters:**
`;
          Object.entries(command.parameters).forEach(([key, value]) => {
            const displayValue = typeof value === "string" && value.length > 100 ? value.substring(0, 100) + "..." : JSON.stringify(value);
            markdown += `- **${key}:** \`${displayValue}\`
`;
          });
          markdown += "\n";
        }
        if (result.success) {
          markdown += `**Result:** ${this.getResultSummary()}

`;
          const details = this.getDetailedResult();
          if (details && details !== this.getResultSummary()) {
            if (details.length <= 200) {
              markdown += `**Details:** \`${details}\`

`;
            } else {
              markdown += `<details>
<summary>Show Details</summary>

\`\`\`
${details}
\`\`\`

</details>

`;
            }
          }
        } else {
          markdown += `**Error:** ${result.error}

`;
        }
        return markdown;
      }
      /**
       * Static method to create a tool display element for notes (without re-run functionality)
       */
      static createNoteDisplay(command, result, options) {
        return _ToolRichDisplay.createDisplayElement(command, result, {
          ...options,
          isNote: true
        });
      }
      /**
       * Static method to create a tool display element with customizable options
       */
      static createDisplayElement(command, result, options) {
        const container = document.createElement("div");
        container.className = (options == null ? void 0 : options.isNote) ? "tool-rich-display tool-rich-display-note" : "tool-rich-display";
        const iconDiv = document.createElement("div");
        iconDiv.className = "tool-rich-icon";
        iconDiv.innerHTML = _ToolRichDisplay.getStaticToolIcon(command.action);
        container.appendChild(iconDiv);
        const infoDiv = document.createElement("div");
        infoDiv.className = "tool-rich-info";
        const titleDiv = document.createElement("div");
        titleDiv.className = "tool-rich-title";
        titleDiv.innerText = _ToolRichDisplay.getStaticToolDisplayName(command.action);
        const statusSpan = document.createElement("span");
        statusSpan.className = `tool-rich-status ${result.success ? "success" : "error"}`;
        statusSpan.innerText = result.success ? "Success" : "Error";
        titleDiv.appendChild(statusSpan);
        infoDiv.appendChild(titleDiv);
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          const paramsDiv = document.createElement("div");
          paramsDiv.innerHTML = `<strong>Parameters:</strong> ${_ToolRichDisplay.formatStaticParameters(command.parameters)}`;
          infoDiv.appendChild(paramsDiv);
        }
        const resultDiv = document.createElement("div");
        resultDiv.innerHTML = `<strong>Result:</strong> ${_ToolRichDisplay.getStaticResultSummary(command, result)}`;
        infoDiv.appendChild(resultDiv);
        const details = _ToolRichDisplay.getStaticDetailedResult(result);
        if (details) {
          const toggle = document.createElement("div");
          toggle.className = "tool-rich-details-toggle";
          toggle.innerText = "Show details \u25BC";
          const detailsDiv = document.createElement("div");
          detailsDiv.className = "tool-rich-details";
          detailsDiv.style.display = "none";
          detailsDiv.innerHTML = `<pre>${details}</pre>`;
          toggle.onclick = () => {
            const isExpanded = detailsDiv.classList.contains("expanded");
            if (isExpanded) {
              detailsDiv.classList.remove("expanded");
              detailsDiv.style.display = "none";
              toggle.innerText = "Show details \u25BC";
            } else {
              detailsDiv.classList.add("expanded");
              detailsDiv.style.display = "block";
              toggle.innerText = "Hide details \u25B2";
            }
          };
          infoDiv.appendChild(toggle);
          infoDiv.appendChild(detailsDiv);
        }
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "tool-rich-actions";
        if (!(options == null ? void 0 : options.isNote) && (options == null ? void 0 : options.onRerun)) {
          const rerunBtn = document.createElement("button");
          rerunBtn.className = "tool-rich-action-btn";
          rerunBtn.innerText = "Re-run";
          rerunBtn.onclick = options.onRerun;
          actionsDiv.appendChild(rerunBtn);
        }
        if (options == null ? void 0 : options.onCopy) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "tool-rich-action-btn";
          copyBtn.innerText = "Copy";
          copyBtn.onclick = options.onCopy;
          actionsDiv.appendChild(copyBtn);
        }
        const copyResultBtn = document.createElement("button");
        copyResultBtn.className = "tool-rich-action-btn";
        copyResultBtn.innerText = "Copy Result";
        copyResultBtn.onclick = async () => {
          const resultText = result.success ? JSON.stringify(result.data, null, 2) : result.error || "Unknown error";
          try {
            await navigator.clipboard.writeText(resultText);
            copyResultBtn.innerText = "Copied!";
            setTimeout(() => {
              copyResultBtn.innerText = "Copy Result";
            }, 2e3);
          } catch (error) {
            console.error("Failed to copy to clipboard:", error);
          }
        };
        actionsDiv.appendChild(copyResultBtn);
        infoDiv.appendChild(actionsDiv);
        container.appendChild(infoDiv);
        return container;
      }
      static getStaticToolIcon(action) {
        const iconMap = {
          "file_search": "\u{1F50D}",
          "file_read": "\u{1F4D6}",
          "file_write": "\u270D\uFE0F",
          "file_diff": "\u{1F504}",
          "file_move": "\u{1F4C1}",
          "file_rename": "\u{1F3F7}\uFE0F",
          "file_list": "\u{1F4CB}",
          "thought": "\u{1F9E0}"
        };
        return iconMap[action] || "\u{1F527}";
      }
      static getStaticToolDisplayName(action) {
        const nameMap = {
          "file_search": "File Search",
          "file_read": "File Read",
          "file_write": "File Write",
          "file_diff": "File Diff",
          "file_move": "File Move",
          "file_rename": "File Rename",
          "file_list": "File List",
          "thought": "Thought Process"
        };
        return nameMap[action] || action;
      }
      static formatStaticParameters(params) {
        const formatted = Object.entries(params).map(([key, value]) => `${key}: ${typeof value === "string" && value.length > 50 ? value.substring(0, 50) + "..." : JSON.stringify(value)}`).join(", ");
        return `<code>${formatted}</code>`;
      }
      static getStaticResultSummary(command, result) {
        if (!result.success) {
          return `<span class="tool-error">${result.error || "Unknown error"}</span>`;
        }
        const data = result.data;
        if (command.action === "file_write" && data) {
          const action = data.action || "modified";
          const filePath = data.filePath || "unknown file";
          const size = data.size ? ` (${data.size} bytes)` : "";
          if (action === "created") {
            return `<span class="tool-success">\u{1F4DD} Created file: <strong>${filePath}</strong>${size}</span>`;
          } else {
            return `<span class="tool-success">\u{1F4BE} Saved file: <strong>${filePath}</strong>${size}</span>`;
          }
        }
        if (command.action === "file_read" && data) {
          const filePath = data.filePath || command.parameters.path;
          const size = data.content ? ` (${data.content.length} chars)` : "";
          return `<span class="tool-success">\u{1F4D6} Read file: <strong>${filePath}</strong>${size}</span>`;
        }
        if (command.action === "file_search" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          return `<span class="tool-success">\u{1F50D} Found ${count} file${count !== 1 ? "s" : ""}</span>`;
        }
        if (command.action === "file_list" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          const path = data.path || command.parameters.path;
          return `<span class="tool-success">\u{1F4CB} Listed ${count} file${count !== 1 ? "s" : ""} in <strong>${path}</strong></span>`;
        }
        if (command.action === "file_move" && data) {
          const from = command.parameters.sourcePath;
          const to = command.parameters.destinationPath;
          return `<span class="tool-success">\u{1F4C1} Moved <strong>${from}</strong> \u2192 <strong>${to}</strong></span>`;
        }
        if (command.action === "file_rename" && data) {
          const oldName = command.parameters.path;
          const newName = command.parameters.newName;
          return `<span class="tool-success">\u{1F3F7}\uFE0F Renamed <strong>${oldName}</strong> \u2192 <strong>${newName}</strong></span>`;
        }
        if (command.action === "thought" && data) {
          const thought = data.thought || data.reasoning || "";
          return `<span class="tool-success">\u{1F9E0} ${thought}</span>`;
        }
        if (typeof data === "string") {
          return data;
        }
        if (Array.isArray(data)) {
          return `${data.length} items returned`;
        }
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data);
          return `Object with ${keys.length} properties`;
        }
        return "Success";
      }
      static getStaticDetailedResult(result) {
        if (!result.success) {
          return result.error || "Unknown error occurred";
        }
        if (result.data) {
          return typeof result.data === "string" ? result.data : JSON.stringify(result.data, null, 2);
        }
        return null;
      }
      /**
       * Render a tool execution block (array of toolResults) into a container element.
       * Used by both markdown and code block processors.
       */
      static renderToolExecutionBlock(toolData, container, onCopy) {
        container.innerHTML = "";
        container.className = "ai-tool-execution-container";
        if (toolData.toolResults && Array.isArray(toolData.toolResults)) {
          for (const toolResult of toolData.toolResults) {
            if (toolResult.command && toolResult.result) {
              const toolDisplay = _ToolRichDisplay.createNoteDisplay(
                toolResult.command,
                toolResult.result,
                {
                  onCopy: onCopy ? () => onCopy(toolResult.result) : void 0
                }
              );
              container.appendChild(toolDisplay);
            }
          }
        }
      }
    };
  }
});

// src/components/chat/MessageRenderer.ts
var MessageRenderer_exports = {};
__export(MessageRenderer_exports, {
  MessageRenderer: () => MessageRenderer
});
var import_obsidian14, MessageRenderer;
var init_MessageRenderer = __esm({
  "src/components/chat/MessageRenderer.ts"() {
    import_obsidian14 = require("obsidian");
    init_ToolRichDisplay();
    MessageRenderer = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * Update message container with enhanced reasoning and task status data
       */
      updateMessageWithEnhancedData(container, messageData, component) {
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[MessageRenderer] updateMessageWithEnhancedData called", { messageData });
        }
        const existingReasoning = container.querySelector(".reasoning-container");
        const existingTaskStatus = container.querySelector(".task-status-container");
        if (existingReasoning) existingReasoning.remove();
        if (existingTaskStatus) existingTaskStatus.remove();
        const messageContainer = container.querySelector(".message-container");
        if (!messageContainer) return;
        if (messageData.reasoning) {
          const reasoningEl = this.createReasoningSection(messageData.reasoning);
          messageContainer.insertBefore(reasoningEl, messageContainer.firstChild);
        }
        if (messageData.taskStatus) {
          const taskStatusEl = this.createTaskStatusSection(messageData.taskStatus);
          messageContainer.insertBefore(taskStatusEl, messageContainer.firstChild);
        }
        const contentEl = container.querySelector(".message-content");
        if (contentEl) {
          contentEl.empty();
          import_obsidian14.MarkdownRenderer.render(
            this.app,
            messageData.content,
            contentEl,
            "",
            component || new import_obsidian14.Component()
          ).catch((error) => {
            contentEl.textContent = messageData.content;
          });
        }
      }
      /**
       * Create reasoning section element
       */
      createReasoningSection(reasoning) {
        var _a2;
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[MessageRenderer] createReasoningSection called", { reasoning });
        }
        const reasoningContainer = document.createElement("div");
        reasoningContainer.className = "reasoning-container";
        const header = document.createElement("div");
        header.className = "reasoning-summary";
        const toggle = document.createElement("span");
        toggle.className = "reasoning-toggle";
        toggle.textContent = reasoning.isCollapsed ? "\u25B6" : "\u25BC";
        const headerText = document.createElement("span");
        const typeLabel = reasoning.type === "structured" ? "STRUCTURED REASONING" : "REASONING";
        const stepCount = ((_a2 = reasoning.steps) == null ? void 0 : _a2.length) || 0;
        headerText.innerHTML = `<strong>\u{1F9E0} ${typeLabel}</strong>`;
        if (stepCount > 0) {
          headerText.innerHTML += ` (${stepCount} steps)`;
        }
        headerText.innerHTML += ` - <em>Click to ${reasoning.isCollapsed ? "expand" : "collapse"}</em>`;
        header.appendChild(toggle);
        header.appendChild(headerText);
        const details = document.createElement("div");
        details.className = "reasoning-details";
        if (!reasoning.isCollapsed) {
          details.classList.add("expanded");
        }
        if (reasoning.type === "structured" && reasoning.steps) {
          if (reasoning.problem) {
            const problemDiv = document.createElement("div");
            problemDiv.className = "reasoning-problem";
            problemDiv.innerHTML = `<strong>Problem:</strong> ${reasoning.problem}`;
            details.appendChild(problemDiv);
          }
          reasoning.steps.forEach((step) => {
            const stepDiv = document.createElement("div");
            stepDiv.className = `reasoning-step ${step.category}`;
            stepDiv.innerHTML = `
                    <div class="step-header">
                        ${this.getStepEmoji(step.category)} Step ${step.step}: ${step.title.toUpperCase()}
                    </div>
                    <div class="step-confidence">
                        Confidence: ${step.confidence}/10
                    </div>
                    <div class="step-content">
                        ${step.content}
                    </div>
                `;
            details.appendChild(stepDiv);
          });
        } else if (reasoning.summary) {
          const summaryDiv = document.createElement("div");
          summaryDiv.className = "reasoning-completion";
          summaryDiv.textContent = reasoning.summary;
          details.appendChild(summaryDiv);
        }
        header.addEventListener("click", () => {
          const isExpanded = details.classList.contains("expanded");
          if (isExpanded) {
            details.classList.remove("expanded");
            toggle.textContent = "\u25B6";
            reasoning.isCollapsed = true;
          } else {
            details.classList.add("expanded");
            toggle.textContent = "\u25BC";
            reasoning.isCollapsed = false;
          }
        });
        reasoningContainer.appendChild(header);
        reasoningContainer.appendChild(details);
        return reasoningContainer;
      }
      /**
       * Create task status section element
       */
      createTaskStatusSection(taskStatus) {
        const statusContainer = document.createElement("div");
        statusContainer.className = "task-status-container";
        statusContainer.dataset.taskStatus = taskStatus.status;
        const statusText = this.getTaskStatusText(taskStatus);
        const statusIcon = this.getTaskStatusIcon(taskStatus.status);
        statusContainer.innerHTML = `
            <div class="task-status-header">
                ${statusIcon} <strong>${statusText}</strong>
            </div>
        `;
        if (taskStatus.toolExecutionCount > 0) {
          const toolInfo = document.createElement("div");
          toolInfo.className = "task-tool-info";
          toolInfo.textContent = `Tools used: ${taskStatus.toolExecutionCount}/${taskStatus.maxToolExecutions}`;
          statusContainer.appendChild(toolInfo);
        }
        return statusContainer;
      }
      /**
       * Get emoji for reasoning step categories
       */
      getStepEmoji(category) {
        switch (category) {
          case "analysis":
            return "\u{1F50D}";
          case "planning":
            return "\u{1F4CB}";
          case "problem-solving":
            return "\u{1F9E9}";
          case "reflection":
            return "\u{1F914}";
          case "conclusion":
            return "\u2705";
          case "reasoning":
            return "\u{1F9E0}";
          case "information":
            return "\u{1F4CA}";
          case "approach":
            return "\u{1F3AF}";
          case "evaluation":
            return "\u2696\uFE0F";
          case "synthesis":
            return "\u{1F517}";
          case "validation":
            return "\u2705";
          case "refinement":
            return "\u26A1";
          default:
            return "\u{1F4AD}";
        }
      }
      /**
       * Get task status text
       */
      getTaskStatusText(taskStatus) {
        switch (taskStatus.status) {
          case "idle":
            return "Task Ready";
          case "running":
            return "Task In Progress";
          case "stopped":
            return "Task Stopped";
          case "completed":
            return "Task Completed";
          case "limit_reached":
            return "Tool Limit Reached";
          case "waiting_for_user":
            return "Waiting for User Input";
          default:
            return "Unknown Status";
        }
      }
      /**
       * Get task status icon
       */
      getTaskStatusIcon(status) {
        switch (status) {
          case "idle":
            return "\u23F8\uFE0F";
          case "running":
            return "\u{1F504}";
          case "stopped":
            return "\u23F9\uFE0F";
          case "completed":
            return "\u2705";
          case "limit_reached":
            return "\u26A0\uFE0F";
          case "waiting_for_user":
            return "\u23F3";
          default:
            return "\u2753";
        }
      }
      /**
      * Render a complete message with tool displays if present
      */
      async renderMessage(message, container, component) {
        if (message.toolResults && message.toolResults.length > 0) {
          await this.renderMessageWithToolDisplays(message, container, component);
        } else {
          await this.renderRegularMessage(message, container, component);
        }
      }
      /**
      * Render message with embedded tool displays
      */
      async renderMessageWithToolDisplays(message, container, component) {
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) {
          console.error("No .message-content element found in container");
          return;
        }
        messageContent.empty();
        container.classList.add("has-rich-tools");
        if (message.toolResults && message.toolResults.length > 0) {
          for (const toolExecutionResult of message.toolResults) {
            const richDisplay = new ToolRichDisplay({
              command: toolExecutionResult.command,
              result: toolExecutionResult.result,
              onRerun: () => {
              },
              onCopy: async () => {
                const displayText = this.formatToolForCopy(toolExecutionResult.command, toolExecutionResult.result);
                try {
                  await navigator.clipboard.writeText(displayText);
                } catch (error) {
                  console.error("Failed to copy tool result:", error);
                }
              }
            });
            const toolWrapper = document.createElement("div");
            toolWrapper.className = "embedded-tool-display";
            toolWrapper.appendChild(richDisplay.getElement());
            messageContent.appendChild(toolWrapper);
          }
        }
        if (message.content && message.content.trim()) {
          const textDiv = document.createElement("div");
          textDiv.className = "message-text-part";
          await import_obsidian14.MarkdownRenderer.render(this.app, message.content, textDiv, "", component || new import_obsidian14.Component());
          messageContent.appendChild(textDiv);
        }
      }
      /**
       * Render regular message without tool displays
       */
      async renderRegularMessage(message, container, component) {
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) return;
        messageContent.empty();
        await import_obsidian14.MarkdownRenderer.render(this.app, message.content, messageContent, "", component || new import_obsidian14.Component());
      }
      /**
       * Parse message content to extract tool calls and text parts
       */
      parseMessageWithTools(content) {
        const parts = [];
        const toolCallRegex = /```json\s*\{[^}]*"action":\s*"([^"]+)"[^}]*\}[^`]*```/g;
        let lastIndex = 0;
        let match;
        while ((match = toolCallRegex.exec(content)) !== null) {
          if (match.index > lastIndex) {
            const textContent = content.slice(lastIndex, match.index).trim();
            if (textContent) {
              parts.push({ type: "text", content: textContent });
            }
          }
          try {
            const toolJson = match[0].replace(/```json\s*/, "").replace(/\s*```[\s\S]*?$/, "");
            const command = JSON.parse(toolJson);
            parts.push({ type: "tool", command });
          } catch (e) {
            parts.push({ type: "text", content: match[0] });
          }
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < content.length) {
          const remainingContent = content.slice(lastIndex).trim();
          if (remainingContent) {
            parts.push({ type: "text", content: remainingContent });
          }
        }
        if (parts.length === 0) {
          parts.push({ type: "text", content });
        }
        return parts;
      }
      /**
       * Compare tool parameters for matching
       */
      compareToolParams(params1, params2) {
        try {
          return JSON.stringify(params1) === JSON.stringify(params2);
        } catch (e) {
          return false;
        }
      }
      /**
      * Format tool execution for clipboard copy
      */
      formatToolForCopy(command, result) {
        const status = result.success ? "\u2705" : "\u274C";
        const statusText = result.success ? "SUCCESS" : "ERROR";
        let output = `${status} **${command.action}** ${statusText}`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          output += `

**Parameters:**
\`\`\`json
${JSON.stringify(command.parameters, null, 2)}
\`\`\``;
        }
        if (result.success) {
          output += `

**Result:**
\`\`\`json
${JSON.stringify(result.data, null, 2)}
\`\`\``;
        } else {
          output += `

**Error:**
${result.error}`;
        }
        return output;
      }
      /**
      * Get message content formatted for clipboard copy, including tool results
      */
      getMessageContentForCopy(messageData) {
        let content = messageData.content;
        if (messageData.toolResults && messageData.toolResults.length > 0) {
          content += "\n\n```ai-tool-execution\n";
          content += JSON.stringify({
            toolResults: messageData.toolResults,
            reasoning: messageData.reasoning,
            taskStatus: messageData.taskStatus
          }, null, 2);
          content += "\n```\n";
        }
        return content;
      }
      /**
      * Parse tool data from saved content that contains ai-tool-execution blocks
      */
      parseToolDataFromContent(content) {
        const toolDataRegex = /```ai-tool-execution\n([\s\S]*?)\n```/g;
        const match = toolDataRegex.exec(content);
        if (match) {
          try {
            return JSON.parse(match[1]);
          } catch (e) {
            console.error("Failed to parse tool data:", e);
          }
        }
        return null;
      }
      /**
       * Remove tool data blocks from content to get clean content for display
       */
      cleanContentFromToolData(content) {
        let cleanContent = content.replace(/```ai-tool-execution\n[\s\S]*?\n```\n?/g, "");
        cleanContent = cleanContent.replace(/\n\n\*\*Tool Execution:\*\*[\s\S]*?(?=\n\n\*\*Tool Execution:\*\*|\n\n[^*]|$)/g, "");
        return cleanContent.trim();
      }
    };
  }
});

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "node_modules/js-yaml/dist/js-yaml.mjs"() {
    isNothing_1 = isNothing;
    isObject_1 = isObject;
    toArray_1 = toArray;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// providers/base.ts
var ProviderErrorType, ProviderError, BaseProvider;
var init_base = __esm({
  "providers/base.ts"() {
    ProviderErrorType = /* @__PURE__ */ ((ProviderErrorType5) => {
      ProviderErrorType5["InvalidApiKey"] = "invalid_api_key";
      ProviderErrorType5["RateLimit"] = "rate_limit";
      ProviderErrorType5["InvalidRequest"] = "invalid_request";
      ProviderErrorType5["ServerError"] = "server_error";
      ProviderErrorType5["NetworkError"] = "network_error";
      return ProviderErrorType5;
    })(ProviderErrorType || {});
    ProviderError = class extends Error {
      constructor(type2, message, statusCode) {
        super(message);
        __publicField(this, "type");
        __publicField(this, "statusCode");
        this.type = type2;
        this.statusCode = statusCode;
        this.name = "ProviderError";
      }
    };
    BaseProvider = class {
      /**
       * Handle common HTTP errors
       */
      handleHttpError(error) {
        if (error instanceof Response) {
          const status2 = error.status;
          switch (status2) {
            case 401:
              throw new ProviderError(
                "invalid_api_key" /* InvalidApiKey */,
                "Invalid API key",
                status2
              );
            case 429:
              throw new ProviderError(
                "rate_limit" /* RateLimit */,
                "Rate limit exceeded",
                status2
              );
            case 400:
              throw new ProviderError(
                "invalid_request" /* InvalidRequest */,
                "Invalid request",
                status2
              );
            case 500:
            case 502:
            case 503:
            case 504:
              throw new ProviderError(
                "server_error" /* ServerError */,
                "Server error occurred",
                status2
              );
            default:
              throw new ProviderError(
                "server_error" /* ServerError */,
                `Unknown error occurred: ${status2}`,
                status2
              );
          }
        }
        if (!error.response) {
          throw new ProviderError(
            "network_error" /* NetworkError */,
            "Network error occurred"
          );
        }
        const status = error.response.status;
        switch (status) {
          case 401:
            throw new ProviderError(
              "invalid_api_key" /* InvalidApiKey */,
              "Invalid API key",
              status
            );
          case 429:
            throw new ProviderError(
              "rate_limit" /* RateLimit */,
              "Rate limit exceeded",
              status
            );
          case 400:
            throw new ProviderError(
              "invalid_request" /* InvalidRequest */,
              "Invalid request",
              status
            );
          case 500:
          case 502:
          case 503:
          case 504:
            throw new ProviderError(
              "server_error" /* ServerError */,
              "Server error occurred",
              status
            );
          default:
            throw new ProviderError(
              "server_error" /* ServerError */,
              `Unknown error occurred: ${status}`,
              status
            );
        }
      }
      /**
       * Format error message for connection test results
       */
      formatErrorMessage(error) {
        if (error instanceof ProviderError) {
          switch (error.type) {
            case "invalid_api_key" /* InvalidApiKey */:
              return "Invalid API key. Please check your credentials.";
            case "rate_limit" /* RateLimit */:
              return "Rate limit exceeded. Please try again later.";
            case "network_error" /* NetworkError */:
              return "Network error. Please check your internet connection.";
            default:
              return error.message;
          }
        }
        return error.message || "An unknown error occurred";
      }
      /**
       * Create a standard error response for connection tests
       */
      createErrorResponse(error) {
        return {
          success: false,
          message: this.formatErrorMessage(error)
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/@anthropic-ai/sdk/version.mjs"() {
    VERSION = "0.36.3";
  }
});

// node_modules/@anthropic-ai/sdk/_shims/registry.mjs
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto, kind, fetch2, Request2, Response2, Headers2, FormData2, Blob2, File2, ReadableStream2, getMultipartRequestOptions, getDefaultAgent, fileFromPath, isFsReadStream;
var init_registry = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/registry.mjs"() {
    auto = false;
    kind = void 0;
    fetch2 = void 0;
    Request2 = void 0;
    Response2 = void 0;
    Headers2 = void 0;
    FormData2 = void 0;
    Blob2 = void 0;
    File2 = void 0;
    ReadableStream2 = void 0;
    getMultipartRequestOptions = void 0;
    getDefaultAgent = void 0;
    fileFromPath = void 0;
    isFsReadStream = void 0;
  }
});

// node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs
var MultipartBody;
var init_MultipartBody = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs"() {
    MultipartBody = class {
      constructor(body) {
        this.body = body;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
var init_web_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs"() {
    init_MultipartBody();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs
var init_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs"() {
    init_web_runtime();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/index.mjs
var init_shims = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/index.mjs"() {
    init_registry();
    init_runtime();
    init_registry();
    if (!kind) setShims(getRuntime(), { auto: true });
  }
});

// node_modules/@anthropic-ai/sdk/error.mjs
var AnthropicError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm({
  "node_modules/@anthropic-ai/sdk/error.mjs"() {
    init_core();
    AnthropicError = class extends Error {
    };
    APIError = class _APIError extends AnthropicError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.request_id = headers == null ? void 0 : headers["request-id"];
        this.error = error;
      }
      static makeMessage(status, error, message) {
        const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error = errorResponse;
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message != null ? message : "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
    };
    AuthenticationError = class extends APIError {
    };
    PermissionDeniedError = class extends APIError {
    };
    NotFoundError = class extends APIError {
    };
    ConflictError = class extends APIError {
    };
    UnprocessableEntityError = class extends APIError {
    };
    RateLimitError = class extends APIError {
    };
    InternalServerError = class extends APIError {
    };
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var LineDecoder;
var init_line = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs"() {
    init_error();
    LineDecoder = class _LineDecoder {
      constructor() {
        this.buffer = [];
        this.trailingCR = false;
      }
      decode(chunk) {
        let text = this.decodeText(chunk);
        if (this.trailingCR) {
          text = "\r" + text;
          this.trailingCR = false;
        }
        if (text.endsWith("\r")) {
          this.trailingCR = true;
          text = text.slice(0, -1);
        }
        if (!text) {
          return [];
        }
        const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
        let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
        if (trailingNewline) {
          lines.pop();
        }
        if (lines.length === 1 && !trailingNewline) {
          this.buffer.push(lines[0]);
          return [];
        }
        if (this.buffer.length > 0) {
          lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
          this.buffer = [];
        }
        if (!trailingNewline) {
          this.buffer = [lines.pop() || ""];
        }
        return lines;
      }
      decodeText(bytes) {
        var _a2;
        if (bytes == null)
          return "";
        if (typeof bytes === "string")
          return bytes;
        if (typeof Buffer !== "undefined") {
          if (bytes instanceof Buffer) {
            return bytes.toString();
          }
          if (bytes instanceof Uint8Array) {
            return Buffer.from(bytes).toString();
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if (typeof TextDecoder !== "undefined") {
          if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
            (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
            return this.textDecoder.decode(bytes);
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
      }
      flush() {
        if (!this.buffer.length && !this.trailingCR) {
          return [];
        }
        const lines = [this.buffer.join("")];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
      }
    };
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  }
});

// node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_stream_utils = __esm({
  "node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
var Stream, SSEDecoder;
var init_streaming = __esm({
  "node_modules/@anthropic-ai/sdk/streaming.mjs"() {
    init_shims();
    init_error();
    init_line();
    init_stream_utils();
    init_core();
    init_error();
    Stream = class _Stream {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      static fromSSEResponse(response, controller) {
        let consumed = false;
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (sse.event === "completion") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "ping") {
                continue;
              }
              if (sse.event === "error") {
                throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
              }
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = ReadableStreamToAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller),
          new _Stream(() => teeIterator(right), this.controller)
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self = this;
        let iter;
        const encoder = new TextEncoder();
        return new ReadableStream2({
          async start() {
            iter = self[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encoder.encode(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            var _a2;
            await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/uploads.mjs
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type2 = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type2 === "string") {
      options = { ...options, type: type2 };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var isResponseLike, isFileLike, isBlobLike, getStringFromMaybeBuffer, isAsyncIterableIterator, isMultipartBody;
var init_uploads = __esm({
  "node_modules/@anthropic-ai/sdk/uploads.mjs"() {
    init_shims();
    init_shims();
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    getStringFromMaybeBuffer = (x) => {
      if (typeof x === "string")
        return x;
      if (typeof Buffer !== "undefined" && x instanceof Buffer)
        return String(x);
      return void 0;
    };
    isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  }
});

// node_modules/@anthropic-ai/sdk/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return _addRequestID(json2, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    console.log(`Anthropic:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractPage_client, APIPromise, APIClient, AbstractPage, PagePromise, createResponseHeaders, requestOptionsKeys, isRequestOptions, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, safeJSON, startsWithSchemeRegexp, isAbsoluteURL, sleep, validatePositiveInteger, castToError, readEnv, uuid4, isRunningInBrowser, isHeadersProtocol, getHeader;
var init_core = __esm({
  "node_modules/@anthropic-ai/sdk/core.mjs"() {
    init_version();
    init_streaming();
    init_error();
    init_shims();
    init_uploads();
    __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    APIPromise = class _APIPromise extends Promise {
      constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get("request-id") };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    APIClient = class {
      constructor({
        baseURL,
        maxRetries = 2,
        timeout = 6e5,
        // 10 minutes
        httpAgent,
        fetch: overriddenFetch
      }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
        this.timeout = validatePositiveInteger("timeout", timeout);
        this.httpAgent = httpAgent;
        this.fetch = overriddenFetch != null ? overriddenFetch : fetch2;
      }
      authHeaders(opts) {
        return {};
      }
      /**
       * Override this to add your own default headers, for example:
       *
       *  {
       *    ...super.defaultHeaders(),
       *    Authorization: 'Bearer 123',
       *  }
       */
      defaultHeaders(opts) {
        return {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": this.getUserAgent(),
          ...getPlatformHeaders(),
          ...this.authHeaders(opts)
        };
      }
      /**
       * Override this to add your own headers validation:
       */
      validateHeaders(headers, customHeaders) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      get(path, opts) {
        return this.methodRequest("get", path, opts);
      }
      post(path, opts) {
        return this.methodRequest("post", path, opts);
      }
      patch(path, opts) {
        return this.methodRequest("patch", path, opts);
      }
      put(path, opts) {
        return this.methodRequest("put", path, opts);
      }
      delete(path, opts) {
        return this.methodRequest("delete", path, opts);
      }
      methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then(async (opts2) => {
          const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
          return { method, path, ...opts2, body };
        }));
      }
      getAPIList(path, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path, ...opts });
      }
      calculateContentLength(body) {
        if (typeof body === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.byteLength(body, "utf8").toString();
          }
          if (typeof TextEncoder !== "undefined") {
            const encoder = new TextEncoder();
            const encoded = encoder.encode(body);
            return encoded.length.toString();
          }
        } else if (ArrayBuffer.isView(body)) {
          return body.byteLength.toString();
        }
        return null;
      }
      buildRequest(options, { retryCount = 0 } = {}) {
        var _a2, _b, _c, _d, _e, _f;
        const { method, path, query, headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path, query);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
        const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
        const minAgentTimeout = timeout + 1e3;
        if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
          httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
        const req = {
          method,
          ...body && { body },
          headers: reqHeaders,
          ...httpAgent && { agent: httpAgent },
          // @ts-ignore node-fetch uses a custom AbortSignal type that is
          // not compatible with standard web types
          signal: (_f = options.signal) != null ? _f : null
        };
        return { req, url, timeout };
      }
      buildHeaders({ options, headers, contentLength, retryCount }) {
        const reqHeaders = {};
        if (contentLength) {
          reqHeaders["content-length"] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        if (isMultipartBody(options.body) && kind !== "node") {
          delete reqHeaders["content-type"];
        }
        if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
          reqHeaders["x-stainless-retry-count"] = String(retryCount);
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      parseHeaders(headers) {
        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
      }
      async makeRequest(optionsInput, retriesRemaining) {
        var _a2, _b, _c;
        const options = await optionsInput;
        const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
        await this.prepareRequest(req, { url, options });
        debug("request", url, options, req.headers);
        if ((_b = options.signal) == null ? void 0 : _b.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
          if ((_c = options.signal) == null ? void 0 : _c.aborted) {
            throw new APIUserAbortError();
          }
          if (retriesRemaining) {
            return this.retryRequest(options, retriesRemaining);
          }
          if (response.name === "AbortError") {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
          if (retriesRemaining && this.shouldRetry(response)) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
            return this.retryRequest(options, retriesRemaining, responseHeaders);
          }
          const errText = await response.text().catch((e) => castToError(e).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
          debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
          const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
          throw err;
        }
        return { response, options, controller };
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page2);
      }
      buildURL(path, query) {
        const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      stringifyQuery(query) {
        return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key)}=`;
          }
          throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const { signal, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const fetchOptions = {
          signal: controller.signal,
          ...options
        };
        if (fetchOptions.method) {
          fetchOptions.method = fetchOptions.method.toUpperCase();
        }
        return (
          // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
          this.fetch.call(void 0, url, fetchOptions).finally(() => {
            clearTimeout(timeout);
          })
        );
      }
      shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, responseHeaders) {
        var _a2;
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
    };
    AbstractPage = class {
      constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageInfo() != null;
      }
      async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
          throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        const nextOptions = { ...this.options };
        if ("params" in nextInfo && typeof nextOptions.query === "object") {
          nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
        } else if ("url" in nextInfo) {
          const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
          for (const [key, value] of params) {
            nextInfo.url.searchParams.set(key, value);
          }
          nextOptions.query = void 0;
          nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client, request, Page2) {
        super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    createResponseHeaders = (headers) => {
      return new Proxy(Object.fromEntries(
        // @ts-ignore
        headers.entries()
      ), {
        get(target, name) {
          const key = name.toString();
          return target[key.toLowerCase()] || target[key];
        }
      });
    };
    requestOptionsKeys = {
      method: true,
      path: true,
      query: true,
      body: true,
      headers: true,
      maxRetries: true,
      stream: true,
      timeout: true,
      httpAgent: true,
      signal: true,
      idempotencyKey: true,
      __binaryRequest: true,
      __binaryResponse: true,
      __streamClass: true
    };
    isRequestOptions = (obj) => {
      return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
    };
    getPlatformProperties = () => {
      var _a2, _b;
      if (typeof Deno !== "undefined" && Deno.build != null) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(process.platform),
          "X-Stainless-Arch": normalizeArch(process.arch),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
    };
    safeJSON = (text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    };
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    validatePositiveInteger = (name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new AnthropicError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new AnthropicError(`${name} must be a positive integer`);
      }
      return n;
    };
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          return new Error(JSON.stringify(err));
        } catch (e) {
        }
      }
      return new Error(String(err));
    };
    readEnv = (env) => {
      var _a2, _b, _c, _d, _e, _f;
      if (typeof process !== "undefined") {
        return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
      }
      if (typeof Deno !== "undefined") {
        return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
      }
      return void 0;
    };
    uuid4 = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
    isHeadersProtocol = (headers) => {
      return typeof (headers == null ? void 0 : headers.get) === "function";
    };
    getHeader = (headers, header) => {
      var _a2;
      const lowerCasedHeader = header.toLowerCase();
      if (isHeadersProtocol(headers)) {
        const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
          const value = headers.get(key);
          if (value) {
            return value;
          }
        }
      }
      for (const [key, value] of Object.entries(headers)) {
        if (key.toLowerCase() === lowerCasedHeader) {
          if (Array.isArray(value)) {
            if (value.length <= 1)
              return value[0];
            console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
            return value[0];
          }
          return value;
        }
      }
      return void 0;
    };
  }
});

// node_modules/@anthropic-ai/sdk/pagination.mjs
var Page;
var init_pagination = __esm({
  "node_modules/@anthropic-ai/sdk/pagination.mjs"() {
    init_core();
    Page = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.first_id = body.first_id || null;
        this.last_id = body.last_id || null;
      }
      getPaginatedItems() {
        var _a2;
        return (_a2 = this.data) != null ? _a2 : [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        var _a2;
        if ((_a2 = this.options.query) == null ? void 0 : _a2["before_id"]) {
          const firstId = this.first_id;
          if (!firstId) {
            return null;
          }
          return {
            params: {
              before_id: firstId
            }
          };
        }
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          params: {
            after_id: cursor
          }
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/shared.mjs
var init_shared = __esm({
  "node_modules/@anthropic-ai/sdk/resources/shared.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/@anthropic-ai/sdk/resource.mjs"() {
    APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models, BetaModelInfosPage;
var init_models = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}?beta=true`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models?beta=true", BetaModelInfosPage, { query, ...options });
      }
    };
    BetaModelInfosPage = class extends Page {
    };
    Models.BetaModelInfosPage = BetaModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder;
var init_jsonl = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs"() {
    init_error();
    init_stream_utils();
    init_line();
    JSONLDecoder = class _JSONLDecoder {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      async *decoder() {
        const lineDecoder = new LineDecoder();
        for await (const chunk of this.iterator) {
          for (const line of lineDecoder.decode(chunk)) {
            yield JSON.parse(line);
          }
        }
        for (const line of lineDecoder.flush()) {
          yield JSON.parse(line);
        }
      }
      [Symbol.asyncIterator]() {
        return this.decoder();
      }
      static fromResponse(response, controller) {
        if (!response.body) {
          controller.abort();
          throw new AnthropicError(`Attempted to iterate over a response with no body`);
        }
        return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches, BetaMessageBatchesPage;
var init_batches = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/batches?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      retrieve(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.retrieve(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { betas, ...query } = params;
        return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
          query,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      delete(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      cancel(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.cancel(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      async results(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.results(messageBatchId, {}, params);
        }
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        const { betas } = params;
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    BetaMessageBatchesPage = class extends Page {
    };
    Batches.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize, strip, unstrip, generate, partialParse;
var init_parser = __esm({
  "node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs"() {
    tokenize = (input) => {
      let current = 0;
      let tokens = [];
      while (current < input.length) {
        let char = input[current];
        if (char === "\\") {
          current++;
          continue;
        }
        if (char === "{") {
          tokens.push({
            type: "brace",
            value: "{"
          });
          current++;
          continue;
        }
        if (char === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
          current++;
          continue;
        }
        if (char === "[") {
          tokens.push({
            type: "paren",
            value: "["
          });
          current++;
          continue;
        }
        if (char === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
          current++;
          continue;
        }
        if (char === ":") {
          tokens.push({
            type: "separator",
            value: ":"
          });
          current++;
          continue;
        }
        if (char === ",") {
          tokens.push({
            type: "delimiter",
            value: ","
          });
          current++;
          continue;
        }
        if (char === '"') {
          let value = "";
          let danglingQuote = false;
          char = input[++current];
          while (char !== '"') {
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            if (char === "\\") {
              current++;
              if (current === input.length) {
                danglingQuote = true;
                break;
              }
              value += char + input[current];
              char = input[++current];
            } else {
              value += char;
              char = input[++current];
            }
          }
          char = input[++current];
          if (!danglingQuote) {
            tokens.push({
              type: "string",
              value
            });
          }
          continue;
        }
        let WHITESPACE = /\s/;
        if (char && WHITESPACE.test(char)) {
          current++;
          continue;
        }
        let NUMBERS = /[0-9]/;
        if (char && NUMBERS.test(char) || char === "-" || char === ".") {
          let value = "";
          if (char === "-") {
            value += char;
            char = input[++current];
          }
          while (char && NUMBERS.test(char) || char === ".") {
            value += char;
            char = input[++current];
          }
          tokens.push({
            type: "number",
            value
          });
          continue;
        }
        let LETTERS = /[a-z]/i;
        if (char && LETTERS.test(char)) {
          let value = "";
          while (char && LETTERS.test(char)) {
            if (current === input.length) {
              break;
            }
            value += char;
            char = input[++current];
          }
          if (value == "true" || value == "false" || value === "null") {
            tokens.push({
              type: "name",
              value
            });
          } else {
            current++;
            continue;
          }
          continue;
        }
        current++;
      }
      return tokens;
    };
    strip = (tokens) => {
      if (tokens.length === 0) {
        return tokens;
      }
      let lastToken = tokens[tokens.length - 1];
      switch (lastToken.type) {
        case "separator":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
        case "number":
          let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
          if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
        case "string":
          let tokenBeforeTheLastToken = tokens[tokens.length - 2];
          if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
          break;
        case "delimiter":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
      }
      return tokens;
    };
    unstrip = (tokens) => {
      let tail = [];
      tokens.map((token) => {
        if (token.type === "brace") {
          if (token.value === "{") {
            tail.push("}");
          } else {
            tail.splice(tail.lastIndexOf("}"), 1);
          }
        }
        if (token.type === "paren") {
          if (token.value === "[") {
            tail.push("]");
          } else {
            tail.splice(tail.lastIndexOf("]"), 1);
          }
        }
      });
      if (tail.length > 0) {
        tail.reverse().map((item) => {
          if (item === "}") {
            tokens.push({
              type: "brace",
              value: "}"
            });
          } else if (item === "]") {
            tokens.push({
              type: "paren",
              value: "]"
            });
          }
        });
      }
      return tokens;
    };
    generate = (tokens) => {
      let output = "";
      tokens.map((token) => {
        switch (token.type) {
          case "string":
            output += '"' + token.value + '"';
            break;
          default:
            output += token.value;
            break;
        }
      });
      return output;
    };
    partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  }
});

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
function checkNever(x) {
}
var __classPrivateFieldSet2, __classPrivateFieldGet2, _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage, JSON_BUF_PROPERTY, BetaMessageStream;
var init_BetaMessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY = "__json_buf";
    BetaMessageStream = class _BetaMessageStream {
      constructor() {
        _BetaMessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _BetaMessageStream_connectedPromise.set(this, void 0);
        _BetaMessageStream_resolveConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_rejectConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_endPromise.set(this, void 0);
        _BetaMessageStream_resolveEndPromise.set(this, () => {
        });
        _BetaMessageStream_rejectEndPromise.set(this, () => {
        });
        _BetaMessageStream_listeners.set(this, {});
        _BetaMessageStream_ended.set(this, false);
        _BetaMessageStream_errored.set(this, false);
        _BetaMessageStream_aborted.set(this, false);
        _BetaMessageStream_catchingPromiseCreated.set(this, false);
        _BetaMessageStream_response.set(this, void 0);
        _BetaMessageStream_request_id.set(this, void 0);
        _BetaMessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet2(this, _BetaMessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet2(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _BetaMessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _BetaMessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_response, response, "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet2(this, _BetaMessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet2(this, _BetaMessageStream_ended, true, "f");
          __classPrivateFieldGet2(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
      }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS, Messages;
var init_messages = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs"() {
    init_resource();
    init_batches();
    init_batches();
    init_BetaMessageStream();
    DEPRECATED_MODELS = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches(this._client);
      }
      create(params, options) {
        var _a2, _b;
        const { betas, ...body } = params;
        if (body.model in DEPRECATED_MODELS) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages?beta=true", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          headers: {
            ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0,
            ...options == null ? void 0 : options.headers
          },
          stream: (_b = params.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return BetaMessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/count_tokens?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "token-counting-2024-11-01"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
    };
    Messages.Batches = Batches;
    Messages.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs"() {
    init_resource();
    init_models();
    init_models();
    init_messages();
    init_messages();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.models = new Models(this._client);
        this.messages = new Messages(this._client);
      }
    };
    Beta.Models = Models;
    Beta.BetaModelInfosPage = BetaModelInfosPage;
    Beta.Messages = Messages;
  }
});

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions;
var init_completions = __esm({
  "node_modules/@anthropic-ai/sdk/resources/completions.mjs"() {
    init_resource();
    Completions = class extends APIResource {
      create(body, options) {
        var _a2, _b;
        return this._client.post("/v1/complete", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2, MessageBatchesPage;
var init_batches2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches2 = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(body, options) {
        return this._client.post("/v1/messages/batches", { body, ...options });
      }
      /**
       * This endpoint is idempotent and can be used to poll for Message Batch
       * completion. To access the results of a Message Batch, make a request to the
       * `results_url` field in the response.
       */
      retrieve(messageBatchId, options) {
        return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/messages/batches", MessageBatchesPage, { query, ...options });
      }
      /**
       * Delete a Message Batch.
       *
       * Message Batches can only be deleted once they've finished processing. If you'd
       * like to delete an in-progress batch, you must first cancel it.
       */
      delete(messageBatchId, options) {
        return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);
      }
      /**
       * Batches may be canceled any time before processing ends. Once cancellation is
       * initiated, the batch enters a `canceling` state, at which time the system may
       * complete any in-progress, non-interruptible requests before finalizing
       * cancellation.
       *
       * The number of canceled requests is specified in `request_counts`. To determine
       * which requests were canceled, check the individual results within the batch.
       * Note that cancellation may not result in any canceled requests if they were
       * non-interruptible.
       */
      cancel(messageBatchId, options) {
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);
      }
      /**
       * Streams the results of a Message Batch as a `.jsonl` file.
       *
       * Each line in the file is a JSON object containing the result of a single request
       * in the Message Batch. Results are not guaranteed to be in the same order as
       * requests. Use the `custom_id` field to match results to requests.
       */
      async results(messageBatchId, options) {
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    MessageBatchesPage = class extends Page {
    };
    Batches2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
function checkNever2(x) {
}
var __classPrivateFieldSet3, __classPrivateFieldGet3, _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage, JSON_BUF_PROPERTY2, MessageStream;
var init_MessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY2 = "__json_buf";
    MessageStream = class _MessageStream {
      constructor() {
        _MessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _MessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _MessageStream_connectedPromise.set(this, void 0);
        _MessageStream_resolveConnectedPromise.set(this, () => {
        });
        _MessageStream_rejectConnectedPromise.set(this, () => {
        });
        _MessageStream_endPromise.set(this, void 0);
        _MessageStream_resolveEndPromise.set(this, () => {
        });
        _MessageStream_rejectEndPromise.set(this, () => {
        });
        _MessageStream_listeners.set(this, {});
        _MessageStream_ended.set(this, false);
        _MessageStream_errored.set(this, false);
        _MessageStream_aborted.set(this, false);
        _MessageStream_catchingPromiseCreated.set(this, false);
        _MessageStream_response.set(this, void 0);
        _MessageStream_request_id.set(this, void 0);
        _MessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet3(this, _MessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet3(this, _MessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet3(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet3(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet3(this, _MessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet3(this, _MessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet3(this, _MessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _MessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _MessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet3(this, _MessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_response, response, "f");
        __classPrivateFieldSet3(this, _MessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet3(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet3(this, _MessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet3(this, _MessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet3(this, _MessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet3(this, _MessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet3(this, _MessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet3(this, _MessageStream_ended, true, "f");
          __classPrivateFieldGet3(this, _MessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
      }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY2, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2, DEPRECATED_MODELS2;
var init_messages2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs"() {
    init_resource();
    init_batches2();
    init_batches2();
    init_MessageStream();
    Messages2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches2(this._client);
      }
      create(body, options) {
        var _a2, _b;
        if (body.model in DEPRECATED_MODELS2) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return MessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(body, options) {
        return this._client.post("/v1/messages/count_tokens", { body, ...options });
      }
    };
    DEPRECATED_MODELS2 = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages2.Batches = Batches2;
    Messages2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2, ModelInfosPage;
var init_models2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models2 = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models", ModelInfosPage, { query, ...options });
      }
    };
    ModelInfosPage = class extends Page {
    };
    Models2.ModelInfosPage = ModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/index.mjs
var init_resources = __esm({
  "node_modules/@anthropic-ai/sdk/resources/index.mjs"() {
    init_shared();
    init_beta();
    init_completions();
    init_messages2();
    init_models2();
  }
});

// node_modules/@anthropic-ai/sdk/index.mjs
var _a, Anthropic, HUMAN_PROMPT, AI_PROMPT, sdk_default;
var init_sdk = __esm({
  "node_modules/@anthropic-ai/sdk/index.mjs"() {
    init_core();
    init_error();
    init_uploads();
    init_resources();
    init_completions();
    init_models2();
    init_beta();
    init_messages2();
    Anthropic = class extends APIClient {
      /**
       * API Client for interfacing with the Anthropic API.
       *
       * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
       * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
       * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = ((_a2) => (_a2 = readEnv("ANTHROPIC_API_KEY")) != null ? _a2 : null)(), authToken = ((_b) => (_b = readEnv("ANTHROPIC_AUTH_TOKEN")) != null ? _b : null)(), ...opts } = {}) {
        var _a3;
        const options = {
          apiKey,
          authToken,
          ...opts,
          baseURL: baseURL || `https://api.anthropic.com`
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
        }
        super({
          baseURL: options.baseURL,
          timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
          httpAgent: options.httpAgent,
          maxRetries: options.maxRetries,
          fetch: options.fetch
        });
        this.completions = new Completions(this);
        this.messages = new Messages2(this);
        this.models = new Models2(this);
        this.beta = new Beta(this);
        this._options = options;
        this.apiKey = apiKey;
        this.authToken = authToken;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(opts) {
        return {
          ...super.defaultHeaders(opts),
          ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
          "anthropic-version": "2023-06-01",
          ...this._options.defaultHeaders
        };
      }
      validateHeaders(headers, customHeaders) {
        if (this.apiKey && headers["x-api-key"]) {
          return;
        }
        if (customHeaders["x-api-key"] === null) {
          return;
        }
        if (this.authToken && headers["authorization"]) {
          return;
        }
        if (customHeaders["authorization"] === null) {
          return;
        }
        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
      }
      authHeaders(opts) {
        const apiKeyAuth = this.apiKeyAuth(opts);
        const bearerAuth = this.bearerAuth(opts);
        if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
          return apiKeyAuth;
        }
        if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
          return bearerAuth;
        }
        return {};
      }
      apiKeyAuth(opts) {
        if (this.apiKey == null) {
          return {};
        }
        return { "X-Api-Key": this.apiKey };
      }
      bearerAuth(opts) {
        if (this.authToken == null) {
          return {};
        }
        return { Authorization: `Bearer ${this.authToken}` };
      }
    };
    _a = Anthropic;
    Anthropic.Anthropic = _a;
    Anthropic.HUMAN_PROMPT = "\n\nHuman:";
    Anthropic.AI_PROMPT = "\n\nAssistant:";
    Anthropic.DEFAULT_TIMEOUT = 6e5;
    Anthropic.AnthropicError = AnthropicError;
    Anthropic.APIError = APIError;
    Anthropic.APIConnectionError = APIConnectionError;
    Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
    Anthropic.APIUserAbortError = APIUserAbortError;
    Anthropic.NotFoundError = NotFoundError;
    Anthropic.ConflictError = ConflictError;
    Anthropic.RateLimitError = RateLimitError;
    Anthropic.BadRequestError = BadRequestError;
    Anthropic.AuthenticationError = AuthenticationError;
    Anthropic.InternalServerError = InternalServerError;
    Anthropic.PermissionDeniedError = PermissionDeniedError;
    Anthropic.UnprocessableEntityError = UnprocessableEntityError;
    Anthropic.toFile = toFile;
    Anthropic.fileFromPath = fileFromPath;
    Anthropic.Completions = Completions;
    Anthropic.Messages = Messages2;
    Anthropic.Models = Models2;
    Anthropic.ModelInfosPage = ModelInfosPage;
    Anthropic.Beta = Beta;
    ({ HUMAN_PROMPT, AI_PROMPT } = Anthropic);
    sdk_default = Anthropic;
  }
});

// providers/anthropic.ts
function estimateTokenCount(messages) {
  const CHARS_PER_TOKEN = 4;
  const totalChars = messages.reduce((total, msg) => {
    return total + msg.content.length;
  }, 0);
  return Math.ceil(totalChars / CHARS_PER_TOKEN);
}
var MODEL_CONTEXT_WINDOWS, MODEL_OUTPUT_TOKEN_LIMITS, AnthropicProvider;
var init_anthropic = __esm({
  "providers/anthropic.ts"() {
    init_base();
    init_sdk();
    MODEL_CONTEXT_WINDOWS = {
      "claude-3-opus-20240229": 2e5,
      "claude-3-sonnet-20240229": 2e5,
      "claude-3-haiku-20240307": 2e5,
      "claude-3-7-sonnet-20250219": 2e5,
      "claude-3-5-sonnet-20241022": 2e5,
      "claude-3-5-sonnet-20240620": 2e5,
      "claude-3-5-haiku-20241022": 2e5
    };
    MODEL_OUTPUT_TOKEN_LIMITS = {
      "claude-3-7-sonnet-20250219": 64e3,
      "claude-3-5-sonnet-20241022": 8192,
      "claude-3-5-sonnet-20240620": 8192,
      "claude-3-5-haiku-20241022": 8192,
      "claude-3-opus-20240229": 4096,
      "claude-3-sonnet-20240229": 8192,
      // fallback for older sonnet
      "claude-3-haiku-20240307": 4096
      // fallback for older haiku
    };
    AnthropicProvider = class extends BaseProvider {
      constructor(apiKey, model = "claude-3-sonnet-20240229") {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl", "https://api.anthropic.com/v1");
        __publicField(this, "model");
        __publicField(this, "client");
        this.apiKey = apiKey;
        this.model = model;
        this.client = new sdk_default({
          apiKey: this.apiKey,
          dangerouslyAllowBrowser: true
          // Required for browser environments
        });
      }
      /**
       * Get a completion from Anthropic
       * 
       * Sends the conversation to Anthropic and streams back the response
       * using the official SDK's streaming support.
       * 
       * Automatically adjusts max_tokens if the request would exceed the model's context window.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d;
        try {
          const contextWindow = (_a2 = MODEL_CONTEXT_WINDOWS[this.model]) != null ? _a2 : 2e5;
          const outputTokenLimit = MODEL_OUTPUT_TOKEN_LIMITS[this.model];
          const inputTokens = estimateTokenCount(messages);
          let maxTokens = (_b = options.maxTokens) != null ? _b : 1e3;
          if (inputTokens + maxTokens > contextWindow) {
            const adjustedMaxTokens = contextWindow - inputTokens;
            if (adjustedMaxTokens <= 0) {
              throw new ProviderError(
                "invalid_request" /* InvalidRequest */,
                `Input is too long for ${this.model}'s context window. Estimated input tokens: ${inputTokens}, context window: ${contextWindow}`
              );
            }
            console.log(
              `Adjusting max_tokens from ${maxTokens} to ${adjustedMaxTokens} to fit within ${this.model}'s context window`
            );
            maxTokens = adjustedMaxTokens;
          }
          if (outputTokenLimit && maxTokens > outputTokenLimit) {
            console.log(
              `Capping max_tokens from ${maxTokens} to model output limit ${outputTokenLimit} for ${this.model}`
            );
            maxTokens = outputTokenLimit;
          }
          const { systemPrompt, anthropicMessages } = this.formatMessages(messages);
          const requestParams = {
            model: this.model,
            messages: anthropicMessages,
            temperature: (_c = options.temperature) != null ? _c : 0.7,
            max_tokens: maxTokens,
            stream: true
          };
          if (systemPrompt) {
            requestParams.system = systemPrompt;
          }
          const stream = await this.client.messages.create(requestParams);
          try {
            if (stream && typeof stream === "object") {
              if (stream.on && typeof stream.on === "function") {
                await new Promise((resolve, reject) => {
                  stream.on("content_block_delta", (chunk) => {
                    var _a3;
                    if (((_a3 = chunk.delta) == null ? void 0 : _a3.type) === "text_delta" && options.streamCallback) {
                      options.streamCallback(chunk.delta.text);
                    }
                  });
                  stream.on("end", resolve);
                  stream.on("error", reject);
                });
              } else if (Symbol.asyncIterator in stream) {
                for await (const chunk of stream) {
                  if (chunk.type === "content_block_delta" && ((_d = chunk.delta) == null ? void 0 : _d.type) === "text_delta" && options.streamCallback) {
                    options.streamCallback(chunk.delta.text);
                  }
                }
              } else if (options.streamCallback) {
                console.warn("Anthropic response is not a stream, handling as regular response");
                if ("content" in stream && typeof stream.content === "string") {
                  options.streamCallback(stream.content);
                }
              }
            }
          } catch (streamError) {
            console.error("Error processing Anthropic stream:", streamError);
            throw streamError;
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Anthropic stream was aborted");
          } else {
            console.error("Error calling Anthropic:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Anthropic models
       * 
       * Returns the list of supported Claude models.
       * Note: Anthropic doesn't have a models endpoint, so we return known models.
       * This list is based on the models defined in MODEL_CONTEXT_WINDOWS.
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          return Object.keys(MODEL_CONTEXT_WINDOWS);
        } catch (error) {
          console.error("Error getting Anthropic models:", error);
          throw error;
        }
      }
      /**
       * Format messages for Anthropic API
       * 
       * Converts from the plugin's Message format to Anthropic's expected format.
       * Handles system messages specially as Anthropic has a different format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages and system prompt for Anthropic API
       */
      formatMessages(messages) {
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        const systemPrompt = systemMessages.length > 0 ? systemMessages.map((msg) => msg.content).join("\n\n") : void 0;
        const anthropicMessages = nonSystemMessages.map((msg) => {
          const role = msg.role === "user" || msg.role === "assistant" ? msg.role : "user";
          return { role, content: msg.content };
        });
        return { systemPrompt, anthropicMessages };
      }
      /**
       * Test connection to Anthropic
       * 
       * Verifies the API key works by attempting a simple completion.
       * 
       * @returns Test results including success/failure
       */
      async testConnection() {
        try {
          await this.client.messages.create({
            model: this.model,
            messages: [{ role: "user", content: "Hi" }],
            max_tokens: 1
          });
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: "Successfully connected to Anthropic!",
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/openai.ts
var OpenAIProvider;
var init_openai = __esm({
  "providers/openai.ts"() {
    init_base();
    OpenAIProvider = class extends BaseProvider {
      constructor(apiKey, model = "gpt-4", baseUrl) {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.apiKey = apiKey;
        this.model = model;
        this.baseUrl = baseUrl || "https://api.openai.com/v1";
      }
      /**
       * Get a completion from OpenAI
       * 
       * Sends the conversation to OpenAI and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e, _f;
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: this.model,
              messages,
              temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
              max_tokens: (_b = options.maxTokens) != null ? _b : 1e3,
              stream: true
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const reader = (_d = response.body) == null ? void 0 : _d.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await (reader == null ? void 0 : reader.read()) || { done: true, value: void 0 };
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.startsWith("data: ") && line !== "data: [DONE]") {
                try {
                  const data = JSON.parse(line.slice(6));
                  const content = (_f = (_e = data.choices[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.content;
                  if (content && options.streamCallback) {
                    options.streamCallback(content);
                  }
                } catch (e) {
                  console.warn("Error parsing OpenAI response chunk:", e);
                }
              }
            }
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("OpenAI stream was aborted");
          } else {
            console.error("Error calling OpenAI:", error);
            throw error;
          }
        }
      }
      /**
       * Get available OpenAI models
       * 
       * Fetches the list of models from OpenAI's API.
       * Filters to only include chat models (GPT-3.5, GPT-4, etc.)
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          const response = await fetch(`${this.baseUrl}/models`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            }
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          return data.data.map((model) => model.id).filter((id) => id.startsWith("gpt-"));
        } catch (error) {
          console.error("Error fetching OpenAI models:", error);
          throw error;
        }
      }
      /**
       * Test connection to OpenAI
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to OpenAI! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/gemini.ts
var GeminiProvider;
var init_gemini = __esm({
  "providers/gemini.ts"() {
    init_base();
    GeminiProvider = class extends BaseProvider {
      constructor(apiKey, model = "gemini-2.0-flash", apiVersion = "v1") {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "apiVersion");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.apiKey = apiKey;
        this.model = model;
        this.apiVersion = apiVersion;
        this.baseUrl = `https://generativelanguage.googleapis.com/${this.apiVersion}`;
      }
      /**
       * Determines the correct API version for a given model name.
       * Uses v1beta for preview/experimental/beta models, otherwise v1.
       */
      getBaseUrlForModel(model) {
        if (/preview|exp|experimental|beta/i.test(model)) {
          return "https://generativelanguage.googleapis.com/v1beta";
        }
        return "https://generativelanguage.googleapis.com/v1";
      }
      /**
       * Get a completion from Google Gemini
       * 
       * Sends the conversation to Gemini and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        try {
          const formattedMessages = this.formatMessages(messages);
          const baseUrl = this.getBaseUrlForModel(this.model);
          const url = `${baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              contents: formattedMessages,
              generationConfig: {
                temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
                maxOutputTokens: (_b = options.maxTokens) != null ? _b : 1e3
              }
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          console.log("Gemini response:", JSON.stringify(data));
          const text = (_h = (_g = (_f = (_e = (_d = data.candidates) == null ? void 0 : _d[0]) == null ? void 0 : _e.content) == null ? void 0 : _f.parts) == null ? void 0 : _g[0]) == null ? void 0 : _h.text;
          if (text && options.streamCallback) {
            options.streamCallback(text);
          } else {
            console.warn("No text found in Gemini response:", JSON.stringify(data));
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Gemini request was aborted");
          } else {
            console.error("Error calling Gemini:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Gemini models from both v1 and v1beta endpoints by default
       *
       * @returns List of available model names (deduplicated)
       */
      async getAvailableModels() {
        const fetchModels = async (version) => {
          var _a2;
          const url = `https://generativelanguage.googleapis.com/${version}/models?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "GET",
            headers: { "Content-Type": "application/json" }
          });
          if (!response.ok) throw this.handleHttpError(response);
          const data = await response.json();
          return ((_a2 = data.models) == null ? void 0 : _a2.map((model) => model.name.split("/").pop())) || [];
        };
        try {
          const [v1Models, v1betaModels] = await Promise.all([
            fetchModels("v1"),
            fetchModels("v1beta")
          ]);
          return Array.from(/* @__PURE__ */ new Set([...v1Models, ...v1betaModels]));
        } catch (error) {
          console.error("Error fetching Gemini models:", error);
          throw error;
        }
      }
      /**
       * Test connection to Gemini
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to Google Gemini! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
      /**
       * Format messages for Gemini API
       * 
       * Converts from the plugin's Message format to Gemini's expected format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages for Gemini API
       */
      formatMessages(messages) {
        const geminiMessages = [];
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        for (const message of systemMessages) {
          geminiMessages.push({
            role: "user",
            parts: [{ text: message.content }]
          });
        }
        for (const message of nonSystemMessages) {
          const role = message.role === "assistant" ? "model" : "user";
          geminiMessages.push({
            role,
            parts: [{ text: message.content }]
          });
        }
        return geminiMessages;
      }
    };
  }
});

// providers/ollama.ts
var OllamaProvider;
var init_ollama = __esm({
  "providers/ollama.ts"() {
    init_base();
    OllamaProvider = class extends BaseProvider {
      constructor(serverUrl = "http://localhost:11434", model = "llama2") {
        super();
        __publicField(this, "apiKey", "");
        // Not used for Ollama
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        this.baseUrl = serverUrl.replace(/\/$/, "");
        this.model = model;
      }
      /**
       * Convert messages to Ollama format
       * 
       * @param messages - Standard message format
       * @returns Prompt string in Ollama format
       */
      convertToOllamaFormat(messages) {
        return messages.map((msg) => {
          if (msg.role === "system") {
            return `System: ${msg.content}

`;
          }
          return `${msg.role === "user" ? "Human" : "Assistant"}: ${msg.content}

`;
        }).join("") + "Assistant:";
      }
      /**
       * Get a completion from Ollama
       * 
       * Sends the conversation to the local Ollama server and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d;
        try {
          const prompt = this.convertToOllamaFormat(messages);
          const response = await fetch(`${this.baseUrl}/api/generate`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: this.model,
              prompt,
              stream: true,
              options: {
                temperature: (_a2 = options.temperature) != null ? _a2 : 0.7,
                num_predict: (_b = options.maxTokens) != null ? _b : 1e3
              }
            }),
            signal: (_c = options.abortController) == null ? void 0 : _c.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const reader = (_d = response.body) == null ? void 0 : _d.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await (reader == null ? void 0 : reader.read()) || { done: true, value: void 0 };
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim()) {
                try {
                  const data = JSON.parse(line);
                  if (data.response && options.streamCallback) {
                    options.streamCallback(data.response);
                  }
                } catch (e) {
                  console.warn("Error parsing Ollama response chunk:", e);
                }
              }
            }
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            console.log("Ollama stream was aborted");
          } else {
            console.error("Error calling Ollama:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Ollama models
       * 
       * Fetches the list of models installed on the local Ollama server.
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        var _a2;
        try {
          const response = await fetch(`${this.baseUrl}/api/tags`);
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          return ((_a2 = data.models) == null ? void 0 : _a2.map((model) => model.name)) || [];
        } catch (error) {
          console.error("Error fetching Ollama models:", error);
          throw error;
        }
      }
      /**
       * Test connection to Ollama
       * 
       * Verifies the Ollama server is running and accessible.
       * Also checks if any models are installed.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          if (models.length === 0) {
            return {
              success: false,
              message: 'Connected to Ollama server, but no models are installed. Use "ollama pull model-name" to install models.',
              models: []
            };
          }
          return {
            success: true,
            message: `Successfully connected to Ollama! Found ${models.length} installed models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/index.ts
var providers_exports = {};
__export(providers_exports, {
  AnthropicProvider: () => AnthropicProvider,
  BaseProvider: () => BaseProvider,
  GeminiProvider: () => GeminiProvider,
  OllamaProvider: () => OllamaProvider,
  OpenAIProvider: () => OpenAIProvider,
  ProviderError: () => ProviderError,
  ProviderErrorType: () => ProviderErrorType,
  createProvider: () => createProvider,
  createProviderFromUnifiedModel: () => createProviderFromUnifiedModel,
  getAllAvailableModels: () => getAllAvailableModels,
  getModelIdFromUnifiedModel: () => getModelIdFromUnifiedModel,
  getProviderFromUnifiedModel: () => getProviderFromUnifiedModel
});
function createProvider(settings) {
  switch (settings.provider) {
    case "openai":
      return new OpenAIProvider(
        settings.openaiSettings.apiKey,
        settings.openaiSettings.model,
        settings.openaiSettings.baseUrl
      );
    case "anthropic":
      return new AnthropicProvider(
        settings.anthropicSettings.apiKey,
        settings.anthropicSettings.model
      );
    case "gemini":
      return new GeminiProvider(
        settings.geminiSettings.apiKey,
        settings.geminiSettings.model
      );
    case "ollama":
      return new OllamaProvider(
        settings.ollamaSettings.serverUrl,
        settings.ollamaSettings.model
      );
    default:
      throw new Error(`Invalid provider type: ${settings.provider}`);
  }
}
function createProviderFromUnifiedModel(settings, unifiedModelId) {
  const [providerType, modelId] = unifiedModelId.split(":", 2);
  switch (providerType) {
    case "openai":
      return new OpenAIProvider(settings.openaiSettings.apiKey, modelId, settings.openaiSettings.baseUrl);
    case "anthropic":
      return new AnthropicProvider(settings.anthropicSettings.apiKey, modelId);
    case "gemini":
      return new GeminiProvider(settings.geminiSettings.apiKey, modelId);
    case "ollama":
      return new OllamaProvider(settings.ollamaSettings.serverUrl, modelId);
    default:
      throw new Error(`Invalid provider type: ${providerType}`);
  }
}
async function getAllAvailableModels(settings) {
  const allModels = [];
  const getProviderDisplayName = (provider) => {
    switch (provider) {
      case "openai":
        return "OpenAI";
      case "anthropic":
        return "Anthropic";
      case "gemini":
        return "Google";
      case "ollama":
        return "Ollama";
      default:
        return provider;
    }
  };
  if (settings.openaiSettings.apiKey && settings.openaiSettings.availableModels.length > 0) {
    settings.openaiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `openai:${model}`,
        name: `${model} (${getProviderDisplayName("openai")})`,
        provider: "openai",
        modelId: model
      });
    });
  }
  if (settings.anthropicSettings.apiKey && settings.anthropicSettings.availableModels.length > 0) {
    settings.anthropicSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `anthropic:${model}`,
        name: `${model} (${getProviderDisplayName("anthropic")})`,
        provider: "anthropic",
        modelId: model
      });
    });
  }
  if (settings.geminiSettings.apiKey && settings.geminiSettings.availableModels.length > 0) {
    settings.geminiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `gemini:${model}`,
        name: `${model} (${getProviderDisplayName("gemini")})`,
        provider: "gemini",
        modelId: model
      });
    });
  }
  if (settings.ollamaSettings.serverUrl && settings.ollamaSettings.availableModels.length > 0) {
    settings.ollamaSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `ollama:${model}`,
        name: `${model} (${getProviderDisplayName("ollama")})`,
        provider: "ollama",
        modelId: model
      });
    });
  }
  return allModels;
}
function getProviderFromUnifiedModel(unifiedModelId) {
  const [providerType] = unifiedModelId.split(":", 2);
  return providerType;
}
function getModelIdFromUnifiedModel(unifiedModelId) {
  const [, modelId] = unifiedModelId.split(":", 2);
  return modelId;
}
var init_providers = __esm({
  "providers/index.ts"() {
    init_base();
    init_anthropic();
    init_openai();
    init_gemini();
    init_ollama();
  }
});

// src/components/chat/chatPersistence.ts
function log(level, ...args) {
  if (typeof window !== "undefined" && window.plugin && typeof window.plugin.debugLog === "function") {
    window.plugin.debugLog(level, "[chatPersistence]", ...args);
  } else if (typeof console !== "undefined") {
    if (level !== "debug") console[level]("[chatPersistence]", ...args);
  }
}
function buildChatYaml(settings, provider, model) {
  log("info", "[buildChatYaml] Entered function", { settings, provider, model });
  if (settings.selectedModel) {
    const providerType = getProviderFromUnifiedModel(settings.selectedModel);
    const modelId = getModelIdFromUnifiedModel(settings.selectedModel);
    const yamlObj = {
      provider: providerType,
      model: modelId,
      unified_model: settings.selectedModel,
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    log("debug", "[buildChatYaml] Using unified model format", yamlObj);
    log("info", "[buildChatYaml] Returning YAML for unified model", { yaml: `---
${dump(yamlObj)}---
` });
    return `---
${dump(yamlObj)}---
`;
  } else {
    const yamlObj = {
      provider: provider || settings.provider,
      model: model || getCurrentModelForProvider(settings),
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    log("debug", "[buildChatYaml] Using legacy model format", yamlObj);
    log("info", "[buildChatYaml] Returning YAML for legacy model", { yaml: `---
${dump(yamlObj)}---
` });
    return `---
${dump(yamlObj)}---
`;
  }
}
function getCurrentModelForProvider(settings) {
  log("debug", "[getCurrentModelForProvider] Called", { provider: settings.provider });
  switch (settings.provider) {
    case "openai":
      return settings.openaiSettings.model;
    case "anthropic":
      return settings.anthropicSettings.model;
    case "gemini":
      return settings.geminiSettings.model;
    case "ollama":
      return settings.ollamaSettings.model;
    default:
      return "";
  }
}
async function saveChatAsNote({
  app,
  messages,
  chatContent,
  settings,
  provider,
  model,
  chatSeparator,
  chatNoteFolder,
  agentResponseHandler
}) {
  log("info", "[saveChatAsNote] Entered function", { hasMessages: !!messages, hasChatContent: typeof chatContent === "string" });
  let content = "";
  if (typeof chatContent === "string") {
    content = chatContent;
    log("info", "[saveChatAsNote] Using provided chatContent string directly.");
  } else if (messages) {
    log("info", "[saveChatAsNote] Building chat content from message DOM nodes.");
    const messageRenderer = new MessageRenderer(app);
    messages.forEach((el, index) => {
      var _a2;
      const htmlElement = el;
      if (htmlElement.classList.contains("tool-display-message")) {
        log("debug", `[saveChatAsNote] Skipping tool-display-message at index ${index}`);
        return;
      }
      const messageDataStr = htmlElement.dataset.messageData;
      let messageData = null;
      if (messageDataStr) {
        try {
          messageData = JSON.parse(messageDataStr);
          log("debug", `[saveChatAsNote] Parsed messageData at index ${index}`, messageData);
        } catch (e) {
          log("warn", `[saveChatAsNote] Failed to parse messageData at index ${index}`, e);
        }
      }
      if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
        log("info", `[saveChatAsNote] Formatting message with toolResults at index ${index}`);
        content += messageRenderer.getMessageContentForCopy(messageData);
      } else {
        const rawContent = htmlElement.dataset.rawContent;
        const msg = rawContent !== void 0 ? rawContent : ((_a2 = el.querySelector(".message-content")) == null ? void 0 : _a2.textContent) || "";
        log("debug", `[saveChatAsNote] Appending regular message at index ${index}`, { msg });
        content += msg;
      }
      if (index < messages.length - 1) {
        content += "\n\n" + chatSeparator + "\n\n";
      }
    });
    log("debug", "[saveChatAsNote] messages NodeList length:", { length: messages.length });
  } else {
    log("error", "[saveChatAsNote] Neither messages nor chatContent provided. Aborting.");
    throw new Error("Either messages or chatContent must be provided");
  }
  const yaml = buildChatYaml(settings, provider, model);
  log("info", "[saveChatAsNote] YAML frontmatter built. Stripping any existing YAML from chat content.");
  content = content.replace(/^---[\s\S]*?---\n?/, "");
  content = content.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  content = content.replace(/\n{3,}/g, "\n\n");
  content = content.replace(/\n+$/, "");
  const noteContent = yaml + "\n" + content + "\n";
  const now = /* @__PURE__ */ new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const fileName = `Chat Export ${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}-${pad(now.getMinutes())}.md`;
  let filePath = fileName;
  const folder = chatNoteFolder == null ? void 0 : chatNoteFolder.trim();
  if (folder) {
    log("info", `[saveChatAsNote] Ensuring chat note folder exists: ${folder}`);
    const folderExists = app.vault.getAbstractFileByPath(folder);
    if (!folderExists) {
      try {
        await app.vault.createFolder(folder);
        log("info", `[saveChatAsNote] Created chat note folder: ${folder}`);
      } catch (e) {
        if (!app.vault.getAbstractFileByPath(folder)) {
          log("error", `[saveChatAsNote] Failed to create folder for chat note: ${folder}`, e);
          new import_obsidian15.Notice("Failed to create folder for chat note.");
          return;
        } else {
          log("warn", `[saveChatAsNote] Folder already exists after race: ${folder}`);
        }
      }
    } else {
      log("debug", `[saveChatAsNote] Folder already exists: ${folder}`);
    }
    filePath = folder.replace(/[/\\]+$/, "") + "/" + fileName;
  }
  let finalFilePath = filePath;
  let attempt = 1;
  while (app.vault.getAbstractFileByPath(finalFilePath)) {
    const extIndex = fileName.lastIndexOf(".");
    const base = extIndex !== -1 ? fileName.substring(0, extIndex) : fileName;
    const ext = extIndex !== -1 ? fileName.substring(extIndex) : "";
    finalFilePath = (folder ? folder.replace(/[/\\]+$/, "") + "/" : "") + `${base} (${attempt})${ext}`;
    log("warn", "[saveChatAsNote] File already exists, trying new filename", { finalFilePath });
    attempt++;
  }
  try {
    await app.vault.create(finalFilePath, noteContent);
    log("info", "[saveChatAsNote] Chat successfully saved as note", { finalFilePath });
    new import_obsidian15.Notice(`Chat saved as note: ${finalFilePath}`);
  } catch (e) {
    log("error", "[saveChatAsNote] Failed to save chat as note", { finalFilePath, error: e });
    new import_obsidian15.Notice("Failed to save chat as note.");
  }
  log("info", "[saveChatAsNote] Exiting function. Save process complete.");
}
async function loadChatYamlAndApplySettings({
  app,
  plugin,
  settings,
  file
}) {
  log("info", "[loadChatYamlAndApplySettings] Entered function", { file: (file == null ? void 0 : file.path) || (file == null ? void 0 : file.name) || file });
  log("debug", "[loadChatYamlAndApplySettings] File content loaded. Extracting YAML frontmatter.");
  let content = await app.vault.read(file);
  const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
  let yamlObj = {};
  if (yamlMatch) {
    try {
      yamlObj = load(yamlMatch[1]) || {};
      log("info", "[loadChatYamlAndApplySettings] YAML frontmatter parsed", yamlObj);
    } catch (e) {
      log("warn", "[loadChatYamlAndApplySettings] Failed to parse YAML frontmatter", e);
      yamlObj = {};
    }
  } else {
    log("warn", "[loadChatYamlAndApplySettings] No YAML frontmatter found in file.");
  }
  if (yamlObj.unified_model) {
    settings.selectedModel = yamlObj.unified_model;
    log("info", "[loadChatYamlAndApplySettings] Loaded unified_model from YAML", yamlObj.unified_model);
    log("info", "[loadChatYamlAndApplySettings] Set selectedModel from unified_model", { selectedModel: settings.selectedModel });
  } else if (yamlObj.provider && yamlObj.model) {
    const unifiedModelId = `${yamlObj.provider}:${yamlObj.model}`;
    settings.selectedModel = unifiedModelId;
    log("info", "[loadChatYamlAndApplySettings] Loaded legacy provider/model from YAML", { provider: yamlObj.provider, model: yamlObj.model });
    log("info", "[loadChatYamlAndApplySettings] Set selectedModel from provider/model", { selectedModel: settings.selectedModel });
    settings.provider = yamlObj.provider;
    switch (yamlObj.provider) {
      case "openai":
        settings.openaiSettings.model = yamlObj.model;
        break;
      case "anthropic":
        settings.anthropicSettings.model = yamlObj.model;
        break;
      case "gemini":
        settings.geminiSettings.model = yamlObj.model;
        break;
      case "ollama":
        settings.ollamaSettings.model = yamlObj.model;
        break;
    }
  } else {
    log("warn", "[loadChatYamlAndApplySettings] No model/provider found in YAML. Using existing settings.");
  }
  let newSystemMessage = yamlObj.system_message || settings.systemMessage;
  let newTemperature = settings.temperature;
  if (yamlObj.temperature !== void 0) {
    const tempNum = parseFloat(yamlObj.temperature);
    if (!isNaN(tempNum)) {
      newTemperature = tempNum;
      log("info", "[loadChatYamlAndApplySettings] Loaded temperature from YAML", newTemperature);
    } else {
      log("warn", "[loadChatYamlAndApplySettings] Invalid temperature in YAML, using existing value.", yamlObj.temperature);
    }
  }
  settings.systemMessage = newSystemMessage;
  settings.temperature = newTemperature;
  log("info", "[loadChatYamlAndApplySettings] Applied settings from YAML", { selectedModel: settings.selectedModel, systemMessage: newSystemMessage, temperature: newTemperature });
  if (plugin.onSettingsLoadedFromNote) {
    log("debug", "[loadChatYamlAndApplySettings] Calling plugin.onSettingsLoadedFromNote");
    plugin.onSettingsLoadedFromNote(settings);
  }
  log("info", "[loadChatYamlAndApplySettings] Exiting function. YAML load/apply process complete.");
  return {
    provider: yamlObj.provider,
    model: yamlObj.model,
    unifiedModel: settings.selectedModel,
    systemMessage: newSystemMessage,
    temperature: newTemperature
  };
}
var import_obsidian15;
var init_chatPersistence = __esm({
  "src/components/chat/chatPersistence.ts"() {
    import_obsidian15 = require("obsidian");
    init_js_yaml();
    init_providers();
    init_MessageRenderer();
  }
});

// src/components/chat/ChatHelpModal.ts
var import_obsidian16, ChatHelpModal;
var init_ChatHelpModal = __esm({
  "src/components/chat/ChatHelpModal.ts"() {
    import_obsidian16 = require("obsidian");
    ChatHelpModal = class extends import_obsidian16.Modal {
      constructor(app) {
        super(app);
      }
      createCollapsibleSection(title, contentCallback, expanded = true) {
        const sectionContainer = createDiv();
        sectionContainer.addClass("ai-collapsible-section");
        const header = createDiv();
        header.addClass("ai-collapsible-header");
        const arrow = createSpan();
        arrow.addClass("ai-collapsible-arrow");
        arrow.textContent = expanded ? "\u25BC" : "\u25B6";
        const titleSpan = createSpan();
        titleSpan.textContent = title;
        header.appendChild(arrow);
        header.appendChild(titleSpan);
        const content = createDiv();
        content.addClass("ai-collapsible-content");
        content.style.display = expanded ? "block" : "none";
        header.addEventListener("click", () => {
          const isExpanded = content.style.display !== "none";
          content.style.display = isExpanded ? "none" : "block";
          arrow.textContent = isExpanded ? "\u25B6" : "\u25BC";
        });
        sectionContainer.appendChild(header);
        sectionContainer.appendChild(content);
        const originalContent = this.contentEl;
        this.contentEl = content;
        contentCallback();
        this.contentEl = originalContent;
        return sectionContainer;
      }
      onOpen() {
        this.titleEl.setText("AI Chat Help");
        this.contentEl.empty();
        this.contentEl.appendChild(this.createCollapsibleSection("Slash Commands", () => {
          this.contentEl.innerHTML = `
                <code>/clear</code> \u2013 Clear the chat<br>
                <code>/copy</code> \u2013 Copy all chat<br>
                <code>/save</code> \u2013 Save chat as note<br>
                <code>/settings</code> \u2013 Open settings<br>
                <code>/help</code> \u2013 Show this help<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Keyboard Shortcuts (when chat window or input is focused)", () => {
          this.contentEl.innerHTML = `
                <code>Ctrl+Shift+X</code> \u2013 Clear chat<br>
                <code>Ctrl+Shift+C</code> \u2013 Copy all chat<br>
                <code>Ctrl+Shift+S</code> \u2013 Save as note<br>
                <code>Ctrl+Shift+O</code> \u2013 Open settings<br>
                <code>Ctrl+Shift+H</code> \u2013 Show this help<br>
                <code>Ctrl+Shift+R</code> \u2013 Toggle referencing current note<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Other", () => {
          this.contentEl.innerHTML = `
                <code>Enter</code> \u2013 Send message<br>
                <code>Shift+Enter</code> \u2013 Newline<br>
                <br>
                You can also use the buttons at the top of the chat window.
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Reference Current Note", () => {
          this.contentEl.innerHTML = `
                <strong>What is it?</strong><br>
                When enabled, the AI can see the content of your currently active note during chat. This helps the AI give more relevant, context-aware responses.<br><br>

                <strong>How to use:</strong><br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>Click the <code>\u{1F4DD}</code> button at the top of the chat window to toggle referencing the current note.</li>
                  <li>Or use the slash command <code>/ref</code> or keyboard shortcut <code>Ctrl+Shift+R</code>.</li>
                  <li>The name of the referenced note will appear in faded small text below the buttons when enabled.</li>
                </ul>

                <strong>Notes:</strong><br>
                - When referencing is enabled, the AI receives:<br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>The system prompt (always)</li>
                  <li>Context notes (if enabled in settings)</li>
                  <li>The content of the currently active note</li>
                  <li>The chat history (all previous user/assistant messages)</li>
                </ul>
                - Only the currently active note is shared in addition to the above context.<br>
                - You can turn this on or off at any time.<br>
                - No other notes or personal data are accessed.<br>
                - The <code>\u{1F4DD}</code> button will show "On" or "Off" to indicate the current state.
            `;
        }));
      }
    };
  }
});

// src/components/chat/ConfirmationModal.ts
var import_obsidian17, ConfirmationModal;
var init_ConfirmationModal = __esm({
  "src/components/chat/ConfirmationModal.ts"() {
    import_obsidian17 = require("obsidian");
    ConfirmationModal = class extends import_obsidian17.Modal {
      constructor(app, title, message, onConfirm) {
        super(app);
        __publicField(this, "onConfirm");
        __publicField(this, "message");
        this.titleEl.setText(title);
        this.message = message;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.addClass("ai-assistant-modal");
        contentEl.createEl("p", { text: this.message });
        const buttonContainer = contentEl.createDiv("modal-button-container");
        buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
          this.onConfirm(false);
          this.close();
        });
        const confirmButton = buttonContainer.createEl("button", {
          text: "Delete",
          cls: "mod-warning"
        });
        confirmButton.addEventListener("click", () => {
          this.onConfirm(true);
          this.close();
        });
      }
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/SettingsSections.ts
var SettingsSections_exports = {};
__export(SettingsSections_exports, {
  SettingsSections: () => SettingsSections
});
var import_obsidian18, SettingsSections;
var init_SettingsSections = __esm({
  "src/components/chat/SettingsSections.ts"() {
    import_obsidian18 = require("obsidian");
    init_providers();
    SettingsSections = class {
      constructor(plugin) {
        __publicField(this, "plugin");
        this.plugin = plugin;
      }
      /**
       * AI Model Settings Section
       */
      async renderAIModelSettings(containerEl, onRefresh) {
        while (containerEl.firstChild) containerEl.removeChild(containerEl.firstChild);
        if (this.plugin.settings.modelSettingPresets && this.plugin.settings.modelSettingPresets.length > 0) {
          const presetContainer = containerEl.createDiv();
          presetContainer.addClass("model-preset-buttons");
          presetContainer.createEl("div", { text: "Presets:", cls: "setting-item-name" });
          this.plugin.settings.modelSettingPresets.forEach((preset, idx) => {
            const btn = presetContainer.createEl("button", { text: preset.name });
            btn.style.marginRight = "0.5em";
            btn.onclick = async () => {
              if (preset.selectedModel !== void 0) this.plugin.settings.selectedModel = preset.selectedModel;
              if (preset.systemMessage !== void 0) this.plugin.settings.systemMessage = preset.systemMessage;
              if (preset.temperature !== void 0) this.plugin.settings.temperature = preset.temperature;
              if (preset.maxTokens !== void 0) this.plugin.settings.maxTokens = preset.maxTokens;
              if (preset.enableStreaming !== void 0) this.plugin.settings.enableStreaming = preset.enableStreaming;
              await this.plugin.saveSettings();
              if (onRefresh) {
                if (window._aiModelSettingsRefreshTimeout) {
                  clearTimeout(window._aiModelSettingsRefreshTimeout);
                }
                window._aiModelSettingsRefreshTimeout = setTimeout(() => {
                  onRefresh();
                  window._aiModelSettingsRefreshTimeout = null;
                }, 50);
              }
              new import_obsidian18.Notice(`Applied preset: ${preset.name}`);
            };
          });
        }
        new import_obsidian18.Setting(containerEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
          this.plugin.settings.systemMessage = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian18.Setting(containerEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
          this.plugin.settings.enableStreaming = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian18.Setting(containerEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.temperature = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian18.Setting(containerEl).setName("Refresh Available Models").setDesc("Test connections to all configured providers and refresh available models").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
          button.setButtonText("Refreshing...");
          button.setDisabled(true);
          try {
            await this.refreshAllAvailableModels();
            new import_obsidian18.Notice("Successfully refreshed available models");
            if (onRefresh) onRefresh();
          } catch (error) {
            new import_obsidian18.Notice(`Error refreshing models: ${error.message}`);
          } finally {
            button.setButtonText("Refresh Models");
            button.setDisabled(false);
          }
        }));
        await this.renderUnifiedModelDropdown(containerEl);
      }
      /**
       * Date Settings Section
       */
      renderDateSettings(containerEl) {
        new import_obsidian18.Setting(containerEl).setName("Include Date with System Message").setDesc("Add the current date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDateWithSystemMessage).onChange(async (value) => {
          this.plugin.settings.includeDateWithSystemMessage = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian18.Setting(containerEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
          this.plugin.settings.includeTimeWithSystemMessage = value;
          await this.plugin.saveSettings();
        }));
      }
      /**
       * Note Reference Settings Section
       */
      renderNoteReferenceSettings(containerEl) {
        new import_obsidian18.Setting(containerEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
          this.plugin.settings.enableObsidianLinks = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian18.Setting(containerEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
          this.plugin.settings.enableContextNotes = value;
          await this.plugin.saveSettings();
        }));
        const contextNotesContainer = containerEl.createDiv("context-notes-container");
        contextNotesContainer.style.marginBottom = "24px";
        new import_obsidian18.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
          text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange(async (value) => {
            this.plugin.settings.contextNotes = value;
            await this.plugin.saveSettings();
          });
          text.inputEl.rows = 4;
          text.inputEl.style.width = "100%";
        });
        new import_obsidian18.Setting(containerEl).setName("Expand Linked Notes Recursively").setDesc("If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).").addToggle((toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false).onChange(async (value) => {
            this.plugin.settings.expandLinkedNotesRecursively = value;
            await this.plugin.saveSettings();
          });
        });
      }
      /**
       * Provider Configuration Section
       */
      renderProviderConfiguration(containerEl) {
        containerEl.createEl("p", {
          text: "API keys are configured in the main plugin settings. Use the test buttons below to verify connections and refresh available models.",
          cls: "setting-item-description"
        });
        this.renderOpenAIConfig(containerEl);
        this.renderAnthropicConfig(containerEl);
        this.renderGeminiConfig(containerEl);
        this.renderOllamaConfig(containerEl);
      }
      /**
       * Renders the unified model selection dropdown
       */
      async renderUnifiedModelDropdown(containerEl) {
        if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
          this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
          await this.plugin.saveSettings();
        }
        new import_obsidian18.Setting(containerEl).setName("Selected Model").setDesc("Choose from all available models across all configured providers").addDropdown((dropdown) => {
          if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
            dropdown.addOption("", "No models available - configure providers below");
          } else {
            dropdown.addOption("", "Select a model...");
            const modelsByProvider = {};
            const enabledModels = this.plugin.settings.enabledModels || {};
            const filteredModels = this.plugin.settings.availableModels.filter((model) => enabledModels[model.id] !== false);
            filteredModels.forEach((model) => {
              if (!modelsByProvider[model.provider]) {
                modelsByProvider[model.provider] = [];
              }
              modelsByProvider[model.provider].push(model);
            });
            Object.entries(modelsByProvider).forEach(([provider, models]) => {
              models.forEach((model) => {
                dropdown.addOption(model.id, model.name);
              });
            });
          }
          dropdown.setValue(this.plugin.settings.selectedModel || "").onChange(async (value) => {
            this.plugin.settings.selectedModel = value;
            if (value) {
              const provider = getProviderFromUnifiedModel(value);
              this.plugin.settings.provider = provider;
            }
            await this.plugin.saveSettings();
          });
        });
        if (this.plugin.settings.selectedModel && this.plugin.settings.availableModels) {
          const selectedModel = this.plugin.settings.availableModels.find(
            (model) => model.id === this.plugin.settings.selectedModel
          );
          if (selectedModel) {
            const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
            infoEl.setText(`Currently using: ${selectedModel.name}`);
          }
        }
      }
      /**
       * Refreshes available models from all configured providers
       */
      async refreshAllAvailableModels() {
        const providers = ["openai", "anthropic", "gemini", "ollama"];
        for (const providerType of providers) {
          try {
            const originalProvider = this.plugin.settings.provider;
            this.plugin.settings.provider = providerType;
            const providerInstance = createProvider(this.plugin.settings);
            const result = await providerInstance.testConnection();
            this.plugin.settings.provider = originalProvider;
            const providerSettings = this.plugin.settings[`${providerType}Settings`];
            if (result.success && result.models) {
              providerSettings.availableModels = result.models;
              providerSettings.lastTestResult = {
                timestamp: Date.now(),
                success: true,
                message: result.message
              };
            } else {
              providerSettings.lastTestResult = {
                timestamp: Date.now(),
                success: false,
                message: result.message
              };
            }
          } catch (error) {
            console.error(`Error testing ${providerType}:`, error);
          }
        }
        this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
        await this.plugin.saveSettings();
      }
      /**
       * Renders a collapsible section for provider configuration.
       * @param containerEl The HTML element to render the section into.
       * @param providerType The type of the provider (e.g., 'openai', 'anthropic').
       * @param displayName The display name of the provider (e.g., 'OpenAI', 'Anthropic').
       * @param renderSpecificSettings A callback function to render provider-specific settings.
       */
      _renderCollapsibleProviderConfig(containerEl, providerType, displayName, renderSpecificSettings) {
        const collapsibleContainer = containerEl.createDiv({ cls: "provider-collapsible" });
        const headerEl = collapsibleContainer.createEl("div", {
          cls: "provider-header",
          text: `\u25B6 ${displayName} Configuration`
        });
        Object.assign(headerEl.style, {
          cursor: "pointer",
          userSelect: "none",
          padding: "8px 0",
          fontWeight: "bold"
        });
        const contentEl = collapsibleContainer.createDiv({ cls: "provider-content" });
        contentEl.style.display = "none";
        contentEl.style.paddingLeft = "16px";
        let isExpanded = false;
        headerEl.addEventListener("click", () => {
          isExpanded = !isExpanded;
          contentEl.style.display = isExpanded ? "block" : "none";
          headerEl.textContent = `${isExpanded ? "\u25BC" : "\u25B6"} ${displayName} Configuration`;
        });
        const settings = this.plugin.settings[`${providerType}Settings`];
        const apiKeyStatus = settings.apiKey ? `API Key: ${settings.apiKey.substring(0, 8)}...` : "No API Key configured";
        const serverUrlStatus = settings.serverUrl ? `Server URL: ${settings.serverUrl}` : "No Server URL configured";
        contentEl.createEl("div", {
          cls: "setting-item-description",
          text: `${settings.apiKey ? apiKeyStatus : serverUrlStatus} (Configure in main plugin settings)`
        });
        if (renderSpecificSettings) {
          renderSpecificSettings(contentEl);
        }
        this.renderProviderTestSection(contentEl, providerType, displayName);
      }
      /**
       * Renders the OpenAI configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOpenAIConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "openai", "OpenAI", (contentEl) => {
          new import_obsidian18.Setting(contentEl).setName("OpenAI Base URL").setDesc("Custom base URL for OpenAI API (optional)").addText((text) => text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openaiSettings.baseUrl || "").onChange(async (value) => {
            this.plugin.settings.openaiSettings.baseUrl = value;
            await this.plugin.saveSettings();
          }));
        });
      }
      /**
       * Renders the Anthropic configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderAnthropicConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "anthropic", "Anthropic");
      }
      /**
       * Renders the Gemini configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderGeminiConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "gemini", "Gemini");
      }
      /**
       * Renders the Ollama configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOllamaConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "ollama", "Ollama", (contentEl) => {
          contentEl.createEl("div", {
            cls: "setting-item-description",
            text: "To use Ollama:"
          });
          const steps = contentEl.createEl("ol");
          steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
          steps.createEl("li", { text: "Start the Ollama server" });
          steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
          steps.createEl("li", { text: "Test connection to see available models" });
        });
      }
      /**
       * Renders the provider connection test section.
       * @param containerEl The HTML element to render the section into.
       * @param provider The internal identifier for the provider (e.g., 'openai').
       * @param displayName The user-friendly name of the provider (e.g., 'OpenAI').
       */
      renderProviderTestSection(containerEl, provider, displayName) {
        const settings = this.plugin.settings[`${provider}Settings`];
        new import_obsidian18.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${displayName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
          button.setButtonText("Testing...");
          button.setDisabled(true);
          try {
            const originalProvider = this.plugin.settings.provider;
            this.plugin.settings.provider = provider;
            const providerInstance = createProvider(this.plugin.settings);
            const result = await providerInstance.testConnection();
            this.plugin.settings.provider = originalProvider;
            if (result.success && result.models) {
              settings.availableModels = result.models;
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: true,
                message: result.message
              };
              await this.plugin.saveSettings();
              this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
              await this.plugin.saveSettings();
              new import_obsidian18.Notice(result.message);
            } else {
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: false,
                message: result.message
              };
              new import_obsidian18.Notice(result.message);
            }
          } catch (error) {
            new import_obsidian18.Notice(`Error: ${error.message}`);
          } finally {
            button.setButtonText("Test");
            button.setDisabled(false);
          }
        }));
        if (settings.lastTestResult) {
          const date = new Date(settings.lastTestResult.timestamp);
          containerEl.createEl("div", {
            text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
            cls: settings.lastTestResult.success ? "success" : "error"
          });
        }
        if (settings.availableModels && settings.availableModels.length > 0) {
          containerEl.createEl("div", {
            text: `Available models: ${settings.availableModels.map((m) => m.name || m.id).join(", ")}`,
            cls: "setting-item-description"
          });
        }
      }
      /**
       * Debug Mode Section
       */
      renderDebugModeSettings(containerEl) {
        new import_obsidian18.Setting(containerEl).setName("Debug Mode").setDesc("Enable verbose logging and debug UI features").addToggle((toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false).onChange(async (value) => {
            this.plugin.settings.debugMode = value;
            await this.plugin.saveSettings();
          });
        });
      }
      /**
       * Renders all settings sections in order for a modal or view.
       * @param containerEl The HTML element to render the sections into.
       * @param options Optional settings, e.g., onRefresh callback.
       */
      async renderAllSettings(containerEl, options) {
        await this.renderAIModelSettings(containerEl, options == null ? void 0 : options.onRefresh);
        this.renderDateSettings(containerEl);
        this.renderNoteReferenceSettings(containerEl);
        this.renderProviderConfiguration(containerEl);
        this.renderDebugModeSettings(containerEl);
      }
    };
  }
});

// src/components/chat/SettingsModal.ts
var SettingsModal_exports = {};
__export(SettingsModal_exports, {
  SettingsModal: () => SettingsModal
});
var import_obsidian19, SettingsModal;
var init_SettingsModal = __esm({
  "src/components/chat/SettingsModal.ts"() {
    import_obsidian19 = require("obsidian");
    init_SettingsSections();
    SettingsModal = class extends import_obsidian19.Modal {
      constructor(app, plugin) {
        super(app);
        __publicField(this, "plugin");
        __publicField(this, "settingsSections");
        __publicField(this, "_onSettingsChange", () => {
          this.onOpen();
        });
        this.plugin = plugin;
        this.settingsSections = new SettingsSections(plugin);
        this.titleEl.setText("AI Model Settings");
        this.plugin.onSettingsChange(this._onSettingsChange);
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("ai-settings-modal");
        await this.settingsSections.renderAllSettings(contentEl, { onRefresh: () => this.onOpen() });
      }
      onClose() {
        this.plugin.offSettingsChange(this._onSettingsChange);
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/eventHandlers.ts
function getFormattedChatContent(messagesContainer, plugin, chatSeparator) {
  const messages = messagesContainer.querySelectorAll(".ai-chat-message");
  let chatContent = "";
  const renderer = new MessageRenderer(plugin.app);
  messages.forEach((el, index) => {
    var _a2;
    const htmlElement = el;
    if (htmlElement.classList.contains("tool-display-message")) {
      return;
    }
    let messageData = null;
    const messageDataStr = htmlElement.dataset.messageData;
    if (messageDataStr) {
      try {
        messageData = JSON.parse(messageDataStr);
      } catch (e) {
      }
    }
    if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
      chatContent += renderer.getMessageContentForCopy(messageData);
    } else {
      const rawContent = htmlElement.dataset.rawContent;
      const content = rawContent !== void 0 ? rawContent : ((_a2 = el.querySelector(".message-content")) == null ? void 0 : _a2.textContent) || "";
      chatContent += content;
    }
    if (index < messages.length - 1) {
      chatContent += "\n\n" + chatSeparator + "\n\n";
    }
  });
  return chatContent;
}
function handleCopyAll(messagesContainer, plugin) {
  return async () => {
    const chatContent = getFormattedChatContent(messagesContainer, plugin, plugin.settings.chatSeparator);
    await copyToClipboard(chatContent);
  };
}
function handleSaveNote(messagesContainer, plugin, app, agentResponseHandler) {
  return async () => {
    const chatContent = getFormattedChatContent(messagesContainer, plugin, plugin.settings.chatSeparator);
    await saveChatAsNote({
      app,
      messages: void 0,
      settings: plugin.settings,
      chatSeparator: plugin.settings.chatSeparator,
      chatNoteFolder: plugin.settings.chatNoteFolder,
      agentResponseHandler,
      chatContent
    });
  };
}
function handleClearChat(messagesContainer, chatHistoryManager) {
  return async () => {
    messagesContainer.empty();
    try {
      await chatHistoryManager.clearHistory();
    } catch (e) {
      new import_obsidian20.Notice("Failed to clear chat history.");
    }
  };
}
function handleSettings(app, plugin) {
  return () => {
    const { SettingsModal: SettingsModal2 } = (init_SettingsModal(), __toCommonJS(SettingsModal_exports));
    const settingsModal = new SettingsModal2(app, plugin);
    settingsModal.open();
  };
}
function handleHelp(app) {
  return () => {
    new ChatHelpModal(app).open();
  };
}
function handleCopyMessage(messageEl, plugin) {
  return async () => {
    let contentToCopy = "";
    const messageData = messageEl.dataset.messageData;
    if (messageData) {
      try {
        const parsedData = JSON.parse(messageData);
        const renderer = new MessageRenderer(plugin.app);
        contentToCopy = renderer.getMessageContentForCopy(parsedData);
      } catch (e) {
        contentToCopy = messageEl.dataset.rawContent || "";
      }
    } else {
      contentToCopy = messageEl.dataset.rawContent || "";
    }
    if (contentToCopy.trim() === "") {
      new import_obsidian20.Notice("No content to copy");
      return;
    }
    await copyToClipboard(contentToCopy);
    new import_obsidian20.Notice("Message copied to clipboard");
  };
}
function handleEditMessage(messageEl, chatHistoryManager, plugin) {
  return async () => {
    const contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) return;
    if (!contentEl.hasClass("editing")) {
      const textarea = document.createElement("textarea");
      textarea.value = messageEl.dataset.rawContent || "";
      textarea.className = "message-content editing";
      contentEl.empty();
      contentEl.appendChild(textarea);
      textarea.focus();
      contentEl.addClass("editing");
      textarea.addEventListener("keydown", async (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          textarea.blur();
        }
      });
      textarea.addEventListener("blur", async () => {
        const oldContent = messageEl.dataset.rawContent;
        const newContent = textarea.value;
        let enhancedData = void 0;
        if (messageEl.dataset.messageData) {
          try {
            enhancedData = JSON.parse(messageEl.dataset.messageData);
          } catch (e) {
          }
        }
        try {
          await chatHistoryManager.updateMessage(
            messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            messageEl.classList.contains("user") ? "user" : "assistant",
            oldContent || "",
            newContent,
            enhancedData
          );
          messageEl.dataset.rawContent = newContent;
          contentEl.empty();
          if (enhancedData && enhancedData.toolResults) {
            const renderer = new MessageRenderer(plugin.app);
            await renderer.renderMessage({
              role: messageEl.classList.contains("user") ? "user" : "assistant",
              content: newContent,
              toolResults: enhancedData.toolResults
            }, messageEl, void 0);
          } else {
            await import_obsidian20.MarkdownRenderer.render(plugin.app, newContent, contentEl, "", void 0);
          }
          contentEl.removeClass("editing");
        } catch (e) {
          new import_obsidian20.Notice("Failed to save edited message.");
          messageEl.dataset.rawContent = oldContent || "";
          contentEl.empty();
          await import_obsidian20.MarkdownRenderer.render(plugin.app, oldContent || "", contentEl, "", void 0);
          contentEl.removeClass("editing");
        }
      });
    }
  };
}
function handleDeleteMessage(messageEl, chatHistoryManager, app) {
  return () => {
    const modal = new ConfirmationModal(app, "Delete message", "Are you sure you want to delete this message?", (confirmed) => {
      if (confirmed) {
        chatHistoryManager.deleteMessage(
          messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          messageEl.classList.contains("user") ? "user" : "assistant",
          messageEl.dataset.rawContent || ""
        ).then(() => {
          messageEl.remove();
        }).catch(() => {
          new import_obsidian20.Notice("Failed to delete message from history.");
        });
      }
    });
    modal.open();
  };
}
function handleRegenerateMessage(messageEl, regenerateCallback) {
  return () => {
    regenerateCallback(messageEl);
  };
}
var import_obsidian20;
var init_eventHandlers = __esm({
  "src/components/chat/eventHandlers.ts"() {
    init_Buttons();
    init_chatPersistence();
    init_ChatHelpModal();
    import_obsidian20 = require("obsidian");
    init_MessageRenderer();
    init_ConfirmationModal();
  }
});

// src/components/chat/BotMessage.ts
var BotMessage_exports = {};
__export(BotMessage_exports, {
  BotMessage: () => BotMessage
});
var import_obsidian24, BotMessage;
var init_BotMessage = __esm({
  "src/components/chat/BotMessage.ts"() {
    import_obsidian24 = require("obsidian");
    init_Buttons();
    BotMessage = class extends import_obsidian24.Component {
      constructor(app, plugin, content) {
        super();
        __publicField(this, "app");
        __publicField(this, "plugin");
        __publicField(this, "content");
        __publicField(this, "element");
        __publicField(this, "contentEl");
        this.app = app;
        this.plugin = plugin;
        this.content = content;
        this.element = this.createMessageElement();
      }
      getElement() {
        return this.element;
      }
      getContent() {
        return this.content;
      }
      async setContent(content) {
        this.content = content;
        this.element.dataset.rawContent = content;
        this.contentEl.empty();
        await import_obsidian24.MarkdownRenderer.render(
          this.app,
          content,
          this.contentEl,
          "",
          this
        );
      }
      createMessageElement() {
        const messageEl = document.createElement("div");
        messageEl.addClass("ai-chat-message", "assistant");
        messageEl.dataset.rawContent = this.content;
        const messageContainer = messageEl.createDiv("message-container");
        this.contentEl = messageContainer.createDiv("message-content");
        import_obsidian24.MarkdownRenderer.render(
          this.app,
          this.content,
          this.contentEl,
          "",
          this
        );
        const buttons = new Buttons();
        const actions = buttons.createMessageActions([
          {
            label: "Copy",
            tooltip: "Copy message",
            onClick: async () => {
              const content = messageEl.dataset.rawContent || "";
              if (content.trim() === "") return;
              await navigator.clipboard.writeText(content);
            }
          },
          {
            label: "Edit",
            tooltip: "Edit message",
            onClick: () => {
              const wasEditing = this.contentEl.hasClass("editing");
              if (!wasEditing) {
                const textarea = document.createElement("textarea");
                textarea.value = messageEl.dataset.rawContent || "";
                this.contentEl.empty();
                this.contentEl.appendChild(textarea);
                textarea.focus();
                this.contentEl.addClass("editing");
              } else {
                const textarea = this.contentEl.querySelector("textarea");
                if (textarea) {
                  this.setContent(textarea.value);
                  this.contentEl.removeClass("editing");
                }
              }
            }
          },
          {
            label: "Delete",
            tooltip: "Delete message",
            onClick: () => {
              messageEl.remove();
            }
          },
          {
            label: "Regenerate",
            tooltip: "Regenerate this response",
            onClick: () => {
              const event = new CustomEvent("ai-assistant:regenerate-response", {
                detail: { messageEl }
              });
              this.app.workspace.trigger("ai-assistant:regenerate-response", messageEl);
            }
          }
        ]);
        messageEl.addEventListener("mouseenter", () => {
        });
        messageEl.addEventListener("mouseleave", () => {
        });
        messageContainer.appendChild(actions);
        return messageEl;
      }
    };
  }
});

// src/components/chat/inputHandler.ts
var inputHandler_exports = {};
__export(inputHandler_exports, {
  setupInputHandler: () => setupInputHandler
});
function setupInputHandler(textarea, messagesContainer, sendMessage, handleSlashCommand, app, plugin, sendButton, stopButton) {
  const handleKeyboardShortcuts = async (e) => {
    if (e.ctrlKey && e.shiftKey) {
      if (e.key.toLowerCase() === "x") {
        e.preventDefault();
        await handleSlashCommand("/clear");
        return true;
      }
      if (e.key.toLowerCase() === "c") {
        e.preventDefault();
        await handleSlashCommand("/copy");
        return true;
      }
      if (e.key.toLowerCase() === "s") {
        e.preventDefault();
        await handleSlashCommand("/save");
        return true;
      }
      if (e.key.toLowerCase() === "o") {
        e.preventDefault();
        await handleSlashCommand("/settings");
        return true;
      }
      if (e.key.toLowerCase() === "h") {
        e.preventDefault();
        handleHelp(app)();
        return true;
      }
      if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        await handleSlashCommand("/ref");
        return true;
      }
    }
    return false;
  };
  textarea.addEventListener("keydown", async (e) => {
    if (await handleKeyboardShortcuts(e)) return;
    if (e.key === "Enter" && !e.shiftKey) {
      const val = textarea.value.trim();
      if (val === "/clear" || val === "/copy" || val === "/save" || val === "/settings" || val === "/help" || val === "/ref") {
        e.preventDefault();
        await handleSlashCommand(val);
        textarea.value = "";
        return;
      }
      await sendMessage();
      e.preventDefault();
    }
  });
  messagesContainer.addEventListener("keydown", async (e) => {
    await handleKeyboardShortcuts(e);
  });
}
var init_inputHandler = __esm({
  "src/components/chat/inputHandler.ts"() {
    init_eventHandlers();
  }
});

// src/YAMLHandler.ts
var YAMLHandler_exports = {};
__export(YAMLHandler_exports, {
  generateNoteTitle: () => generateNoteTitle,
  generateYamlAttribute: () => generateYamlAttribute,
  registerYamlAttributeCommands: () => registerYamlAttributeCommands,
  upsertYamlField: () => upsertYamlField
});
function generateTableOfContents(noteContent) {
  const headerLines = noteContent.split("\n").filter((line) => /^#{1,6}\s+.+/.test(line));
  if (headerLines.length === 0) return "";
  return headerLines.map((line) => {
    const match = line.match(/^(#{1,6})\s+(.+)/);
    if (!match) return "";
    const level = match[1].length;
    const title = match[2].trim();
    return `${"  ".repeat(level - 1)}- ${title}`;
  }).join("\n");
}
function debug2(...args) {
  if (DEBUG) {
    console.log("[DEBUG]", ...args);
  }
}
async function generateNoteTitle(app, settings, processMessages2) {
  var _a2, _b;
  debug2("Starting generateNoteTitle");
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian28.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const toc = generateTableOfContents(noteContent);
  const prompt = DEFAULT_TITLE_PROMPT;
  const userContent = (toc && toc.trim().length > 0 ? "Table of Contents:\n" + toc + "\n\n" : "") + noteContent;
  try {
    debug2("Provider:", settings.provider);
    const provider = settings.selectedModel ? createProviderFromUnifiedModel(settings, settings.selectedModel) : createProvider(settings);
    const messages = [
      { role: "system", content: prompt },
      { role: "user", content: userContent }
    ];
    debug2("Original messages:", JSON.stringify(messages));
    const originalEnableContextNotes = settings.enableContextNotes;
    debug2("Original enableContextNotes:", originalEnableContextNotes);
    settings.enableContextNotes = false;
    try {
      const processedMessages = await processMessages2(messages);
      debug2("Processed messages:", JSON.stringify(processedMessages));
      settings.enableContextNotes = originalEnableContextNotes;
      if (!processedMessages || processedMessages.length === 0) {
        debug2("No processed messages!");
        new import_obsidian28.Notice("No valid messages to send to the model. Please check your note content.");
        return;
      }
      debug2("Calling provider.getCompletion");
      let resultBuffer = "";
      await provider.getCompletion(processedMessages, {
        temperature: 0,
        streamCallback: (chunk) => {
          resultBuffer += chunk;
        }
      });
      debug2("Result from provider (buffered):", resultBuffer);
      let title = resultBuffer.trim();
      debug2("Extracted title before sanitization:", title);
      title = title.replace(/[\\/:]/g, "").trim();
      debug2("Sanitized title:", title);
      if (title && typeof title === "string" && title.length > 0) {
        const outputMode = (_a2 = settings.titleOutputMode) != null ? _a2 : "clipboard";
        debug2("Output mode:", outputMode);
        if (outputMode === "replace-filename") {
          const file = app.workspace.getActiveFile();
          if (file) {
            const ext = file.extension ? "." + file.extension : "";
            const sanitized = title;
            const parentPath = file.parent ? file.parent.path : "";
            const newPath = parentPath ? parentPath + "/" + sanitized + ext : sanitized + ext;
            if (file.path !== newPath) {
              await app.fileManager.renameFile(file, newPath);
              new import_obsidian28.Notice(`Note renamed to: ${sanitized}${ext}`);
            } else {
              new import_obsidian28.Notice(`Note title is already: ${sanitized}${ext}`);
            }
          }
        } else if (outputMode === "metadata") {
          const file = app.workspace.getActiveFile();
          if (file) {
            await upsertYamlField(app, file, "title", title);
            new import_obsidian28.Notice(`Inserted title into metadata: ${title}`);
          }
        } else {
          try {
            await navigator.clipboard.writeText(title);
            new import_obsidian28.Notice(`Generated title (copied): ${title}`);
          } catch (e) {
            new import_obsidian28.Notice(`Generated title: ${title}`);
          }
        }
      } else {
        debug2("No title generated after sanitization.");
        new import_obsidian28.Notice("No title generated.");
      }
    } catch (processError) {
      debug2("Error in processMessages or provider.getCompletion:", processError);
      settings.enableContextNotes = originalEnableContextNotes;
      throw processError;
    }
  } catch (err) {
    new import_obsidian28.Notice("Error generating title: " + ((_b = err == null ? void 0 : err.message) != null ? _b : err));
  }
}
async function generateYamlAttribute(app, settings, processMessages2, attributeName, prompt, outputMode = "metadata") {
  debug2(`Starting generateYamlAttribute for ${attributeName}`);
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian28.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const messages = [
    { role: "system", content: DEFAULT_YAML_SYSTEM_MESSAGE },
    { role: "user", content: prompt + "\n\n" + noteContent }
  ];
  debug2("Original messages:", JSON.stringify(messages));
  const originalEnableContextNotes = settings.enableContextNotes;
  debug2("Original enableContextNotes:", originalEnableContextNotes);
  settings.enableContextNotes = false;
  try {
    const processedMessages = await processMessages2(messages);
    debug2("Processed messages:", JSON.stringify(processedMessages));
    settings.enableContextNotes = originalEnableContextNotes;
    if (!processedMessages || processedMessages.length === 0) {
      debug2("No processed messages!");
      new import_obsidian28.Notice("No valid messages to send to the model. Please check your note content.");
      return;
    }
    debug2("Calling provider.getCompletion");
    const provider = settings.selectedModel ? createProviderFromUnifiedModel(settings, settings.selectedModel) : createProvider(settings);
    let resultBuffer = "";
    await provider.getCompletion(processedMessages, {
      temperature: 0,
      streamCallback: (chunk) => {
        resultBuffer += chunk;
      }
    });
    debug2("Result from provider (buffered):", resultBuffer);
    let value = resultBuffer.trim();
    debug2("Extracted value before sanitization:", value);
    value = value.replace(/[\\/]/g, "").trim();
    debug2("Sanitized value:", value);
    if (value && typeof value === "string" && value.length > 0) {
      debug2("Output mode:", outputMode);
      if (outputMode === "metadata") {
        await upsertYamlField(app, activeFile, attributeName, value);
        new import_obsidian28.Notice(`Inserted ${attributeName} into metadata: ${value}`);
      } else {
        try {
          await navigator.clipboard.writeText(value);
          new import_obsidian28.Notice(`Generated ${attributeName} (copied): ${value}`);
        } catch (e) {
          new import_obsidian28.Notice(`Generated ${attributeName}: ${value}`);
        }
      }
    } else {
      debug2(`No value generated for ${attributeName} after sanitization.`);
      new import_obsidian28.Notice(`No value generated for ${attributeName}.`);
    }
  } catch (processError) {
    debug2("Error in processMessages or provider.getCompletion:", processError);
    settings.enableContextNotes = originalEnableContextNotes;
    throw processError;
  }
}
async function upsertYamlField(app, file, field, value) {
  let content = await app.vault.read(file);
  let newContent = content;
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  if (match) {
    let yamlObj = {};
    try {
      yamlObj = load(match[1]) || {};
    } catch (e) {
      yamlObj = {};
    }
    yamlObj[field] = value;
    const newYaml = dump(yamlObj, { lineWidth: -1 }).trim();
    newContent = content.replace(frontmatterRegex, `---
${newYaml}
---`);
  } else {
    const newYaml = dump({ [field]: value }, { lineWidth: -1 }).trim();
    newContent = `---
${newYaml}
---
` + content;
  }
  await app.vault.modify(file, newContent);
}
function registerYamlAttributeCommands(plugin, settings, processMessages2, yamlAttributeCommandIds, debugLog2) {
  debugLog2("debug", "[YAMLHandler.ts] registerYamlAttributeCommands called");
  if (yamlAttributeCommandIds && yamlAttributeCommandIds.length > 0) {
    for (const id of yamlAttributeCommandIds) {
      plugin.app.commands.removeCommand(id);
      debugLog2("debug", "[YAMLHandler.ts] Removed previous YAML command", { id });
    }
  }
  const newCommandIds = [];
  if (settings.yamlAttributeGenerators && Array.isArray(settings.yamlAttributeGenerators)) {
    for (const gen of settings.yamlAttributeGenerators) {
      if (!gen.attributeName || !gen.prompt || !gen.commandName) continue;
      const id = `generate-yaml-attribute-${gen.attributeName}`;
      debugLog2("debug", "[YAMLHandler.ts] Registering YAML attribute command", { id, gen });
      registerCommand(plugin, {
        id,
        name: gen.commandName,
        callback: async () => {
          await generateYamlAttribute(
            plugin.app,
            settings,
            processMessages2,
            gen.attributeName,
            gen.prompt,
            gen.outputMode
          );
        }
      });
      newCommandIds.push(id);
    }
  }
  return newCommandIds;
}
var import_obsidian28, DEBUG;
var init_YAMLHandler = __esm({
  "src/YAMLHandler.ts"() {
    import_obsidian28 = require("obsidian");
    init_providers();
    init_promptConstants();
    init_pluginUtils();
    init_js_yaml();
    DEBUG = true;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian35 = require("obsidian");
init_types();

// src/settings/SettingTab.ts
var import_obsidian33 = require("obsidian");

// src/components/commands/viewCommands.ts
init_pluginUtils();

// src/utils/viewManager.ts
async function activateView(app, viewType, reveal = true) {
  app.workspace.detachLeavesOfType(viewType);
  let leaf = app.workspace.getRightLeaf(false) || app.workspace.getLeaf(true);
  await leaf.setViewState({
    type: viewType,
    active: true
  });
  if (reveal) {
    app.workspace.revealLeaf(leaf);
  }
}

// src/chat.ts
var import_obsidian27 = require("obsidian");

// src/components/chat/ChatHistoryManager.ts
var import_obsidian11 = require("obsidian");
var ChatHistoryManager = class {
  constructor(vault, pluginId, historyFilePath) {
    __publicField(this, "vault");
    __publicField(this, "historyFilePath");
    __publicField(this, "history", []);
    __publicField(this, "isLoaded", false);
    this.vault = vault;
    let effectivePluginId = pluginId;
    if (!pluginId) {
      console.error("CRITICAL: ChatHistoryManager instantiated without pluginId! Using placeholder. This will likely lead to incorrect file paths.");
      effectivePluginId = "unknown-plugin-id-error";
    }
    const fPath = historyFilePath || "chat-history.json";
    this.historyFilePath = (0, import_obsidian11.normalizePath)(`.obsidian/plugins/${effectivePluginId}/${fPath}`);
    if (typeof window !== "undefined" && window.Notice) {
    }
  }
  async ensureDirectoryExists() {
    const dirPath = this.historyFilePath.substring(0, this.historyFilePath.lastIndexOf("/"));
    if (!dirPath) return;
    try {
      const abstractFile = this.vault.getAbstractFileByPath(dirPath);
      if (abstractFile === null) {
        await this.vault.createFolder(dirPath);
      } else if (!(abstractFile instanceof import_obsidian11.TFolder)) {
        console.error(`Path ${dirPath} exists but is not a folder.`);
        throw new Error(`Path ${dirPath} exists but is not a folder.`);
      }
    } catch (e) {
      if (e.message && e.message.toLowerCase().includes("folder already exists")) {
        return;
      }
      console.error(`Failed to ensure directory ${dirPath} exists:`, e);
      throw e;
    }
  }
  async loadHistory() {
    try {
      const exists = await this.vault.adapter.exists(this.historyFilePath);
      if (exists) {
        const data = await this.vault.adapter.read(this.historyFilePath);
        try {
          this.history = JSON.parse(data);
        } catch (parseError) {
          console.error("Failed to parse chat history:", parseError);
          this.history = [];
        }
      } else {
        this.history = [];
      }
    } catch (e) {
      console.error("Failed to load chat history:", e);
      this.history = [];
    }
    return this.history;
  }
  async addMessage(message) {
    const currentHistory = await this.loadHistory();
    currentHistory.push(message);
    this.history = currentHistory;
    await this.saveHistory();
  }
  async getHistory() {
    return await this.loadHistory();
  }
  async clearHistory() {
    this.history = [];
    await this.saveHistory();
  }
  async deleteMessage(timestamp2, sender, content) {
    await this.loadHistory();
    const index = this.history.findIndex(
      (msg) => msg.timestamp === timestamp2 && msg.sender === sender && msg.content === content
    );
    if (index !== -1) {
      this.history.splice(index, 1);
      await this.saveHistory();
    }
  }
  async updateMessage(timestamp2, sender, oldContent, newContent, enhancedData) {
    await this.loadHistory();
    const message = this.history.find(
      (msg) => msg.timestamp === timestamp2 && msg.sender === sender && msg.content === oldContent
    );
    if (message) {
      message.content = newContent;
      if (enhancedData) {
        if ("reasoning" in enhancedData) message.reasoning = enhancedData.reasoning;
        if ("taskStatus" in enhancedData) message.taskStatus = enhancedData.taskStatus;
        if ("toolResults" in enhancedData) message.toolResults = enhancedData.toolResults;
      }
      await this.saveHistory();
    } else {
    }
  }
  async saveHistory() {
    try {
      await this.ensureDirectoryExists();
      const data = JSON.stringify(this.history, null, 2);
      const abstractTarget = this.vault.getAbstractFileByPath(this.historyFilePath);
      if (abstractTarget instanceof import_obsidian11.TFolder) {
        throw new Error(`Path ${this.historyFilePath} is a directory, not a file.`);
      }
      await this.vault.adapter.write(this.historyFilePath, data);
      if (!abstractTarget || !(abstractTarget instanceof import_obsidian11.TFile)) {
        await this.vault.adapter.exists(this.historyFilePath);
      }
    } catch (e) {
      console.error(`Failed to save history to ${this.historyFilePath}:`, e);
      throw e;
    }
  }
};

// src/components/chat/Message.ts
var import_obsidian21 = require("obsidian");
init_Buttons();
init_MessageRenderer();
init_eventHandlers();
async function createMessageElement(app, role, content, chatHistoryManager, plugin, regenerateCallback, parentComponent, messageData) {
  const messageEl = document.createElement("div");
  messageEl.addClass("ai-chat-message", role);
  const messageContainer = messageEl.createDiv("message-container");
  messageEl.dataset.rawContent = content;
  messageEl.dataset.timestamp = (/* @__PURE__ */ new Date()).toISOString();
  if (messageData) {
    messageEl.dataset.messageData = JSON.stringify(messageData);
  }
  const messageRenderer = new MessageRenderer(app);
  let contentEl = null;
  if (role === "assistant") {
    if (messageData && (messageData.reasoning || messageData.taskStatus)) {
      messageRenderer.updateMessageWithEnhancedData(messageEl, {
        ...messageData,
        role: "assistant",
        content
      }, parentComponent);
    }
    if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
      contentEl = messageEl.querySelector(".message-content");
      if (!contentEl) {
        contentEl = messageContainer.createDiv("message-content");
      }
      await messageRenderer.renderMessage({
        ...messageData,
        role: "assistant",
        content
      }, messageEl, parentComponent);
    } else if (!(messageData == null ? void 0 : messageData.reasoning) && !(messageData == null ? void 0 : messageData.taskStatus)) {
      contentEl = messageEl.querySelector(".message-content");
      if (!contentEl) {
        contentEl = messageContainer.createDiv("message-content");
      }
      await import_obsidian21.MarkdownRenderer.render(app, content, contentEl, "", parentComponent);
    }
  } else {
    contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) {
      contentEl = messageContainer.createDiv("message-content");
    }
    await import_obsidian21.MarkdownRenderer.render(app, content, contentEl, "", parentComponent);
  }
  if (!contentEl) {
    contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) {
      contentEl = messageContainer.createDiv("message-content");
    }
  }
  const actionsEl = messageContainer.createDiv("message-actions");
  actionsEl.classList.add("hidden");
  messageEl.addEventListener("mouseenter", () => {
    actionsEl.classList.remove("hidden");
    actionsEl.classList.add("visible");
  });
  messageEl.addEventListener("mouseleave", () => {
    actionsEl.classList.remove("visible");
    actionsEl.classList.add("hidden");
  });
  actionsEl.appendChild(createActionButton("Copy", "Copy message (including tool results)", handleCopyMessage(messageEl, plugin)));
  actionsEl.appendChild(createActionButton("Edit", "Edit message", handleEditMessage(messageEl, chatHistoryManager, plugin)));
  actionsEl.appendChild(createActionButton("Delete", "Delete message", handleDeleteMessage(messageEl, chatHistoryManager, app)));
  if (role === "assistant") {
    actionsEl.appendChild(createActionButton("Regenerate", "Regenerate this response", handleRegenerateMessage(messageEl, regenerateCallback)));
  }
  messageContainer.appendChild(actionsEl);
  return messageEl;
}

// src/components/chat/ui.ts
function createChatUI(app, contentEl) {
  const fadedHelp = contentEl.createDiv();
  fadedHelp.setText("Tip: Type /help or press Ctrl+Shift+H for chat commands and shortcuts. Use Ctrl+Shift+X to clear chat and Ctrl+Shift+C to copy.");
  fadedHelp.style.textAlign = "center";
  fadedHelp.style.opacity = "0.6";
  fadedHelp.style.fontSize = "0.95em";
  fadedHelp.style.margin = "0.5em 0 0.2em 0";
  const topButtonContainer = contentEl.createDiv("ai-chat-buttons");
  const settingsButton = document.createElement("button");
  settingsButton.setText("Settings");
  settingsButton.setAttribute("aria-label", "Toggle model settings");
  topButtonContainer.appendChild(settingsButton);
  const copyAllButton = document.createElement("button");
  copyAllButton.textContent = "Copy All";
  topButtonContainer.appendChild(copyAllButton);
  const saveNoteButton = document.createElement("button");
  saveNoteButton.textContent = "Save as Note";
  topButtonContainer.appendChild(saveNoteButton);
  const clearButton = document.createElement("button");
  clearButton.textContent = "Clear Chat";
  topButtonContainer.appendChild(clearButton);
  const referenceNoteButton = document.createElement("button");
  referenceNoteButton.setText("\u{1F4DD}");
  referenceNoteButton.setAttribute("aria-label", "Toggle referencing current note");
  referenceNoteButton.addClass("ai-chat-reference-button");
  referenceNoteButton.style.fontSize = "0.85em";
  referenceNoteButton.style.fontFamily = "inherit";
  referenceNoteButton.style.width = "1.8em";
  referenceNoteButton.style.height = "1.8em";
  referenceNoteButton.style.marginBottom = "0.2em";
  referenceNoteButton.style.opacity = "0.7";
  topButtonContainer.appendChild(referenceNoteButton);
  const referenceNoteIndicator = document.createElement("div");
  referenceNoteIndicator.className = "ai-reference-note-indicator";
  referenceNoteIndicator.style.textAlign = "center";
  referenceNoteIndicator.style.opacity = "0.5";
  referenceNoteIndicator.style.fontSize = "0.85em";
  referenceNoteIndicator.style.margin = "0.1em 0 0.2em 0";
  referenceNoteIndicator.style.display = "none";
  topButtonContainer.appendChild(referenceNoteIndicator);
  const modelNameDisplay = document.createElement("div");
  modelNameDisplay.className = "ai-model-name-display";
  modelNameDisplay.style.textAlign = "center";
  modelNameDisplay.style.opacity = "0.7";
  modelNameDisplay.style.fontSize = "0.75em";
  modelNameDisplay.style.margin = "0.2em 0 0.5em 0";
  modelNameDisplay.style.fontWeight = "bold";
  topButtonContainer.appendChild(modelNameDisplay);
  const messagesContainer = contentEl.createDiv("ai-chat-messages");
  messagesContainer.setAttribute("tabindex", "0");
  const toolContinuationContainer = contentEl.createDiv("ai-tool-continuation-container");
  toolContinuationContainer.style.display = "none";
  const inputContainer = contentEl.createDiv("ai-chat-input-container");
  const textarea = inputContainer.createEl("textarea", {
    cls: "ai-chat-input",
    attr: {
      placeholder: "Type your message...",
      rows: "3"
    }
  });
  const sendButton = inputContainer.createEl("button", {
    text: "Send",
    cls: "mod-cta"
  });
  const stopButton = inputContainer.createEl("button", {
    text: "Stop"
  });
  stopButton.classList.add("hidden");
  const helpButton = inputContainer.createEl("button", {
    text: "?"
  });
  helpButton.setAttr("aria-label", "Show chat help");
  helpButton.style.fontSize = "0.9em";
  helpButton.style.width = "1.8em";
  helpButton.style.height = "1.8em";
  helpButton.style.marginBottom = "0.2em";
  helpButton.style.opacity = "0.7";
  helpButton.style.position = "absolute";
  helpButton.style.right = "0.5em";
  helpButton.style.top = "-2.2em";
  helpButton.style.zIndex = "2";
  const agentModeButton = inputContainer.createEl("button", {
    text: "\u{1F916}"
  });
  agentModeButton.setAttr("aria-label", "Toggle Agent Mode");
  agentModeButton.style.fontSize = "0.9em";
  agentModeButton.style.width = "1.8em";
  agentModeButton.style.height = "1.8em";
  agentModeButton.style.marginBottom = "0.2em";
  agentModeButton.style.opacity = "0.7";
  agentModeButton.style.position = "absolute";
  agentModeButton.style.right = "2.8em";
  agentModeButton.style.top = "-2.2em";
  agentModeButton.style.zIndex = "2";
  agentModeButton.classList.add("ai-agent-mode-btn");
  function setAgentModeActive(isActive) {
    if (isActive) {
      agentModeButton.classList.add("active");
    } else {
      agentModeButton.classList.remove("active");
    }
  }
  agentModeButton.setActive = setAgentModeActive;
  inputContainer.appendChild(agentModeButton);
  inputContainer.style.position = "relative";
  [topButtonContainer.querySelectorAll("button")].forEach((btns) => {
    btns.forEach((btn) => {
      btn.style.fontSize = "0.85em";
      btn.style.fontFamily = "inherit";
    });
  });
  return {
    contentEl,
    fadedHelp,
    topButtonContainer,
    settingsButton,
    copyAllButton,
    saveNoteButton,
    clearButton,
    messagesContainer,
    toolContinuationContainer,
    inputContainer,
    textarea,
    sendButton,
    stopButton,
    helpButton,
    agentModeButton,
    // <-- add to return object
    referenceNoteButton,
    referenceNoteIndicator,
    modelNameDisplay
    // Add to return object
  };
}

// src/chat.ts
init_eventHandlers();
init_chatPersistence();

// src/components/chat/chatHistoryUtils.ts
init_MessageRenderer();
async function renderChatHistory({
  messagesContainer,
  loadedHistory,
  chatHistoryManager,
  plugin,
  regenerateResponse,
  scrollToBottom = true
}) {
  messagesContainer.empty();
  const renderer = new MessageRenderer(plugin.app);
  for (const msg of loadedHistory) {
    if (msg.sender === "user" || msg.sender === "assistant") {
      const toolData = renderer.parseToolDataFromContent(msg.content);
      let messageData = msg;
      let cleanContent = msg.content;
      if (toolData) {
        messageData = {
          ...msg,
          toolResults: toolData.toolResults,
          reasoning: toolData.reasoning,
          taskStatus: toolData.taskStatus
        };
        cleanContent = renderer.cleanContentFromToolData(msg.content);
        messageData.content = cleanContent;
      }
      const messageEl = await createMessageElement(
        plugin.app,
        msg.sender,
        cleanContent,
        chatHistoryManager,
        plugin,
        regenerateResponse,
        plugin,
        // parentComponent
        messageData
        // Pass enhanced message object with tool results
      );
      messageEl.dataset.timestamp = msg.timestamp;
      messagesContainer.appendChild(messageEl);
    }
  }
  if (scrollToBottom) {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

// src/components/chat/CommandParser.ts
init_toolcollect();
var CommandParser = class {
  constructor(plugin) {
    this.plugin = plugin;
    __publicField(this, "validActions");
    this.validActions = getAllToolNames();
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Constructor - Valid actions loaded:", this.validActions);
    }
  }
  /**
   * Parse AI response to extract tool commands and regular text
   * @param response The AI response string
   * @returns Object containing separated text and commands
   */
  parseResponse(response) {
    const commands = [];
    let cleanText = response;
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Parsing response:", response);
      this.plugin.debugLog("debug", "[CommandParser] Valid actions:", this.validActions);
    }
    const extractedCommands = this.extractCommands(response);
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Extracted commands:", extractedCommands);
    }
    for (const command of extractedCommands) {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Validating command:", command.command);
      }
      if (this.validateCommand(command.command)) {
        if (this.plugin) {
          this.plugin.debugLog("debug", "[CommandParser] Command is valid, adding to commands");
        }
        commands.push(command.command);
        cleanText = cleanText.replace(command.originalText, "").trim();
      } else {
        if (this.plugin) {
          this.plugin.debugLog("debug", "[CommandParser] Command is invalid");
        }
      }
    }
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Final commands:", commands);
    }
    return {
      text: cleanText,
      commands
    };
  }
  /**
   * Validate that a command has the required structure
   * @param command The command to validate
   * @returns True if command is valid
   */
  validateCommand(command) {
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] validateCommand called with:", command);
    }
    if (!command || typeof command !== "object") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command is not an object");
      }
      return false;
    }
    if (!command.action || typeof command.action !== "string") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command missing action field:", command.action);
      }
      return false;
    }
    if (!command.parameters || typeof command.parameters !== "object") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command missing parameters field:", command.parameters);
      }
      return false;
    }
    if (!this.validActions.includes(command.action)) {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command action not in valid actions:", command.action, "Valid actions:", this.validActions);
      }
      return false;
    }
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Command is valid");
    }
    return true;
  }
  /**
   * Extract JSON commands from text
   * @param text The text to extract commands from
   * @returns Array of extracted commands with their original text
   */
  extractCommands(text) {
    var _a2, _b;
    const commands = [];
    try {
      const parsed = JSON.parse(text.trim());
      if (parsed.action) {
        let parameters = parsed.parameters;
        if (!parameters) {
          parameters = { ...parsed };
          delete parameters.action;
          delete parameters.requestId;
        }
        commands.push({
          command: {
            action: parsed.action,
            parameters,
            requestId: parsed.requestId || this.generateRequestId(),
            finished: parsed.finished || false
          },
          originalText: text.trim()
        });
        return commands;
      } else if (parsed.thought && parsed.nextTool) {
        commands.push({
          command: {
            action: "thought",
            parameters: {
              thought: parsed.thought,
              nextTool: parsed.nextTool,
              nextActionDescription: parsed.nextActionDescription,
              step: parsed.step,
              totalSteps: parsed.totalSteps
            },
            requestId: this.generateRequestId(),
            finished: ((_a2 = parsed.nextTool) == null ? void 0 : _a2.toLowerCase()) === "finished"
          },
          originalText: text.trim()
        });
        return commands;
      }
    } catch (error) {
    }
    const patterns = [
      /```json\s*(\{[\s\S]*?\})\s*```/g,
      // JSON in code blocks
      /```\s*(\{[\s\S]*?\})\s*```/g,
      // JSON in generic code blocks
      /(\{[\s\S]*?\})/g
      // Any JSON-like objects
    ];
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const jsonText = match[1];
        const originalText = match[0];
        try {
          const parsed = JSON.parse(jsonText);
          if (parsed.action) {
            let parameters = parsed.parameters;
            if (!parameters) {
              parameters = { ...parsed };
              delete parameters.action;
              delete parameters.requestId;
            }
            commands.push({
              command: {
                action: parsed.action,
                parameters,
                requestId: parsed.requestId || this.generateRequestId(),
                finished: parsed.finished || false
              },
              originalText
            });
          } else if (parsed.thought && parsed.nextTool) {
            commands.push({
              command: {
                action: "thought",
                parameters: {
                  thought: parsed.thought,
                  nextTool: parsed.nextTool,
                  nextActionDescription: parsed.nextActionDescription,
                  step: parsed.step,
                  totalSteps: parsed.totalSteps
                },
                requestId: this.generateRequestId(),
                finished: ((_b = parsed.nextTool) == null ? void 0 : _b.toLowerCase()) === "finished"
              },
              originalText
            });
          }
        } catch (error) {
          continue;
        }
      }
      pattern.lastIndex = 0;
    }
    return commands;
  }
  /**
   * Generate a unique request ID
   * @returns A unique request ID string
   */
  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/components/chat/agent/ToolRegistry.ts
var ToolRegistry = class {
  constructor(plugin) {
    __publicField(this, "tools", /* @__PURE__ */ new Map());
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  register(tool) {
    this.tools.set(tool.name, tool);
    if (this.plugin && this.plugin.settings && this.plugin.settings.debugMode) {
      this.plugin.debugLog("[ToolRegistry] Registering tool", { tool });
    }
  }
  async execute(command) {
    const tool = this.tools.get(command.action);
    if (!tool) {
      if (this.plugin && this.plugin.settings && this.plugin.settings.debugMode) {
        this.plugin.debugLog("[ToolRegistry] Tool not found", { action: command.action });
      }
      return {
        success: false,
        error: `Tool not found: ${command.action}`,
        requestId: command.requestId
      };
    }
    try {
      if (this.plugin && this.plugin.settings && this.plugin.settings.debugMode) {
        this.plugin.debugLog("[ToolRegistry] Executing tool", { command });
      }
      const result = await tool.execute(command.parameters, {});
      if (this.plugin && this.plugin.settings && this.plugin.settings.debugMode) {
        this.plugin.debugLog("[ToolRegistry] Tool execution result", { command, result });
      }
      return {
        ...result,
        requestId: command.requestId
      };
    } catch (error) {
      if (this.plugin && this.plugin.settings && this.plugin.settings.debugMode) {
        this.plugin.debugLog("[ToolRegistry] Tool execution error", { command, error });
      }
      return {
        success: false,
        error: error.message || String(error),
        requestId: command.requestId
      };
    }
  }
  getAvailableTools() {
    return Array.from(this.tools.values());
  }
};

// src/components/chat/agent/AgentResponseHandler/AgentResponseHandler.ts
init_ToolRichDisplay();
init_toolcollect();

// src/components/chat/agent/AgentResponseHandler/constants.ts
var CONSTANTS = {
  NOTIFICATION_DISPLAY_DELAY: 100,
  NOTIFICATION_AUTO_REMOVE_DELAY: 5e3,
  NOTIFICATION_FADE_DELAY: 300,
  MAX_ADDITIONAL_TOOLS: 100,
  // Maximum additional tools that can be added
  REASONING_ID_PREFIX: "reasoning-",
  TOOL_DISPLAY_ID_SEPARATOR: "-",
  ERROR_MESSAGES: {
    TOOL_EXECUTION_FAILED: "Tool execution failed",
    TOOL_EXECUTION_TIMEOUT: "Tool execution timed out",
    COPY_FAILED: "Failed to copy tool result",
    RERUN_FAILED: "Failed to re-run tool"
  },
  JSON_INDENT: 2,
  MD_EXTENSION: ".md",
  PATH_SEPARATOR: "/",
  COMMAND_KEY_SEPARATOR: ":"
};

// src/components/chat/agent/AgentResponseHandler/utils.ts
function normalizePath2(path) {
  return path.replace(/\\/g, CONSTANTS.PATH_SEPARATOR);
}
function stringifyJson(obj) {
  return JSON.stringify(obj, null, CONSTANTS.JSON_INDENT);
}

// src/components/chat/agent/AgentResponseHandler/TaskNotificationManager.ts
var TaskNotificationManager = class {
  constructor(context) {
    __publicField(this, "context");
    this.context = context;
  }
  createTaskCompletionNotification(message, type2 = "success") {
    const notification = document.createElement("div");
    notification.className = `task-completion-notification ${type2}`;
    const icon = this.getNotificationIcon(type2);
    notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <span>${icon}</span>
                <span>${message}</span>
            </div>
        `;
    this.setupNotificationAutoRemoval(notification);
    return notification;
  }
  showTaskCompletionNotification(message, type2 = "success") {
    var _a2;
    if (!((_a2 = this.context.plugin.settings.uiBehavior) == null ? void 0 : _a2.showCompletionNotifications)) {
      return;
    }
    const notification = this.createTaskCompletionNotification(message, type2);
    document.body.appendChild(notification);
  }
  updateTaskProgress(current, total, description) {
  }
  hideTaskProgress() {
  }
  getNotificationIcon(type2) {
    const icons = {
      success: "\u2705",
      error: "\u274C",
      warning: "\u26A0\uFE0F"
    };
    return icons[type2];
  }
  setupNotificationAutoRemoval(notification) {
    setTimeout(() => {
      notification.classList.add("show");
    }, CONSTANTS.NOTIFICATION_DISPLAY_DELAY);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), CONSTANTS.NOTIFICATION_FADE_DELAY);
    }, CONSTANTS.NOTIFICATION_AUTO_REMOVE_DELAY);
  }
};

// src/components/chat/agent/AgentResponseHandler/ToolResultFormatter.ts
var ToolResultFormatter = class {
  getStatusIcon(success, style) {
    if (success) {
      return style === "markdown" ? "\u2705" : style === "copy" ? "SUCCESS" : "\u2713";
    } else {
      return style === "markdown" ? "\u274C" : style === "copy" ? "ERROR" : "\u2717";
    }
  }
  formatToolResult(command, result, opts) {
    const style = (opts == null ? void 0 : opts.style) || "plain";
    const status = this.getStatusIcon(result.success, style);
    const action = command.action.replace("_", " ");
    const context = this.getResultContext(command, result);
    switch (style) {
      case "markdown":
        return `${status} **${action}** completed successfully${context}`;
      case "copy":
        return this.formatToolResultForCopy(command, result, status);
      default:
        return this.formatToolResultPlain(command, result, status);
    }
  }
  getResultContext(command, result) {
    var _a2;
    if (!result.success || !result.data) return "";
    switch (command.action) {
      case "file_write":
      case "file_read":
      case "file_diff":
        if (result.data.filePath) {
          return ` [[${result.data.filePath}]]`;
        }
        break;
      case "file_select":
        if (result.data.count !== void 0) {
          return ` [[${result.data.count} files found]]`;
        }
        break;
      case "thought":
        if ((_a2 = result.data) == null ? void 0 : _a2.formattedThought) {
          return result.data.formattedThought;
        }
        break;
    }
    return "";
  }
  formatToolResultForCopy(command, result, status) {
    const params = stringifyJson(command.parameters);
    const resultData = result.success ? stringifyJson(result.data) : result.error;
    return `TOOL EXECUTION: ${command.action}
STATUS: ${status}
PARAMETERS:
${params}
RESULT:
${resultData}`;
  }
  formatToolResultPlain(command, result, status) {
    const data = result.success ? stringifyJson(result.data) : result.error;
    return `${status} Tool: ${command.action}
Parameters: ${stringifyJson(command.parameters)}
Result: ${data}`;
  }
  formatToolResultsForDisplay(toolResults) {
    if (toolResults.length === 0) {
      return "";
    }
    const resultText = toolResults.map(
      ({ command, result }) => this.formatToolResult(command, result, { style: "markdown" })
    ).join("\n");
    return `

**Tool Execution:**
${resultText}`;
  }
  createToolResultMessage(toolResults) {
    if (toolResults.length === 0) {
      return null;
    }
    const resultText = toolResults.map(
      ({ command, result }) => this.formatToolResult(command, result, { style: "plain" })
    ).join("\n\n");
    return {
      role: "system",
      content: `Tool execution results:

${resultText}`
    };
  }
};

// src/components/chat/agent/AgentResponseHandler/ToolExecutor.ts
var ToolExecutor = class {
  constructor(toolRegistry, onToolResult, createToolDisplay) {
    __publicField(this, "toolRegistry");
    __publicField(this, "executionCount", 0);
    __publicField(this, "onToolResult");
    __publicField(this, "createToolDisplay");
    this.toolRegistry = toolRegistry;
    this.onToolResult = onToolResult;
    this.createToolDisplay = createToolDisplay;
  }
  async executeToolWithLogging(command, timeoutMs, contextLabel, debugLog2) {
    const startTime = Date.now();
    if (debugLog2) debugLog2("Executing tool", { command }, contextLabel);
    const result = await this.executeToolWithTimeout(command, timeoutMs);
    const executionTime = Date.now() - startTime;
    if (debugLog2) debugLog2("Tool execution result", { command, result, executionTime }, contextLabel);
    return result;
  }
  async executeToolWithTimeout(command, timeoutMs) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_TIMEOUT} after ${timeoutMs}ms`));
      }, timeoutMs);
      this.toolRegistry.execute(command).then((result) => {
        clearTimeout(timeout);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  handleToolExecutionSuccess(command, result, toolResults) {
    toolResults.push({ command, result });
    this.executionCount++;
    this.createToolDisplay(command, result);
    this.onToolResult(result, command);
  }
  handleToolExecutionError(command, error, toolResults, contextLabel, debugLog2) {
    if (debugLog2) debugLog2("Tool execution error", { command, error }, contextLabel);
    console.error(`ToolExecutor: Tool '${command.action}' failed with error:`, error);
    const errorResult = this.createErrorResult(command, error);
    this.handleToolExecutionSuccess(command, errorResult, toolResults);
  }
  createErrorResult(command, error) {
    return {
      success: false,
      error: `${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_FAILED}: ${error.message}`,
      requestId: command.requestId
    };
  }
  async rerunTool(originalCommand, timeoutMs) {
    try {
      const result = await this.executeToolWithTimeout(originalCommand, timeoutMs);
      this.createToolDisplay(originalCommand, result);
      this.onToolResult(result, originalCommand);
    } catch (error) {
      console.error(`${CONSTANTS.ERROR_MESSAGES.RERUN_FAILED} ${originalCommand.action}:`, error);
    }
  }
  getExecutionCount() {
    return this.executionCount;
  }
  resetExecutionCount() {
    this.executionCount = 0;
  }
};

// src/components/chat/agent/AgentResponseHandler/ReasoningProcessor.ts
var ReasoningProcessor = class {
  constructor(context) {
    __publicField(this, "context");
    this.context = context;
  }
  processToolResultsForMessage(toolResults) {
    const toolExecutionResults = toolResults.map(({ command, result }) => ({
      command,
      result,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }));
    let reasoning;
    for (const { command, result } of toolResults) {
      if (command.action === "thought" && result.success && result.data) {
        reasoning = this.convertThoughtToolResultToReasoning(result.data);
        break;
      }
    }
    return {
      reasoning,
      toolExecutionResults
    };
  }
  convertThoughtToolResultToReasoning(thoughtData) {
    var _a2;
    const reasoningId = this.generateReasoningId();
    const baseData = {
      id: reasoningId,
      timestamp: thoughtData.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
      isCollapsed: ((_a2 = this.context.plugin.settings.uiBehavior) == null ? void 0 : _a2.collapseOldReasoning) || false
    };
    if (thoughtData.reasoning === "structured" && thoughtData.steps) {
      return {
        ...baseData,
        type: "structured",
        problem: thoughtData.problem,
        steps: thoughtData.steps.map((step) => ({
          step: step.step,
          title: step.title,
          content: step.content
        })),
        depth: thoughtData.depth
      };
    } else {
      return {
        ...baseData,
        type: "simple",
        summary: thoughtData.thought || thoughtData.formattedThought
      };
    }
  }
  generateReasoningId() {
    const timestamp2 = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `reasoning-${timestamp2}-${random}`;
  }
};

// src/components/chat/agent/AgentResponseHandler/ToolLimitWarningUI.ts
var ToolLimitWarningUI = class {
  constructor(context) {
    __publicField(this, "context");
    this.context = context;
  }
  createToolLimitWarning() {
    const warning = document.createElement("div");
    warning.className = "tool-limit-warning";
    const agentSettings = this.context.plugin.getAgentModeSettings();
    const effectiveLimit = this.getEffectiveToolLimit();
    const executionCount = this.context.getExecutionCount();
    warning.innerHTML = this.createToolLimitWarningHTML(executionCount, effectiveLimit, agentSettings.maxToolCalls);
    this.attachToolLimitWarningHandlers(warning, agentSettings);
    return warning;
  }
  createToolLimitWarningHTML(executionCount, effectiveLimit, maxToolCalls) {
    return `
            <div class="tool-limit-warning-text">
                <strong>\u26A0\uFE0F Tool execution limit reached</strong><br>
                Used ${executionCount}/${effectiveLimit} tool calls. 
                Choose how to proceed:
            </div>
            <div class="tool-limit-warning-actions">
                <div class="tool-limit-input-group">
                    <label for="additional-tools">Add more executions:</label>
                    <input type="number" id="additional-tools" min="1" max="${CONSTANTS.MAX_ADDITIONAL_TOOLS}" value="${maxToolCalls}" placeholder="5">
                    <button class="ai-chat-add-tools-button">Add & Continue</button>
                </div>
                <div class="tool-limit-button-group">
                    <button class="ai-chat-continue-button">Reset & Continue</button>
                    <span class="tool-limit-settings-link">Open Settings</span>
                </div>
            </div>
        `;
  }
  attachToolLimitWarningHandlers(warning, agentSettings) {
    this.attachSettingsHandler(warning);
    this.attachAddToolsHandler(warning, agentSettings);
    this.attachContinueHandler(warning);
  }
  attachSettingsHandler(warning) {
    const settingsLink = warning.querySelector(".tool-limit-settings-link");
    if (settingsLink) {
      settingsLink.onclick = () => {
        this.context.app.setting.open();
        this.context.app.setting.openTabById(this.context.plugin.manifest.id);
      };
    }
  }
  attachAddToolsHandler(warning, agentSettings) {
    const addToolsButton = warning.querySelector(".ai-chat-add-tools-button");
    if (addToolsButton) {
      addToolsButton.onclick = () => {
        const input = warning.querySelector("#additional-tools");
        const additionalTools = parseInt(input.value) || agentSettings.maxToolCalls;
        if (additionalTools > 0) {
          this.context.addToolExecutions(additionalTools);
          this.removeWarningAndTriggerContinuation(warning, "continueTaskWithAdditionalTools", { additionalTools });
        }
      };
    }
  }
  attachContinueHandler(warning) {
    const continueButton = warning.querySelector(".ai-chat-continue-button");
    if (continueButton) {
      continueButton.onclick = () => {
        this.context.resetExecutionCount();
        this.removeWarningAndTriggerContinuation(warning, "continueTask");
      };
    }
  }
  removeWarningAndTriggerContinuation(warning, eventType, detail) {
    warning.remove();
    this.hideToolContinuationContainerIfEmpty();
    const event = detail ? new CustomEvent(eventType, { detail }) : new CustomEvent(eventType);
    this.context.messagesContainer.dispatchEvent(event);
  }
  hideToolContinuationContainerIfEmpty() {
    if (this.context.toolContinuationContainer) {
      if (this.context.toolContinuationContainer.children.length === 0) {
        this.context.toolContinuationContainer.style.display = "none";
      }
    }
  }
  getEffectiveToolLimit() {
    const agentSettings = this.context.plugin.getAgentModeSettings();
    return this.context.getTemporaryMaxToolCalls() || agentSettings.maxToolCalls;
  }
};

// src/components/chat/agent/AgentResponseHandler/AgentResponseHandler.ts
var AgentResponseHandler = class {
  constructor(context) {
    this.context = context;
    __publicField(this, "commandParser");
    __publicField(this, "toolRegistry");
    __publicField(this, "executionCount", 0);
    __publicField(this, "temporaryMaxToolCalls");
    __publicField(this, "toolDisplays", /* @__PURE__ */ new Map());
    __publicField(this, "toolMarkdownCache", /* @__PURE__ */ new Map());
    __publicField(this, "notificationManager");
    __publicField(this, "toolResultFormatter");
    __publicField(this, "toolExecutor");
    __publicField(this, "reasoningProcessor");
    __publicField(this, "toolLimitWarningUI");
    this.debugLog("constructor called");
    this.commandParser = new CommandParser(this.context.plugin);
    this.toolRegistry = new ToolRegistry(this.context.plugin);
    this.notificationManager = new TaskNotificationManager(context);
    this.toolResultFormatter = new ToolResultFormatter();
    this.toolExecutor = new ToolExecutor(
      this.toolRegistry,
      (result, command) => this.context.onToolResult(result, command),
      (command, result) => this.createToolDisplay(command, result)
    );
    this.reasoningProcessor = new ReasoningProcessor(context);
    this.toolLimitWarningUI = new ToolLimitWarningUI(this);
    this.initializeTools();
  }
  getContext() {
    return this.context;
  }
  debugLog(message, data, contextLabel = "AgentResponseHandler") {
    var _a2, _b;
    if (((_b = (_a2 = this.context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) && typeof this.context.plugin.debugLog === "function") {
      this.context.plugin.debugLog("debug", `[${contextLabel}] ${message}`, data);
    }
  }
  initializeTools() {
    this.debugLog("initializeTools called");
    const tools = createToolInstances(this.context.app, this.context.plugin);
    for (const tool of tools) {
      this.toolRegistry.register(tool);
    }
  }
  async processResponse(response, contextLabel = "main", chatHistory) {
    this.debugLog("Processing response", { response }, contextLabel);
    if (!this.context.plugin.isAgentModeEnabled()) {
      return this.createProcessResponseResult(response, [], false);
    }
    const { text, commands } = this.commandParser.parseResponse(response);
    if (commands.length === 0) {
      this.debugLog("No tool commands found in response", void 0, contextLabel);
      return this.createProcessResponseResult(text, [], false);
    }
    const commandsToExecute = chatHistory ? this.filterAlreadyExecutedCommands(commands, chatHistory, contextLabel) : commands;
    if (commandsToExecute.length === 0) {
      this.debugLog("All commands already executed, skipping", void 0, contextLabel);
      const existingResults = this.getExistingToolResults(commands, chatHistory || []);
      return this.createProcessResponseResult(text, existingResults, true);
    }
    const effectiveLimit = this.getEffectiveToolLimit();
    if (this.executionCount >= effectiveLimit) {
      this.debugLog("Tool execution limit reached", { executionCount: this.executionCount, effectiveLimit }, contextLabel);
      this.notificationManager.showTaskCompletionNotification(`Agent mode: Maximum tool calls (${effectiveLimit}) reached`, "warning");
      return this.createProcessResponseResult(
        text + `

*${effectiveLimit} [Tool execution limit reached]*`,
        [],
        true
      );
    }
    return await this.executeToolCommands(commandsToExecute, text, contextLabel);
  }
  createProcessResponseResult(text, toolResults, hasTools) {
    return {
      processedText: text,
      toolResults,
      hasTools
    };
  }
  async executeToolCommands(commands, text, contextLabel) {
    const toolResults = [];
    const agentSettings = this.context.plugin.getAgentModeSettings();
    const effectiveLimit = this.getEffectiveToolLimit();
    for (const command of commands) {
      try {
        const result = await this.toolExecutor.executeToolWithLogging(command, agentSettings.timeoutMs, contextLabel, this.debugLog.bind(this));
        toolResults.push({ command, result });
        this.executionCount++;
        this.createToolDisplay(command, result);
        this.context.onToolResult(result, command);
        if (this.executionCount >= effectiveLimit) {
          break;
        }
      } catch (error) {
        this.debugLog("Tool execution error", { command, error }, contextLabel);
        console.error(`AgentResponseHandler: Tool '${command.action}' failed with error:`, error);
        const errorResult = {
          success: false,
          error: `${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_FAILED}: ${error.message}`,
          requestId: command.requestId
        };
        toolResults.push({ command, result: errorResult });
        this.createToolDisplay(command, errorResult);
        this.context.onToolResult(errorResult, command);
      }
    }
    return this.createProcessResponseResult(text, toolResults, true);
  }
  // For ToolLimitWarningUI compatibility
  getExecutionCount() {
    return this.executionCount;
  }
  addToolExecutions(count) {
    const agentSettings = this.context.plugin.getAgentModeSettings();
    this.temporaryMaxToolCalls = (this.temporaryMaxToolCalls || agentSettings.maxToolCalls) + count;
  }
  resetExecutionCount() {
    this.executionCount = 0;
    this.temporaryMaxToolCalls = void 0;
    this.toolDisplays.clear();
    this.toolMarkdownCache.clear();
  }
  getTemporaryMaxToolCalls() {
    return this.temporaryMaxToolCalls;
  }
  getAvailableTools() {
    return this.toolRegistry.getAvailableTools();
  }
  getToolDisplays() {
    return new Map(this.toolDisplays);
  }
  clearToolDisplays() {
    this.toolDisplays.clear();
    this.toolMarkdownCache.clear();
  }
  getToolMarkdown() {
    return Array.from(this.toolMarkdownCache.values());
  }
  getCombinedToolMarkdown() {
    return this.getToolMarkdown().join("\n");
  }
  getExecutionStats() {
    const effectiveLimit = this.getEffectiveToolLimit();
    return {
      executionCount: this.executionCount,
      maxToolCalls: effectiveLimit,
      remaining: Math.max(0, effectiveLimit - this.executionCount)
    };
  }
  createToolDisplay(command, result) {
    const displayId = this.generateDisplayId(command);
    const toolDisplay = new ToolRichDisplay({
      command,
      result,
      onRerun: () => this.rerunTool(command),
      onCopy: () => this.copyToolResult(command, result)
    });
    this.toolDisplays.set(displayId, toolDisplay);
    this.toolMarkdownCache.set(displayId, toolDisplay.toMarkdown());
    if (this.context.onToolDisplay) {
      this.context.onToolDisplay(toolDisplay);
    }
    this.cacheToolMarkdown(command, result);
  }
  generateDisplayId(command) {
    return `${command.action}${CONSTANTS.TOOL_DISPLAY_ID_SEPARATOR}${command.requestId || Date.now()}`;
  }
  async copyToolResult(command, result) {
    const displayText = this.toolResultFormatter.formatToolResult(command, result, { style: "copy" });
    try {
      await navigator.clipboard.writeText(displayText);
    } catch (error) {
      console.error(CONSTANTS.ERROR_MESSAGES.COPY_FAILED, error);
    }
  }
  cacheToolMarkdown(command, result) {
    const cacheKey = `${command.action}-${command.requestId}`;
    const statusText = result.success ? "SUCCESS" : "ERROR";
    const resultData = result.success ? stringifyJson(result.data) : result.error;
    const markdown = `### TOOL EXECUTION: ${command.action}
**Status:** ${statusText}

**Parameters:**
\`\`\`json
${stringifyJson(command.parameters)}
\`\`\`

**Result:**
\`\`\`json
${resultData}
\`\`\`
`;
    this.toolMarkdownCache.set(cacheKey, markdown);
  }
  async rerunTool(originalCommand) {
    try {
      const agentSettings = this.context.plugin.getAgentModeSettings();
      const result = await this.toolExecutor.executeToolWithLogging(originalCommand, agentSettings.timeoutMs, "rerun", this.debugLog.bind(this));
      this.createToolDisplay(originalCommand, result);
      this.context.onToolResult(result, originalCommand);
    } catch (error) {
      console.error(`${CONSTANTS.ERROR_MESSAGES.RERUN_FAILED} ${originalCommand.action}:`, error);
    }
  }
  getRelativePath(filePath) {
    const adapter = this.context.app.vault.adapter;
    const vaultRoot = (adapter == null ? void 0 : adapter.basePath) ? normalizePath2(adapter.basePath) : "";
    let relPath = normalizePath2(filePath);
    if (vaultRoot && relPath.startsWith(vaultRoot)) {
      relPath = relPath.slice(vaultRoot.length);
      if (relPath.startsWith(CONSTANTS.PATH_SEPARATOR)) {
        relPath = relPath.slice(1);
      }
    }
    if (relPath.toLowerCase().endsWith(CONSTANTS.MD_EXTENSION)) {
      relPath = relPath.slice(0, -CONSTANTS.MD_EXTENSION.length);
    }
    return relPath;
  }
  getEffectiveToolLimit() {
    const agentSettings = this.context.plugin.getAgentModeSettings();
    return this.temporaryMaxToolCalls || agentSettings.maxToolCalls;
  }
  filterAlreadyExecutedCommands(commands, chatHistory, contextLabel) {
    const filteredCommands = [];
    for (const command of commands) {
      const commandKey = this.generateCommandKey(command);
      const alreadyExecuted = this.isCommandInChatHistory(commandKey, chatHistory);
      if (alreadyExecuted) {
        if (this.context.plugin.settings.debugMode) {
          this.context.plugin.debugLog("debug", `[AgentResponseHandler][${contextLabel}] Skipping already executed command`, { command, commandKey });
        }
      } else {
        filteredCommands.push(command);
      }
    }
    return filteredCommands;
  }
  getExistingToolResults(commands, chatHistory) {
    const existingResults = [];
    for (const command of commands) {
      const commandKey = this.generateCommandKey(command);
      const existingResult = this.findToolResultInChatHistory(commandKey, chatHistory);
      if (existingResult) {
        existingResults.push({ command, result: existingResult });
      }
    }
    return existingResults;
  }
  generateCommandKey(command) {
    const params = stringifyJson(command.parameters || {});
    return [
      command.action,
      params,
      command.requestId || "no-id"
    ].join(CONSTANTS.COMMAND_KEY_SEPARATOR);
  }
  isCommandInChatHistory(commandKey, chatHistory) {
    for (const message of chatHistory) {
      if (message.sender === "assistant" && message.toolResults) {
        for (const toolResult of message.toolResults) {
          const existingKey = this.generateCommandKey(toolResult.command);
          if (existingKey === commandKey) {
            return true;
          }
        }
      }
    }
    return false;
  }
  findToolResultInChatHistory(commandKey, chatHistory) {
    for (const message of chatHistory) {
      if (message.sender === "assistant" && message.toolResults) {
        for (const toolResult of message.toolResults) {
          const existingKey = this.generateCommandKey(toolResult.command);
          if (existingKey === commandKey) {
            return toolResult.result;
          }
        }
      }
    }
    return null;
  }
  // Delegated public API for compatibility with other modules
  isToolLimitReached() {
    const effectiveLimit = this.getEffectiveToolLimit();
    return this.executionCount >= effectiveLimit;
  }
  createToolResultMessage(toolResults) {
    return this.toolResultFormatter.createToolResultMessage(toolResults);
  }
  hideTaskProgress() {
    this.notificationManager.hideTaskProgress();
  }
  processResponseWithUI(response, contextLabel = "ui", chatHistory) {
    return (async () => {
      const result = await this.processResponse(response, contextLabel, chatHistory);
      let status = "completed";
      if (result.hasTools) {
        if (this.isToolLimitReached()) {
          status = "limit_reached";
        } else {
          status = "running";
        }
      }
      const taskStatus = this.createTaskStatus(status);
      const { reasoning } = this.reasoningProcessor.processToolResultsForMessage(result.toolResults);
      const shouldShowLimitWarning = this.isToolLimitReached() && result.hasTools;
      return {
        ...result,
        reasoning,
        taskStatus,
        shouldShowLimitWarning
      };
    })();
  }
  showTaskCompletionNotification(message, type2 = "success") {
    this.notificationManager.showTaskCompletionNotification(message, type2);
  }
  createToolLimitWarning() {
    return this.toolLimitWarningUI.createToolLimitWarning();
  }
  createTaskStatus(status, progress) {
    const agentSettings = this.context.plugin.getAgentModeSettings();
    return {
      status,
      progress,
      toolExecutionCount: this.executionCount,
      maxToolExecutions: agentSettings.maxToolCalls,
      canContinue: status === "limit_reached" || status === "stopped",
      lastUpdateTime: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};

// src/utils/systemMessage.ts
function getSystemMessage(settings) {
  let systemMessage = settings.systemMessage;
  if (settings.includeDateWithSystemMessage) {
    const currentDate = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    systemMessage = `${systemMessage}

The current date is ${currentDate}.`;
  }
  if (settings.includeTimeWithSystemMessage) {
    const now = /* @__PURE__ */ new Date();
    const timeZoneOffset = now.getTimezoneOffset();
    const offsetHours = Math.abs(timeZoneOffset) / 60;
    const offsetMinutes = Math.abs(timeZoneOffset) % 60;
    const sign = timeZoneOffset > 0 ? "-" : "+";
    const currentTime = now.toLocaleTimeString();
    const timeZoneString = `UTC${sign}${offsetHours.toString().padStart(2, "0")}:${offsetMinutes.toString().padStart(2, "0")}`;
    systemMessage = `${systemMessage}

The current time is ${currentTime} ${timeZoneString}.`;
  }
  return systemMessage;
}

// src/utils/noteUtils.ts
var import_obsidian22 = require("obsidian");

// src/utils/utils.ts
function findFile(app, filePath) {
  let file = app.vault.getAbstractFileByPath(filePath) || app.vault.getAbstractFileByPath(`${filePath}.md`);
  if (!file) {
    const allFiles = app.vault.getFiles();
    file = allFiles.find(
      (f) => f.name === filePath || f.name === `${filePath}.md` || f.basename.toLowerCase() === filePath.toLowerCase() || f.path === filePath || f.path === `${filePath}.md`
    ) || null;
  }
  return file;
}
function extractContentUnderHeader(content, headerText) {
  const lines = content.split("\n");
  let foundHeader = false;
  let extractedContent = [];
  let headerLevel = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const headerMatch = line.match(/^(#+)\s+(.*?)$/);
    if (headerMatch) {
      const currentHeaderLevel = headerMatch[1].length;
      const currentHeaderText = headerMatch[2].trim();
      if (foundHeader) {
        if (currentHeaderLevel <= headerLevel) {
          break;
        }
      } else if (currentHeaderText.toLowerCase() === headerText.toLowerCase()) {
        foundHeader = true;
        headerLevel = currentHeaderLevel;
        extractedContent.push(line);
        continue;
      }
    }
    if (foundHeader) {
      extractedContent.push(line);
    }
  }
  return extractedContent.join("\n");
}

// src/utils/noteUtils.ts
async function processObsidianLinks(content, app, settings, visitedNotes = /* @__PURE__ */ new Set(), currentDepth = 0) {
  var _a2;
  if (!settings.enableObsidianLinks) return content;
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let processedContent = content;
  while ((match = linkRegex.exec(content)) !== null) {
    if (match && match[0] && match[1]) {
      const parts = match[1].split("|");
      const filePath = parts[0].trim();
      try {
        let file = findFile(app, filePath);
        const headerMatch = filePath.match(/(.*?)#(.*)/);
        let extractedContent = "";
        if (file && file instanceof import_obsidian22.TFile) {
          if (visitedNotes.has(file.path)) {
            extractedContent = "[Recursive link omitted: already included]";
          } else {
            visitedNotes.add(file.path);
            const noteContent = await app.vault.cachedRead(file);
            if (headerMatch) {
              extractedContent = extractContentUnderHeader(noteContent, headerMatch[2].trim());
            } else {
              extractedContent = noteContent;
            }
            if (settings.expandLinkedNotesRecursively && currentDepth < ((_a2 = settings.maxLinkExpansionDepth) != null ? _a2 : 2)) {
              extractedContent = await processObsidianLinks(extractedContent, app, settings, visitedNotes, currentDepth + 1);
            }
          }
          processedContent = processedContent.replace(
            match[0],
            `${match[0]}

---
Note Name: ${filePath}
Content:
${extractedContent}
---
`
          );
        } else {
          new import_obsidian22.Notice(`File not found: ${filePath}. Ensure the file name and path are correct.`);
        }
      } catch (error) {
        new import_obsidian22.Notice(`Error processing link for ${filePath}: ${error.message}`);
      }
    }
  }
  return processedContent;
}
async function processContextNotes(contextNotesText, app) {
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let contextContent = "";
  while ((match = linkRegex.exec(contextNotesText)) !== null) {
    if (match && match[1]) {
      const fileName = match[1].trim();
      try {
        const headerMatch = fileName.match(/(.*?)#(.*)/);
        const baseFileName = headerMatch ? headerMatch[1].trim() : fileName;
        const headerName = headerMatch ? headerMatch[2].trim() : null;
        let file = findFile(app, baseFileName);
        if (file && file instanceof import_obsidian22.TFile) {
          const noteContent = await app.vault.cachedRead(file);
          contextContent += `---
From note: ${file.basename}

`;
          if (headerName) {
            const headerContent = extractContentUnderHeader(noteContent, headerName);
            contextContent += headerContent;
          } else {
            contextContent += noteContent;
          }
          contextContent += "\n\n";
        } else {
          contextContent += `Note not found: ${fileName}

`;
        }
      } catch (error) {
        contextContent += `Error processing note ${fileName}: ${error.message}

`;
      }
    }
  }
  return contextContent;
}
async function processMessages(messages, app, settings) {
  const processedMessages = [];
  if (settings.enableContextNotes && settings.contextNotes) {
    const contextContent = await processContextNotes(settings.contextNotes, app);
    if (contextContent) {
      if (messages.length > 0 && messages[0].role === "system") {
        processedMessages.push({
          role: "system",
          content: `${messages[0].content}

Here is additional context:
${contextContent}`
        });
        messages = messages.slice(1);
      } else {
        processedMessages.push({
          role: "system",
          content: `Here is context for our conversation:
${contextContent}`
        });
      }
    }
  }
  for (const message of messages) {
    const processedContent = await processObsidianLinks(message.content, app, settings, /* @__PURE__ */ new Set());
    processedMessages.push({
      role: message.role,
      content: processedContent
    });
  }
  return processedMessages;
}
async function getContextNotesContent(contextNotesText, app) {
  return processContextNotes(contextNotesText, app);
}

// src/components/chat/agent/ContextBuilder.ts
var ContextBuilder = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async buildContextMessages() {
    const messages = [
      { role: "system", content: getSystemMessage(this.plugin.settings) }
    ];
    if (this.plugin.settings.enableContextNotes && this.plugin.settings.contextNotes) {
      const contextContent = await getContextNotesContent(this.plugin.settings.contextNotes, this.plugin.app);
      messages[0].content += `

Context Notes:
${contextContent}`;
    }
    if (this.plugin.settings.referenceCurrentNote) {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const currentNoteContent = await this.app.vault.cachedRead(currentFile);
        messages.push({
          role: "system",
          content: `Here is the content of the current note (${currentFile.path}):

${currentNoteContent}`
        });
      }
    }
    if (this.plugin.settings.debugMode) {
      this.plugin.debugLog("debug", "[ContextBuilder] Building context messages", {
        enableContextNotes: this.plugin.settings.enableContextNotes,
        contextNotes: this.plugin.settings.contextNotes,
        referenceCurrentNote: this.plugin.settings.referenceCurrentNote
      });
    }
    return messages;
  }
  /**
   * Update reference note indicator
   */
  updateReferenceNoteIndicator(referenceNoteIndicator) {
    if (!referenceNoteIndicator) return;
    const currentFile = this.app.workspace.getActiveFile();
    const isReferenceEnabled = this.plugin.settings.referenceCurrentNote;
    const button = referenceNoteIndicator.previousElementSibling;
    if (isReferenceEnabled && currentFile) {
      referenceNoteIndicator.setText(`\u{1F4DD} Referencing: ${currentFile.basename}`);
      referenceNoteIndicator.style.display = "block";
      if (button && button.getAttribute("aria-label") === "Toggle referencing current note") {
        button.setText("\u{1F4DD}");
        button.classList.add("active");
      }
    } else {
      referenceNoteIndicator.style.display = "none";
      if (button && button.getAttribute("aria-label") === "Toggle referencing current note") {
        button.setText("\u{1F4DD}");
        button.classList.remove("active");
      }
    }
  }
};

// src/components/chat/MessageRegenerator.ts
var import_obsidian26 = require("obsidian");

// src/components/chat/ResponseStreamer.ts
var import_obsidian25 = require("obsidian");
init_providers();
init_MessageRenderer();

// src/components/chat/agent/TaskContinuation.ts
var import_obsidian23 = require("obsidian");
var TaskContinuation = class {
  constructor(plugin, agentResponseHandler, messagesContainer, component) {
    this.plugin = plugin;
    this.agentResponseHandler = agentResponseHandler;
    this.messagesContainer = messagesContainer;
    this.component = component;
  }
  /**
  * Continue task execution until finished parameter is true
  */
  async continueTaskUntilFinished(messages, container, initialResponseContent, currentContent, initialToolResults, chatHistory) {
    var _a2, _b, _c, _d, _e;
    let responseContent = currentContent;
    let maxIterations = (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxIterations) != null ? _b : 10;
    let iteration = 0;
    let limitReachedDuringContinuation = false;
    let allToolResults = [...initialToolResults];
    let isFinished = this.checkIfTaskFinished(allToolResults);
    if ((_c = this.agentResponseHandler) == null ? void 0 : _c.isToolLimitReached()) {
      return {
        content: responseContent + "\n\n*[Tool execution limit reached - task continuation stopped]*",
        limitReachedDuringContinuation: true
      };
    }
    if (this.plugin.settings.debugMode) {
      this.plugin.debugLog("debug", "[TaskContinuation] continueTaskUntilFinished", {
        initialResponseContent,
        currentContent,
        initialToolResults,
        maxIterations
      });
    }
    while (!isFinished && iteration < maxIterations) {
      iteration++;
      if ((_d = this.agentResponseHandler) == null ? void 0 : _d.isToolLimitReached()) {
        responseContent += "\n\n*[Tool execution limit reached during continuation]*";
        limitReachedDuringContinuation = true;
        break;
      }
      const toolResultMessage = (_e = this.agentResponseHandler) == null ? void 0 : _e.createToolResultMessage(allToolResults);
      if (toolResultMessage) {
        const continuationMessages = [
          ...messages,
          { role: "assistant", content: initialResponseContent },
          toolResultMessage
        ];
        const continuationContent = await this.getContinuationResponse(continuationMessages, container);
        if (continuationContent.trim()) {
          let processingResult;
          if (this.agentResponseHandler) {
            processingResult = await this.agentResponseHandler.processResponse(continuationContent, "task-continuation", chatHistory);
            if (processingResult.toolResults && processingResult.toolResults.length > 0) {
              allToolResults = [...allToolResults, ...processingResult.toolResults];
            }
          }
          const continuationResult = await this.processContinuation(
            continuationContent,
            responseContent,
            container,
            allToolResults,
            // pass all so far
            chatHistory,
            processingResult
            // pass the already processed result to avoid double processing
          );
          responseContent = continuationResult.responseContent;
          isFinished = continuationResult.isFinished;
          initialResponseContent = continuationContent;
        } else {
          isFinished = true;
        }
      } else {
        isFinished = true;
      }
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Iteration", {
          iteration,
          isFinished,
          toolResults: allToolResults
        });
      }
    }
    if (iteration >= maxIterations) {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Maximum iterations reached", { iteration });
      }
      responseContent += "\n\n*[Task continuation reached maximum iterations - stopping to prevent infinite loop]*";
    }
    return { content: responseContent, limitReachedDuringContinuation };
  }
  /**
  * Process continuation response and update UI
  */
  async processContinuation(continuationContent, responseContent, container, initialToolResults, chatHistory, processingResult) {
    let continuationResult;
    if (processingResult) {
      continuationResult = processingResult;
    } else if (this.agentResponseHandler) {
      continuationResult = await this.agentResponseHandler.processResponse(continuationContent, "main", chatHistory);
    } else {
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateContainerContent(container, updatedContent);
      return { responseContent: updatedContent, isFinished: true };
    }
    if (continuationResult.hasTools) {
      const cleanContinuationContent = continuationResult.processedText;
      const isFinished = this.checkIfTaskFinished(continuationResult.toolResults);
      const allToolResults = initialToolResults;
      const updatedContent = responseContent + "\n\n" + cleanContinuationContent;
      const enhancedMessageData = this.createEnhancedMessageData(
        updatedContent,
        continuationResult,
        allToolResults
      );
      this.updateContainerWithMessageData(container, enhancedMessageData, updatedContent);
      return { responseContent: updatedContent, isFinished };
    } else {
      let isFinished = false;
      try {
        const parsed = JSON.parse(continuationContent);
        if (parsed && parsed.finished === true) {
          isFinished = true;
        }
      } catch (e) {
        if (initialToolResults.length > 0) {
          isFinished = this.checkIfTaskFinished(initialToolResults);
        }
      }
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateContainerContent(container, updatedContent);
      return { responseContent: updatedContent, isFinished };
    }
  }
  /**
   * Update container content with new text
   */
  async updateContainerContent(container, content) {
    container.dataset.rawContent = content;
    const contentEl = container.querySelector(".message-content");
    if (contentEl) {
      contentEl.empty();
      await import_obsidian23.MarkdownRenderer.render(
        this.plugin.app,
        content,
        contentEl,
        "",
        this.component || null
      );
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
  }
  /**
   * Check if any tool results indicate the task is finished
   */
  checkIfTaskFinished(toolResults) {
    return toolResults.some(({ command, result }) => {
      if (command.finished === true) {
        return true;
      }
      if (command.action === "thought" && result.success && result.data) {
        return result.data.nextTool === "finished" || result.data.finished === true;
      }
      return false;
    });
  }
  /**
  * Get continuation response after tool execution
  */
  async getContinuationResponse(messages, container) {
    var _a2;
    try {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] getContinuationResponse", { messages });
      }
      if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
        return "*[Tool execution limit reached - no continuation response]*";
      }
      const { createProvider: createProvider2, createProviderFromUnifiedModel: createProviderFromUnifiedModel2 } = await Promise.resolve().then(() => (init_providers(), providers_exports));
      const provider = this.plugin.settings.selectedModel ? createProviderFromUnifiedModel2(this.plugin.settings, this.plugin.settings.selectedModel) : createProvider2(this.plugin.settings);
      let continuationContent = "";
      await provider.getCompletion(
        messages,
        {
          temperature: this.plugin.settings.temperature,
          maxTokens: this.plugin.settings.maxTokens,
          streamCallback: async (chunk) => {
            continuationContent += chunk;
          }
          // Note: We don't pass activeStream here as this is a background operation
        }
      );
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Continuation response received", { continuationContent });
      }
      return continuationContent;
    } catch (error) {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Error getting continuation response", { error });
      }
      console.error("TaskContinuation: Error getting continuation response:", error);
      if (error.name !== "AbortError") {
        return `*[Error getting continuation: ${error.message}]*`;
      }
      return "";
    }
  }
  /**
   * Creates enhanced message data structure
   */
  createEnhancedMessageData(content, agentResult, toolResults) {
    const messageData = {
      role: "assistant",
      content,
      reasoning: agentResult.reasoning,
      taskStatus: agentResult.taskStatus
    };
    if (toolResults) {
      messageData.toolResults = toolResults.map(({ command, result }) => ({
        command,
        result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
    return messageData;
  }
  /**
   * Updates container with enhanced message data
   */
  updateContainerWithMessageData(container, messageData, rawContent) {
    container.dataset.messageData = JSON.stringify(messageData);
    container.dataset.rawContent = rawContent;
  }
};

// src/components/chat/ResponseStreamer.ts
var ResponseStreamer = class {
  constructor(plugin, agentResponseHandler, messagesContainer, activeStream, component) {
    this.plugin = plugin;
    this.agentResponseHandler = agentResponseHandler;
    this.messagesContainer = messagesContainer;
    this.activeStream = activeStream;
    this.component = component;
    __publicField(this, "messageRenderer");
    this.messageRenderer = new MessageRenderer(plugin.app);
  }
  /**
  * Streams AI assistant response with optional agent processing.
  * Handles agent mode integration, tool execution, and task continuation.
  */
  async streamAssistantResponse(messages, container, originalTimestamp, originalContent, chatHistory) {
    var _a2;
    this.plugin.debugLog("info", "[ResponseStreamer] streamAssistantResponse called", { messages, originalTimestamp });
    let responseContent = "";
    this.activeStream = new AbortController();
    await this.addAgentSystemPrompt(messages);
    try {
      const provider = this.createProvider();
      await provider.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        maxTokens: this.plugin.settings.maxTokens,
        streamCallback: async (chunk) => {
          responseContent += chunk;
          await this.updateMessageContent(container, responseContent);
        },
        abortController: this.activeStream || void 0
      });
      if (this.plugin.isAgentModeEnabled() && this.agentResponseHandler) {
        responseContent = await this.processAgentResponse(responseContent, container, messages, "streamer-main", chatHistory);
      }
      return responseContent;
    } catch (error) {
      if (error.name !== "AbortError") {
        throw error;
      }
      return "";
    } finally {
      (_a2 = this.agentResponseHandler) == null ? void 0 : _a2.hideTaskProgress();
    }
  }
  /**
   * Creates AI provider instance based on current settings
   */
  createProvider() {
    return this.plugin.settings.selectedModel ? createProviderFromUnifiedModel(this.plugin.settings, this.plugin.settings.selectedModel) : createProvider(this.plugin.settings);
  }
  /**
  * Adds agent system prompt to messages if agent mode is enabled
  */
  async addAgentSystemPrompt(messages) {
    this.plugin.debugLog("debug", "[ResponseStreamer] addAgentSystemPrompt called", { messages });
    if (!this.plugin.isAgentModeEnabled()) return;
    const { buildAgentSystemPrompt: buildAgentSystemPrompt2 } = await Promise.resolve().then(() => (init_promptConstants(), promptConstants_exports));
    const agentPrompt = buildAgentSystemPrompt2(
      this.plugin.settings.enabledTools,
      this.plugin.settings.customAgentSystemMessage
    );
    const systemMessageIndex = messages.findIndex((msg) => msg.role === "system");
    if (systemMessageIndex !== -1) {
      const originalContent = messages[systemMessageIndex].content;
      messages[systemMessageIndex].content = agentPrompt + "\n\n" + originalContent;
    } else {
      messages.unshift({
        role: "system",
        content: agentPrompt
      });
    }
  }
  /**
   * Updates message content in the UI with markdown rendering
   */
  async updateMessageContent(container, content) {
    const contentEl = container.querySelector(".message-content");
    if (!contentEl) return;
    this.updateContainerDataset(container, content);
    contentEl.empty();
    await import_obsidian25.MarkdownRenderer.render(
      this.plugin.app,
      content,
      contentEl,
      "",
      this.component || null
    );
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  /**
  * Processes agent response and handles tool execution or reasoning
  */
  async processAgentResponse(responseContent, container, messages, contextLabel = "streamer", chatHistory) {
    if (!this.agentResponseHandler) {
      return responseContent;
    }
    try {
      const agentResult = await this.agentResponseHandler.processResponseWithUI(responseContent, contextLabel, chatHistory);
      return agentResult.hasTools ? await this.handleToolExecution(agentResult, container, responseContent, messages, chatHistory) : await this.handleNonToolResponse(agentResult, container, responseContent, messages, chatHistory);
    } catch (error) {
      console.error("ResponseStreamer: Error processing agent response:", error);
      return responseContent;
    }
  }
  /**
  * Handles responses that include tool execution
  */
  async handleToolExecution(agentResult, container, responseContent, messages, chatHistory) {
    const finalContent = agentResult.processedText;
    const enhancedMessageData = this.createEnhancedMessageData(
      finalContent,
      agentResult,
      agentResult.toolResults
    );
    this.updateContainerWithMessageData(container, enhancedMessageData, finalContent);
    return this.handleTaskCompletion(agentResult, finalContent, responseContent, messages, container, chatHistory);
  }
  /**
   * Handles responses without tool execution but potentially with reasoning
   */
  async handleNonToolResponse(agentResult, container, responseContent, messages, chatHistory) {
    if (agentResult.reasoning) {
      const enhancedMessageData = this.createEnhancedMessageData(responseContent, agentResult);
      this.updateContainerWithMessageData(container, enhancedMessageData, responseContent);
    }
    if (this.isReasoningStep(responseContent)) {
      return await this.handleReasoningContinuation(responseContent, messages, container, chatHistory);
    }
    return responseContent;
  }
  /**
   * Creates enhanced message data structure
   */
  createEnhancedMessageData(content, agentResult, toolResults) {
    const messageData = {
      role: "assistant",
      content,
      reasoning: agentResult.reasoning,
      taskStatus: agentResult.taskStatus
    };
    if (toolResults) {
      messageData.toolResults = toolResults.map(({ command, result }) => ({
        command,
        result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
    return messageData;
  }
  /**
   * Updates container with enhanced message data
   */
  updateContainerWithMessageData(container, messageData, rawContent) {
    container.dataset.messageData = JSON.stringify(messageData);
    container.dataset.rawContent = rawContent;
    this.messageRenderer.updateMessageWithEnhancedData(container, messageData);
  }
  /**
   * DRY helper: Updates container dataset values for rawContent and messageData
   */
  updateContainerDataset(container, rawContent, messageData) {
    container.dataset.rawContent = rawContent;
    if (messageData) {
      container.dataset.messageData = JSON.stringify(messageData);
    }
  }
  /**
   * Checks if response content indicates a reasoning step
   */
  isReasoningStep(responseContent) {
    return responseContent.includes('"action"') && responseContent.includes('"thought"');
  }
  /**
  * Handles task completion, continuation, and tool limit management
  */
  async handleTaskCompletion(agentResult, finalContent, responseContent, messages, container, chatHistory) {
    if (agentResult.shouldShowLimitWarning) {
      return this.handleToolLimitReached(messages, container, responseContent, finalContent, agentResult.toolResults, chatHistory);
    }
    if (agentResult.taskStatus.status === "completed") {
      this.agentResponseHandler.showTaskCompletionNotification(
        `Task completed successfully! Used ${agentResult.taskStatus.toolExecutionCount} tools.`,
        "success"
      );
      return finalContent;
    }
    return await this.continueTaskIfPossible(
      agentResult,
      messages,
      container,
      responseContent,
      finalContent,
      chatHistory
    );
  }
  /**
   * Handles tool limit reached scenario
   */
  handleToolLimitReached(messages, container, responseContent, finalContent, toolResults, chatHistory) {
    const warning = this.agentResponseHandler.createToolLimitWarning();
    const targetContainer = this.agentResponseHandler.getContext().toolContinuationContainer || this.messagesContainer;
    targetContainer.appendChild(warning);
    if (this.agentResponseHandler.getContext().toolContinuationContainer) {
      this.agentResponseHandler.getContext().toolContinuationContainer.style.display = "block";
    }
    this.setupContinuationEventListeners(messages, container, responseContent, finalContent, toolResults, chatHistory);
    this.agentResponseHandler.showTaskCompletionNotification(
      "Tool execution limit reached. Choose how to continue above.",
      "warning"
    );
    return finalContent;
  }
  /**
   * Sets up event listeners for task continuation
   */
  setupContinuationEventListeners(messages, container, responseContent, finalContent, toolResults, chatHistory) {
    const continuationParams = {
      messages,
      container,
      responseContent,
      finalContent,
      toolResults,
      chatHistory
    };
    this.messagesContainer.addEventListener("continueTask", () => {
      this.executeContinuation(continuationParams);
    });
    this.messagesContainer.addEventListener("continueTaskWithAdditionalTools", (event) => {
      this.executeContinuation({
        ...continuationParams,
        additionalTools: event.detail.additionalTools
      });
    });
  }
  /**
   * Continues task if no limits are reached
   */
  async continueTaskIfPossible(agentResult, messages, container, responseContent, finalContent, chatHistory) {
    var _a2;
    if (agentResult.shouldShowLimitWarning || ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached())) {
      return finalContent;
    }
    const taskContinuation = this.createTaskContinuation();
    const continuationResult = await taskContinuation.continueTaskUntilFinished(
      messages,
      container,
      responseContent,
      finalContent,
      agentResult.toolResults,
      chatHistory || []
    );
    if (continuationResult.limitReachedDuringContinuation) {
      this.handleToolLimitReached(
        messages,
        container,
        responseContent,
        continuationResult.content,
        agentResult.toolResults,
        chatHistory
      );
    }
    return continuationResult.content;
  }
  /**
   * Creates TaskContinuation instance
   */
  createTaskContinuation() {
    return new TaskContinuation(
      this.plugin,
      this.agentResponseHandler,
      this.messagesContainer,
      this.component
    );
  }
  /**
   * Handles reasoning continuation when AI response contains reasoning steps
   */
  async handleReasoningContinuation(responseContent, messages, container, chatHistory) {
    var _a2;
    if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
      return responseContent + "\n\n*[Tool execution limit reached - reasoning continuation stopped]*";
    }
    messages.push(
      { role: "assistant", content: responseContent },
      { role: "system", content: "Please continue with the actual task execution based on your reasoning." }
    );
    const continuationContent = await this.getContinuationResponse(messages, container);
    if (continuationContent.trim()) {
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateMessageContent(container, updatedContent);
      return updatedContent;
    }
    return responseContent;
  }
  /**
   * Gets continuation response after tool execution with error handling
   */
  async getContinuationResponse(messages, container) {
    var _a2;
    try {
      if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
        return "*[Tool execution limit reached - no continuation response]*";
      }
      const provider = this.createProvider();
      let continuationContent = "";
      await provider.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        maxTokens: this.plugin.settings.maxTokens,
        streamCallback: async (chunk) => {
          continuationContent += chunk;
        },
        abortController: this.activeStream || void 0
      });
      return continuationContent;
    } catch (error) {
      console.error("ResponseStreamer: Error getting continuation response:", error);
      return error.name !== "AbortError" ? `*[Error getting continuation: ${error.message}]*` : "";
    }
  }
  /**
   * Executes task continuation with proper setup and error handling
   */
  async executeContinuation(params) {
    if (!this.agentResponseHandler) return;
    const { messages, container, responseContent, finalContent, toolResults, additionalTools, chatHistory } = params;
    if (additionalTools) {
    } else {
      this.agentResponseHandler.resetExecutionCount();
    }
    const continueMessage = this.createContinuationMessage(additionalTools);
    await this.addContinuationNotice(continueMessage);
    messages.push({ role: "assistant", content: finalContent }, continueMessage);
    const newBotMessage = await this.createNewBotMessage();
    const continuationResult = await this.executeTaskContinuation(
      messages,
      newBotMessage.getElement(),
      responseContent,
      toolResults,
      chatHistory
    );
    if (continuationResult.limitReachedDuringContinuation) {
      this.handleToolLimitReached(
        messages,
        newBotMessage.getElement(),
        responseContent,
        continuationResult.content,
        toolResults,
        chatHistory
      );
    }
    newBotMessage.setContent(continuationResult.content);
  }
  /**
   * Creates continuation message based on type
   */
  createContinuationMessage(additionalTools) {
    const content = additionalTools ? `Added ${additionalTools} additional tool executions. Continuing with the task...` : "Tool execution limit was reset. Continuing with the task...";
    return { role: "system", content };
  }
  /**
   * Adds continuation notice to chat
   */
  async addContinuationNotice(continueMessage) {
    const { BotMessage: BotMessage2 } = await Promise.resolve().then(() => (init_BotMessage(), BotMessage_exports));
    const continuationNotice = new BotMessage2(this.plugin.app, this.plugin, continueMessage.content);
    const element = continuationNotice.getElement();
    element.style.opacity = "0.8";
    element.style.fontStyle = "italic";
    this.messagesContainer.appendChild(element);
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  /**
   * Creates new bot message for continuation response
   */
  async createNewBotMessage() {
    const { BotMessage: BotMessage2 } = await Promise.resolve().then(() => (init_BotMessage(), BotMessage_exports));
    const newBotMessage = new BotMessage2(this.plugin.app, this.plugin, "");
    this.messagesContainer.appendChild(newBotMessage.getElement());
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    return newBotMessage;
  }
  /**
   * Executes task continuation logic
   */
  async executeTaskContinuation(messages, container, responseContent, toolResults, chatHistory) {
    const taskContinuation = this.createTaskContinuation();
    return await taskContinuation.continueTaskUntilFinished(
      messages,
      container,
      responseContent,
      "",
      toolResults,
      chatHistory || []
    );
  }
};

// src/components/chat/MessageRegenerator.ts
var MessageRegenerator = class {
  constructor(plugin, messagesContainer, inputContainer, chatHistoryManager, agentResponseHandler, activeStream, component) {
    this.plugin = plugin;
    this.messagesContainer = messagesContainer;
    this.inputContainer = inputContainer;
    this.chatHistoryManager = chatHistoryManager;
    this.agentResponseHandler = agentResponseHandler;
    this.activeStream = activeStream;
    this.component = component;
    __publicField(this, "responseStreamer");
    this.responseStreamer = new ResponseStreamer(
      plugin,
      agentResponseHandler,
      messagesContainer,
      activeStream,
      component
    );
  }
  async regenerateResponse(messageEl, buildContextMessages) {
    const textarea = this.inputContainer.querySelector("textarea");
    if (textarea) textarea.disabled = true;
    const allMessages = Array.from(this.messagesContainer.querySelectorAll(".ai-chat-message"));
    const currentIndex = allMessages.indexOf(messageEl);
    const isUserClicked = messageEl.classList.contains("user");
    let targetIndex = -1;
    if (isUserClicked) {
      for (let i = currentIndex + 1; i < allMessages.length; i++) {
        if (allMessages[i].classList.contains("assistant")) {
          targetIndex = i;
          break;
        }
        if (allMessages[i].classList.contains("user")) {
          break;
        }
      }
    } else {
      targetIndex = currentIndex;
    }
    let userMsgIndex = currentIndex;
    if (!isUserClicked) {
      userMsgIndex = currentIndex - 1;
      while (userMsgIndex >= 0 && !allMessages[userMsgIndex].classList.contains("user")) {
        userMsgIndex--;
      }
    }
    const messages = await buildContextMessages();
    for (let i = 0; i <= userMsgIndex; i++) {
      const el = allMessages[i];
      const role = el.classList.contains("user") ? "user" : "assistant";
      const content = el.dataset.rawContent || "";
      messages.push({ role, content });
    }
    let originalTimestamp = (/* @__PURE__ */ new Date()).toISOString();
    let originalContent = "";
    let insertAfterNode = null;
    if (targetIndex !== -1) {
      const targetEl = allMessages[targetIndex];
      originalTimestamp = targetEl.dataset.timestamp || originalTimestamp;
      originalContent = targetEl.dataset.rawContent || "";
      insertAfterNode = targetEl.previousElementSibling;
      targetEl.remove();
    } else if (isUserClicked) {
      insertAfterNode = messageEl;
    } else {
      insertAfterNode = null;
    }
    const assistantContainer = await createMessageElement(
      this.plugin.app,
      "assistant",
      "",
      this.chatHistoryManager,
      this.plugin,
      (el) => this.regenerateResponse(el, buildContextMessages),
      this.component || null
    );
    assistantContainer.dataset.timestamp = originalTimestamp;
    if (insertAfterNode && insertAfterNode.nextSibling) {
      this.messagesContainer.insertBefore(assistantContainer, insertAfterNode.nextSibling);
    } else {
      this.messagesContainer.appendChild(assistantContainer);
    }
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    try {
      await this.responseStreamer.streamAssistantResponse(
        messages,
        assistantContainer,
        originalTimestamp,
        originalContent
      );
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian26.Notice(`Error: ${error.message}`);
        assistantContainer.remove();
      }
    } finally {
      if (textarea) {
        textarea.disabled = false;
        textarea.focus();
      }
      this.activeStream = null;
    }
  }
};

// src/chat.ts
init_MessageRenderer();
var VIEW_TYPE_CHAT = "chat-view";
var ChatView = class extends import_obsidian27.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "chatHistoryManager");
    __publicField(this, "messagesContainer");
    __publicField(this, "inputContainer");
    __publicField(this, "activeStream", null);
    __publicField(this, "referenceNoteIndicator");
    // Add this property
    __publicField(this, "modelNameDisplay");
    // Add model name display property
    __publicField(this, "agentResponseHandler", null);
    // Helper classes for refactoring
    __publicField(this, "contextBuilder");
    __publicField(this, "messageRegenerator", null);
    __publicField(this, "responseStreamer", null);
    __publicField(this, "messageRenderer");
    this.plugin = plugin;
    this.chatHistoryManager = new ChatHistoryManager(this.app.vault, this.plugin.manifest.id, "chat-history.json");
    this.contextBuilder = new ContextBuilder(this.app, this.plugin);
    this.messageRenderer = new MessageRenderer(this.app);
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-chat-view");
    let loadedHistory = [];
    try {
      loadedHistory = await this.chatHistoryManager.getHistory();
    } catch (e) {
      new import_obsidian27.Notice("Failed to load chat history.");
      loadedHistory = [];
    }
    const ui = createChatUI(this.app, contentEl);
    this.messagesContainer = ui.messagesContainer;
    this.inputContainer = ui.inputContainer;
    this.referenceNoteIndicator = ui.referenceNoteIndicator;
    this.modelNameDisplay = ui.modelNameDisplay;
    this.updateReferenceNoteIndicator();
    this.updateModelNameDisplay();
    const textarea = ui.textarea;
    const sendButton = ui.sendButton;
    const stopButton = ui.stopButton;
    ui.copyAllButton.addEventListener("click", handleCopyAll(this.messagesContainer, this.plugin));
    ui.clearButton.addEventListener("click", handleClearChat(this.messagesContainer, this.chatHistoryManager));
    ui.settingsButton.addEventListener("click", handleSettings(this.app, this.plugin));
    ui.helpButton.addEventListener("click", handleHelp(this.app));
    ui.referenceNoteButton.addEventListener("click", () => {
      this.plugin.settings.referenceCurrentNote = !this.plugin.settings.referenceCurrentNote;
      this.plugin.saveSettings();
      this.updateReferenceNoteIndicator();
    });
    this.agentResponseHandler = new AgentResponseHandler({
      app: this.app,
      plugin: this.plugin,
      messagesContainer: this.messagesContainer,
      toolContinuationContainer: ui.toolContinuationContainer,
      onToolResult: (toolResult, command) => {
        if (toolResult.success) {
          console.log(`Tool ${command.action} completed successfully`, toolResult.data);
        } else {
          console.error(`Tool ${command.action} failed:`, toolResult.error);
        }
      },
      onToolDisplay: (display) => {
        const toolWrapper = document.createElement("div");
        toolWrapper.className = "real-time-tool-display";
        toolWrapper.appendChild(display.getElement());
        const tempContainer = this.messagesContainer.querySelector(".ai-chat-message.assistant:last-child");
        if (tempContainer) {
          const messageContent = tempContainer.querySelector(".message-content");
          if (messageContent) {
            messageContent.appendChild(toolWrapper);
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
          }
        }
      }
    });
    ui.saveNoteButton.addEventListener("click", handleSaveNote(this.messagesContainer, this.plugin, this.app, this.agentResponseHandler));
    this.responseStreamer = new ResponseStreamer(
      this.plugin,
      this.agentResponseHandler,
      this.messagesContainer,
      this.activeStream,
      this
    );
    this.messageRegenerator = new MessageRegenerator(
      this.plugin,
      this.messagesContainer,
      this.inputContainer,
      this.chatHistoryManager,
      this.agentResponseHandler,
      this.activeStream
    );
    ui.agentModeButton.addEventListener("click", async () => {
      const isCurrentlyEnabled = this.plugin.isAgentModeEnabled();
      await this.plugin.setAgentModeEnabled(!isCurrentlyEnabled);
      if (this.plugin.isAgentModeEnabled()) {
        ui.agentModeButton.classList.add("active");
        ui.agentModeButton.setAttribute("title", "Agent Mode: ON - AI can use tools");
        new import_obsidian27.Notice("Agent Mode enabled - AI can now use tools");
        if (this.agentResponseHandler) {
          this.agentResponseHandler.resetExecutionCount();
        }
      } else {
        ui.agentModeButton.classList.remove("active");
        ui.agentModeButton.setAttribute("title", "Agent Mode: OFF - Regular chat");
        new import_obsidian27.Notice("Agent Mode disabled");
      }
    });
    if (this.plugin.isAgentModeEnabled()) {
      ui.agentModeButton.classList.add("active");
      ui.agentModeButton.setAttribute("title", "Agent Mode: ON - AI can use tools");
    } else {
      ui.agentModeButton.classList.remove("active");
      ui.agentModeButton.setAttribute("title", "Agent Mode: OFF - Regular chat");
    }
    const sendMessage = async () => {
      var _a2;
      const content = textarea.value.trim();
      if (!content) return;
      if (this.agentResponseHandler) {
        this.agentResponseHandler.resetExecutionCount();
      }
      textarea.disabled = true;
      sendButton.classList.add("hidden");
      stopButton.classList.remove("hidden");
      const userMessageEl = await createMessageElement(this.app, "user", content, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this);
      this.messagesContainer.appendChild(userMessageEl);
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      textarea.value = "";
      try {
        await this.chatHistoryManager.addMessage({
          timestamp: userMessageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          sender: "user",
          content
        });
      } catch (e) {
        new import_obsidian27.Notice("Failed to save user message: " + e.message);
      }
      try {
        const messages = await this.buildContextMessages();
        const messageElements = this.messagesContainer.querySelectorAll(".ai-chat-message");
        messageElements.forEach((el) => {
          var _a3;
          const role = el.classList.contains("user") ? "user" : "assistant";
          const content2 = ((_a3 = el.querySelector(".message-content")) == null ? void 0 : _a3.textContent) || "";
          messages.push({ role, content: content2 });
        });
        const tempContainer = document.createElement("div");
        tempContainer.addClass("ai-chat-message", "assistant");
        tempContainer.createDiv("message-content");
        this.messagesContainer.appendChild(tempContainer);
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        const responseContent = await this.streamAssistantResponse(messages, tempContainer);
        let enhancedMessageData = void 0;
        console.log("DEBUG: tempContainer.dataset.messageData exists:", !!tempContainer.dataset.messageData);
        if (tempContainer.dataset.messageData) {
          try {
            enhancedMessageData = JSON.parse(tempContainer.dataset.messageData);
            console.log("DEBUG: enhancedMessageData parsed, toolResults count:", ((_a2 = enhancedMessageData.toolResults) == null ? void 0 : _a2.length) || 0);
          } catch (e) {
            console.warn("Failed to parse enhanced message data:", e);
          }
        }
        console.log("DEBUG: responseContent length:", responseContent.length, "trimmed length:", responseContent.trim().length);
        tempContainer.remove();
        if (responseContent.trim() !== "" || enhancedMessageData && enhancedMessageData.toolResults && enhancedMessageData.toolResults.length > 0) {
          const messageEl = await createMessageElement(
            this.app,
            "assistant",
            responseContent,
            this.chatHistoryManager,
            this.plugin,
            (el) => this.regenerateResponse(el),
            this,
            enhancedMessageData
            // Pass enhanced data to createMessageElement
          );
          this.messagesContainer.appendChild(messageEl);
          console.log("DEBUG: About to save message to history with toolResults:", !!(enhancedMessageData == null ? void 0 : enhancedMessageData.toolResults));
          await this.chatHistoryManager.addMessage({
            timestamp: messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            sender: "assistant",
            content: responseContent,
            ...enhancedMessageData && {
              toolResults: enhancedMessageData.toolResults,
              reasoning: enhancedMessageData.reasoning,
              taskStatus: enhancedMessageData.taskStatus
            }
          });
          console.log("DEBUG: Message saved to history successfully");
        } else {
          console.log("DEBUG: responseContent is empty and no toolResults, not saving message");
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          new import_obsidian27.Notice(`Error: ${error.message}`);
          await createMessageElement(this.app, "assistant", `Error: ${error.message}`, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this);
        }
      } finally {
        textarea.disabled = false;
        textarea.focus();
        stopButton.classList.add("hidden");
        sendButton.classList.remove("hidden");
        this.activeStream = null;
      }
    };
    sendButton.addEventListener("click", sendMessage);
    stopButton.addEventListener("click", () => {
      if (this.activeStream) {
        this.activeStream.abort();
        this.activeStream = null;
        textarea.disabled = false;
        textarea.focus();
        stopButton.classList.add("hidden");
        sendButton.classList.remove("hidden");
      }
    });
    Promise.resolve().then(() => (init_inputHandler(), inputHandler_exports)).then(({ setupInputHandler: setupInputHandler2 }) => {
      setupInputHandler2(
        textarea,
        this.messagesContainer,
        // Pass messagesContainer for keyboard shortcuts
        sendMessage,
        async (cmd) => {
          switch (cmd) {
            case "/clear":
              ui.clearButton.click();
              break;
            case "/copy":
              ui.copyAllButton.click();
              break;
            case "/save":
              ui.saveNoteButton.click();
              break;
            case "/settings":
              ui.settingsButton.click();
              break;
            case "/help":
              ui.helpButton.click();
              break;
            case "/ref":
              ui.referenceNoteButton.click();
              break;
          }
        },
        this.app,
        this.plugin,
        sendButton,
        stopButton
      );
    });
    if (loadedHistory.length > 0) {
      this.messagesContainer.empty();
      const file = this.app.workspace.getActiveFile();
      if (file) {
        await loadChatYamlAndApplySettings({
          app: this.app,
          plugin: this.plugin,
          settings: this.plugin.settings,
          file
        });
      }
      await renderChatHistory({
        messagesContainer: this.messagesContainer,
        loadedHistory,
        chatHistoryManager: this.chatHistoryManager,
        plugin: this.plugin,
        regenerateResponse: (el) => this.regenerateResponse(el),
        scrollToBottom: true
      });
    }
    this.updateReferenceNoteIndicator();
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.updateReferenceNoteIndicator();
    }));
    this.plugin.onSettingsChange(() => {
      this.updateReferenceNoteIndicator();
      this.updateModelNameDisplay();
    });
  }
  async addMessage(role, content, isError = false, enhancedData) {
    const messageEl = await createMessageElement(this.app, role, content, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this, enhancedData ? { role, content, ...enhancedData } : void 0);
    const uiTimestamp = messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString();
    this.messagesContainer.appendChild(messageEl);
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    try {
      await this.chatHistoryManager.addMessage({
        timestamp: uiTimestamp,
        sender: role,
        content,
        ...enhancedData || {}
      });
    } catch (e) {
      new import_obsidian27.Notice("Failed to save chat message: " + e.message);
    }
  }
  async onClose() {
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
  }
  async regenerateResponse(messageEl) {
    if (this.messageRegenerator) {
      await this.messageRegenerator.regenerateResponse(messageEl, () => this.buildContextMessages());
    }
  }
  updateReferenceNoteIndicator() {
    this.contextBuilder.updateReferenceNoteIndicator(this.referenceNoteIndicator);
  }
  updateModelNameDisplay() {
    if (!this.modelNameDisplay) return;
    let modelName = "Unknown Model";
    const settings = this.plugin.settings;
    if (settings.selectedModel && settings.availableModels) {
      const found = settings.availableModels.find((m) => m.id === settings.selectedModel);
      if (found) modelName = found.name;
      else modelName = settings.selectedModel;
    } else if (settings.selectedModel) {
      modelName = settings.selectedModel;
    }
    this.modelNameDisplay.textContent = `Model: ${modelName}`;
  }
  async buildContextMessages() {
    return await this.contextBuilder.buildContextMessages();
  }
  // Delegated to ResponseStreamer for DRY and clarity
  async streamAssistantResponse(messages, container, originalTimestamp, originalContent) {
    if (!this.responseStreamer) {
      throw new Error("ResponseStreamer not initialized");
    }
    const chatHistory = await this.chatHistoryManager.getHistory();
    const responseContent = await this.responseStreamer.streamAssistantResponse(
      messages,
      container,
      originalTimestamp,
      originalContent,
      chatHistory
    );
    if (originalTimestamp && responseContent.trim() !== "") {
      let messageData = void 0;
      if (container.dataset.messageData) {
        try {
          messageData = JSON.parse(container.dataset.messageData);
        } catch (e) {
        }
      }
      await this.chatHistoryManager.updateMessage(
        originalTimestamp,
        "assistant",
        originalContent || "",
        responseContent,
        messageData
      );
    }
    return responseContent;
  }
  clearMessages() {
    this.messagesContainer.empty();
    if (this.agentResponseHandler) {
      this.agentResponseHandler.resetExecutionCount();
    }
  }
  scrollMessagesToBottom() {
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  /**
  * Insert a rich tool display into the messages container
  */
  insertToolDisplay(display) {
    const toolDisplayWrapper = document.createElement("div");
    toolDisplayWrapper.className = "ai-chat-message tool-display-message";
    const messageContainer = toolDisplayWrapper.createDiv("message-container");
    messageContainer.appendChild(display.getElement());
    toolDisplayWrapper.dataset.timestamp = (/* @__PURE__ */ new Date()).toISOString();
    toolDisplayWrapper.dataset.rawContent = display.toMarkdown();
    const actionsEl = messageContainer.createDiv("message-actions");
    actionsEl.classList.add("hidden");
    toolDisplayWrapper.addEventListener("mouseenter", () => {
      actionsEl.classList.remove("hidden");
      actionsEl.classList.add("visible");
    });
    toolDisplayWrapper.addEventListener("mouseleave", () => {
      actionsEl.classList.remove("visible");
      actionsEl.classList.add("hidden");
    });
    const copyBtn = document.createElement("button");
    copyBtn.className = "ai-chat-action-button";
    copyBtn.setAttribute("aria-label", "Copy tool result");
    copyBtn.innerHTML = "<span>Copy</span>";
    copyBtn.addEventListener("click", async () => {
      const content = display.toMarkdown();
      try {
        await navigator.clipboard.writeText(content);
        new import_obsidian27.Notice("Tool result copied to clipboard");
      } catch (error) {
        new import_obsidian27.Notice("Failed to copy to clipboard");
        console.error("Clipboard error:", error);
      }
    });
    actionsEl.appendChild(copyBtn);
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "ai-chat-action-button";
    deleteBtn.setAttribute("aria-label", "Delete tool display");
    deleteBtn.innerHTML = "<span>Delete</span>";
    deleteBtn.addEventListener("click", () => {
      toolDisplayWrapper.remove();
    });
    actionsEl.appendChild(deleteBtn);
    this.messagesContainer.appendChild(toolDisplayWrapper);
    this.scrollMessagesToBottom();
  }
  // Task continuation logic is now delegated to TaskContinuation and ResponseStreamer
  // All reasoning/task status rendering and helpers are now handled by MessageRenderer
};

// src/components/commands/viewCommands.ts
var VIEW_TYPE_MODEL_SETTINGS = "model-settings-view";
function registerViewCommands(plugin) {
  registerCommand(
    plugin,
    {
      id: "show-ai-settings",
      name: "Show AI Settings",
      callback: () => activateView(plugin.app, VIEW_TYPE_MODEL_SETTINGS)
    },
    "file-sliders",
    "Open AI Settings"
  );
  registerCommand(
    plugin,
    {
      id: "show-ai-chat",
      name: "Show AI Chat",
      callback: () => activateView(plugin.app, VIEW_TYPE_CHAT)
    },
    "message-square",
    "Open AI Chat"
  );
}

// src/components/commands/aiStreamCommands.ts
init_pluginUtils();

// src/utils/aiCompletionHandler.ts
init_providers();

// src/utils/parseSelection.ts
function parseSelection(selection, chatSeparator, chatBoundaryString) {
  let insideChat = !chatBoundaryString;
  const lines = selection.split("\n");
  let messages = [];
  let currentRole = "user";
  let currentContent = "";
  for (const line of lines) {
    if (chatBoundaryString && line.trim() === chatBoundaryString) {
      if (!insideChat && currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
        currentContent = "";
      }
      insideChat = !insideChat;
      continue;
    }
    if (!insideChat) continue;
    if (line.trim() === chatSeparator) {
      if (currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
      }
      currentRole = currentRole === "user" ? "assistant" : "user";
      currentContent = "";
    } else {
      currentContent += line + "\n";
    }
  }
  if (currentContent.trim()) {
    messages.push({ role: currentRole, content: currentContent.trim() });
  }
  return messages;
}

// src/utils/generalUtils.ts
function showNotice(message) {
  const { Notice: Notice17 } = require("obsidian");
  new Notice17(message);
}
async function copyToClipboard3(text, successMsg = "Copied to clipboard", failMsg = "Failed to copy to clipboard") {
  try {
    await navigator.clipboard.writeText(text);
    showNotice(successMsg);
  } catch (error) {
    showNotice(failMsg);
    console.error("Clipboard error:", error);
  }
}
function moveCursorAfterInsert(editor, startPos, insertText) {
  const lines = insertText.split("\n");
  if (lines.length === 1) {
    editor.setCursor({
      line: startPos.line,
      ch: startPos.ch + insertText.length
    });
  } else {
    editor.setCursor({
      line: startPos.line + lines.length - 1,
      ch: lines[lines.length - 1].length
    });
  }
}
function insertSeparator(editor, position, separator) {
  var _a2;
  const lineContent = (_a2 = editor.getLine(position.line)) != null ? _a2 : "";
  const prefix = lineContent.trim() !== "" ? "\n" : "";
  editor.replaceRange(`${prefix}
${separator}
`, position);
  return position.line + (prefix ? 1 : 0) + 2;
}

// src/utils/aiCompletionHandler.ts
async function handleAICompletion(editor, settings, processMessages2, getSystemMessage2, activeStream, setActiveStream) {
  var _a2, _b;
  let text;
  let insertPosition;
  if (editor.somethingSelected()) {
    text = editor.getSelection();
    insertPosition = editor.getCursor("to");
  } else {
    const currentLineNumber = editor.getCursor().line;
    let lines = [];
    for (let i = 0; i <= currentLineNumber; i++) {
      lines.push(editor.getLine(i));
    }
    const chatStartString = settings.chatStartString;
    if (chatStartString) {
      const startIdx = lines.findIndex((line) => line.trim() === chatStartString.trim());
      if (startIdx !== -1) {
        lines = lines.slice(startIdx + 1);
      }
    }
    text = lines.join("\n");
    insertPosition = { line: currentLineNumber + 1, ch: 0 };
  }
  const messages = parseSelection(text, settings.chatSeparator);
  if (messages.length === 0) {
    showNotice("No valid messages found in the selection.");
    return;
  }
  const sepLine = insertSeparator(editor, insertPosition, settings.chatSeparator);
  let currentPosition = { line: sepLine, ch: 0 };
  activeStream.current = new AbortController();
  setActiveStream(activeStream.current);
  try {
    const provider = settings.selectedModel ? createProviderFromUnifiedModel(settings, settings.selectedModel) : createProvider(settings);
    const processedMessages = await processMessages2([
      { role: "system", content: getSystemMessage2() },
      ...messages
    ]);
    let bufferedChunk = "";
    const flushBuffer = () => {
      if (bufferedChunk) {
        editor.replaceRange(bufferedChunk, currentPosition);
        currentPosition = editor.offsetToPos(
          editor.posToOffset(currentPosition) + bufferedChunk.length
        );
        bufferedChunk = "";
      }
    };
    await provider.getCompletion(
      processedMessages,
      {
        temperature: settings.temperature,
        maxTokens: settings.maxTokens,
        streamCallback: (chunk) => {
          bufferedChunk += chunk;
          setTimeout(flushBuffer, 100);
        },
        abortController: activeStream.current
      }
    );
    flushBuffer();
    const endLineContent = (_a2 = editor.getLine(currentPosition.line)) != null ? _a2 : "";
    const endPrefix = endLineContent.trim() !== "" ? "\n" : "";
    editor.replaceRange(`${endPrefix}
${settings.chatSeparator}

`, currentPosition);
    const newCursorPos = editor.offsetToPos(
      editor.posToOffset(currentPosition) + (endPrefix ? 1 : 0) + 1 + settings.chatSeparator.length + 1
    );
    editor.setCursor(newCursorPos);
  } catch (error) {
    showNotice(`Error: ${error.message}`);
    const errLineContent = (_b = editor.getLine(currentPosition.line)) != null ? _b : "";
    const errPrefix = errLineContent.trim() !== "" ? "\n" : "";
    editor.replaceRange(`Error: ${error.message}
${errPrefix}
${settings.chatSeparator}

`, currentPosition);
  } finally {
    activeStream.current = null;
    setActiveStream(null);
  }
}

// src/components/commands/aiStreamCommands.ts
function registerAIStreamCommands(plugin, settings, processMessages2, activeStream, setActiveStream) {
  registerCommand(
    plugin,
    {
      id: "ai-completion",
      name: "Get AI Completion",
      editorCallback: (editor) => handleAICompletion(
        editor,
        settings,
        processMessages2,
        () => getSystemMessage(settings),
        activeStream,
        setActiveStream
      )
    }
  );
  registerCommand(
    plugin,
    {
      id: "end-ai-stream",
      name: "End AI Stream",
      callback: () => {
        if (activeStream.current) {
          activeStream.current.abort();
          activeStream.current = null;
          setActiveStream(null);
          showNotice("AI stream ended");
        } else {
          showNotice("No active AI stream to end");
        }
      }
    }
  );
}

// src/components/commands/noteCommands.ts
init_pluginUtils();
function registerNoteCommands(plugin, settings, activateChatViewAndLoadMessages) {
  registerCommand(
    plugin,
    {
      id: "copy-active-note-name",
      name: "Copy Active Note Name",
      callback: async () => {
        const activeFile = plugin.app.workspace.getActiveFile();
        if (activeFile) {
          const noteName = `[[${activeFile.basename}]]`;
          await copyToClipboard3(noteName, `Copied to clipboard: ${noteName}`, "Failed to copy to clipboard");
        } else {
          showNotice("No active note found");
        }
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "insert-chat-start-string",
      name: "Insert Chat Start String",
      editorCallback: (editor) => {
        var _a2;
        const chatStartString = (_a2 = settings.chatStartString) != null ? _a2 : "";
        if (!chatStartString) {
          showNotice("chatStartString is not set in settings.");
          return;
        }
        const cursor = editor.getCursor();
        editor.replaceRange(chatStartString, cursor);
        moveCursorAfterInsert(editor, cursor, chatStartString);
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "load-chat-note-into-chat",
      name: "Load Chat Note into Chat",
      callback: async () => {
        let file = plugin.app.workspace.getActiveFile();
        if (!file) {
          showNotice("No active note found. Please open a note to load as chat.");
          return;
        }
        let content = await plugin.app.vault.read(file);
        const messages = parseSelection(content, settings.chatSeparator);
        if (!messages.length) {
          showNotice("No chat messages found in the selected note.");
          return;
        }
        await activateChatViewAndLoadMessages(messages);
      }
    }
  );
}

// src/components/commands/generateNoteTitleCommand.ts
init_pluginUtils();
function registerGenerateNoteTitleCommand(plugin, settings, processMessages2) {
  registerCommand(
    plugin,
    {
      id: "generate-note-title",
      name: "Generate Note Title",
      callback: async () => {
        const { generateNoteTitle: generateNoteTitle2 } = await Promise.resolve().then(() => (init_YAMLHandler(), YAMLHandler_exports));
        await generateNoteTitle2(
          plugin.app,
          settings,
          processMessages2
        );
      }
    }
  );
}

// src/components/chat/CollapsibleSection.ts
var CollapsibleSectionRenderer = class {
  /**
   * Creates a collapsible section with a header that can be toggled
   */
  static createCollapsibleSection(containerEl, title, contentCallback, plugin, settingsType) {
    var _a2;
    plugin.settings[settingsType] = plugin.settings[settingsType] || {};
    let isExpanded = (_a2 = (plugin.settings[settingsType] || {})[title]) != null ? _a2 : false;
    const collapsibleContainer = containerEl.createEl("div");
    collapsibleContainer.addClass("ai-collapsible-section");
    const headerEl = collapsibleContainer.createEl("div");
    headerEl.addClass("ai-collapsible-header");
    const arrow = headerEl.createEl("span");
    arrow.addClass("ai-collapsible-arrow");
    arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
    const titleSpan = headerEl.createEl("span");
    titleSpan.textContent = title;
    const contentEl = collapsibleContainer.createEl("div");
    contentEl.addClass("ai-collapsible-content");
    contentEl.style.display = isExpanded ? "block" : "none";
    headerEl.addEventListener("click", async () => {
      isExpanded = !isExpanded;
      contentEl.style.display = isExpanded ? "block" : "none";
      arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
      (plugin.settings[settingsType] || {})[title] = isExpanded;
      await plugin.saveSettings();
    });
    const result = contentCallback(contentEl);
    if (result instanceof Promise) {
      result.catch((error) => console.error("Error in collapsible section:", error));
    }
  }
};

// src/settings/components/SettingCreators.ts
var import_obsidian29 = require("obsidian");
var SettingCreators = class {
  constructor(plugin, reRenderCallback) {
    __publicField(this, "plugin");
    __publicField(this, "reRenderCallback");
    this.plugin = plugin;
    this.reRenderCallback = reRenderCallback;
  }
  /**
   * Creates a text input setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param placeholder The placeholder text for the input.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   * @param options Additional options for the text input (e.g., trim, undefinedIfEmpty, isTextArea).
   */
  createTextSetting(containerEl, name, desc, placeholder, getValue, setValue, options) {
    new import_obsidian29.Setting(containerEl).setName(name).setDesc(desc).then((setting) => {
      const textInputOptions = {
        trim: options == null ? void 0 : options.trim,
        undefinedIfEmpty: options == null ? void 0 : options.undefinedIfEmpty
      };
      if (options == null ? void 0 : options.isTextArea) {
        setting.addTextArea((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      } else {
        setting.addText((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      }
    });
  }
  /**
   * Configures a text input (either single-line or multi-line).
   * @param textComponent The TextComponent or TextAreaComponent to configure.
   * @param placeholder The placeholder text.
   * @param getValue A function to get the current value.
   * @param setValue A function to set the new value.
   * @param options Additional options for processing the input value (e.g., trim, undefinedIfEmpty).
   */
  configureTextInput(textComponent, placeholder, getValue, setValue, options) {
    var _a2;
    textComponent.setPlaceholder(placeholder).setValue((_a2 = getValue()) != null ? _a2 : "").onChange(async (value) => {
      let processedValue = value;
      if (options == null ? void 0 : options.trim) {
        processedValue = processedValue.trim();
      }
      if ((options == null ? void 0 : options.undefinedIfEmpty) && processedValue === "") {
        processedValue = void 0;
      }
      await setValue(processedValue);
      this.reRenderCallback();
    });
  }
  /**
   * Creates a dropdown setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param options A record of option values to display names.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   */
  createDropdownSetting(containerEl, name, desc, options, getValue, setValue) {
    new import_obsidian29.Setting(containerEl).setName(name).setDesc(desc).addDropdown((drop) => {
      Object.entries(options).forEach(([key, display]) => drop.addOption(key, display));
      drop.setValue(getValue());
      drop.onChange(async (value) => {
        await setValue(value);
        this.reRenderCallback();
      });
    });
  }
  /**
   * Creates a toggle (checkbox) setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param getValue A function to get the current boolean value.
   * @param setValue A function to set the new boolean value.
   * @param onChangeCallback An optional callback to run after the value changes and settings are saved.
   */
  createToggleSetting(containerEl, name, desc, getValue, setValue, onChangeCallback) {
    new import_obsidian29.Setting(containerEl).setName(name).setDesc(desc).addToggle((toggle) => toggle.setValue(getValue()).onChange(async (value) => {
      await setValue(value);
      if (onChangeCallback) {
        onChangeCallback();
      }
      this.reRenderCallback();
    }));
  }
  /**
   * Creates a slider setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param limits An object defining min, max, and step for the slider.
   * @param getValue A function to get the current numeric value.
   * @param setValue A function to set the new numeric value.
   */
  createSliderSetting(containerEl, name, desc, limits, getValue, setValue) {
    new import_obsidian29.Setting(containerEl).setName(name).setDesc(desc).addSlider((slider) => {
      slider.setLimits(limits.min, limits.max, limits.step).setValue(getValue()).setDynamicTooltip().onChange(async (value) => {
        await setValue(value);
        this.reRenderCallback();
      });
    });
  }
};

// src/settings/sections/GeneralSettingsSection.ts
var GeneralSettingsSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  async render(containerEl) {
    containerEl.createEl("h3", { text: "Plugin Behavior" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Auto-Open Model Settings",
      "Automatically open the AI model settings panel when the plugin loads.",
      () => this.plugin.settings.autoOpenModelSettings,
      async (value) => {
        this.plugin.settings.autoOpenModelSettings = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h3", { text: "Date & Time Settings" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Include Date with System Message",
      "Add the current date to the system message",
      () => this.plugin.settings.includeDateWithSystemMessage,
      async (value) => {
        this.plugin.settings.includeDateWithSystemMessage = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createToggleSetting(
      containerEl,
      "Include Time with System Message",
      "Add the current time along with the date to the system message",
      () => this.plugin.settings.includeTimeWithSystemMessage,
      async (value) => {
        this.plugin.settings.includeTimeWithSystemMessage = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h3", { text: "Debug Settings" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Debug Mode",
      "Enable verbose logging and debug UI features",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.debugMode) != null ? _a2 : false;
      },
      async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      }
    );
  }
};

// src/settings/sections/AIModelConfigurationSection.ts
var import_obsidian30 = require("obsidian");
init_providers();
var AIModelConfigurationSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  async render(containerEl) {
    containerEl.createEl("h3", { text: "API Keys & Providers" });
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "OpenAI Configuration",
      async (sectionEl) => {
        this.settingCreators.createTextSetting(
          sectionEl,
          "OpenAI API Key",
          "Enter your OpenAI API key",
          "Enter your API key",
          () => this.plugin.settings.openaiSettings.apiKey,
          async (value) => {
            this.plugin.settings.openaiSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createTextSetting(
          sectionEl,
          "OpenAI Base URL",
          "Custom base URL for OpenAI API (optional, leave empty for default)",
          "https://api.openai.com/v1",
          () => this.plugin.settings.openaiSettings.baseUrl || "",
          async (value) => {
            this.plugin.settings.openaiSettings.baseUrl = value;
            await this.plugin.saveSettings();
          },
          { trim: true, undefinedIfEmpty: true }
        );
        this.renderProviderTestSection(sectionEl, "openai", "OpenAI");
      },
      this.plugin,
      "providerConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Anthropic Configuration",
      async (sectionEl) => {
        this.settingCreators.createTextSetting(
          sectionEl,
          "Anthropic API Key",
          "Enter your Anthropic API key",
          "Enter your API key",
          () => this.plugin.settings.anthropicSettings.apiKey,
          async (value) => {
            this.plugin.settings.anthropicSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.renderProviderTestSection(sectionEl, "anthropic", "Anthropic");
      },
      this.plugin,
      "providerConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Google Gemini Configuration",
      async (sectionEl) => {
        this.settingCreators.createTextSetting(
          sectionEl,
          "Google API Key",
          "Enter your Google API key",
          "Enter your API key",
          () => this.plugin.settings.geminiSettings.apiKey,
          async (value) => {
            this.plugin.settings.geminiSettings.apiKey = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.renderProviderTestSection(sectionEl, "gemini", "Google Gemini");
      },
      this.plugin,
      "providerConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Ollama Configuration",
      async (sectionEl) => {
        this.settingCreators.createTextSetting(
          sectionEl,
          "Ollama Server URL",
          "Enter your Ollama server URL (default: http://localhost:11434)",
          "http://localhost:11434",
          () => this.plugin.settings.ollamaSettings.serverUrl,
          async (value) => {
            this.plugin.settings.ollamaSettings.serverUrl = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        sectionEl.createEl("div", {
          cls: "setting-item-description",
          text: "To use Ollama:"
        });
        const steps = sectionEl.createEl("ol");
        steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
        steps.createEl("li", { text: "Start the Ollama server" });
        steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
        steps.createEl("li", { text: "Test connection to see available models" });
        this.renderProviderTestSection(sectionEl, "ollama", "Ollama");
      },
      this.plugin,
      "providerConfigExpanded"
    );
    containerEl.createEl("h3", { text: "Default AI Model Settings" });
    await this.renderAIModelSettings(containerEl);
    containerEl.createEl("h3", { text: "Model Management" });
    containerEl.createEl("h4", { text: "Available Models" });
    await this.renderAvailableModelsSection(containerEl);
    containerEl.createEl("h4", { text: "Model Setting Presets" });
    this.renderModelSettingPresets(containerEl);
  }
  /**
   * Renders the provider connection test section.
   */
  renderProviderTestSection(containerEl, provider, displayName) {
    const settings = this.plugin.settings[`${provider}Settings`];
    new import_obsidian30.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${displayName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        const originalProvider = this.plugin.settings.provider;
        this.plugin.settings.provider = provider;
        const providerInstance = createProvider(this.plugin.settings);
        const result = await providerInstance.testConnection();
        this.plugin.settings.provider = originalProvider;
        if (result.success && result.models) {
          settings.availableModels = result.models;
          settings.lastTestResult = {
            timestamp: Date.now(),
            success: true,
            message: result.message
          };
          await this.plugin.saveSettings();
          this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
          await this.plugin.saveSettings();
          new import_obsidian30.Notice(result.message);
        } else {
          settings.lastTestResult = {
            timestamp: Date.now(),
            success: false,
            message: result.message
          };
          new import_obsidian30.Notice(result.message);
        }
      } catch (error) {
        new import_obsidian30.Notice(`Error: ${error.message}`);
      } finally {
        button.setButtonText("Test");
        button.setDisabled(false);
      }
    }));
    if (settings.lastTestResult) {
      const date = new Date(settings.lastTestResult.timestamp);
      containerEl.createEl("div", {
        text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
        cls: settings.lastTestResult.success ? "success" : "error"
      });
    }
    if (settings.availableModels && settings.availableModels.length > 0) {
      containerEl.createEl("div", {
        text: `Available models: ${settings.availableModels.map((m) => m.name || m.id).join(", ")}`,
        cls: "setting-item-description"
      });
    }
  }
  /**
   * AI Model Settings Section
   */
  async renderAIModelSettings(containerEl) {
    if (this.plugin.settings.modelSettingPresets && this.plugin.settings.modelSettingPresets.length > 0) {
      const presetContainer = containerEl.createDiv();
      presetContainer.addClass("model-preset-buttons");
      presetContainer.createEl("div", { text: "Quick Presets:", cls: "setting-item-name" });
      this.plugin.settings.modelSettingPresets.forEach((preset, idx) => {
        const btn = presetContainer.createEl("button", { text: preset.name });
        btn.style.marginRight = "0.5em";
        btn.onclick = async () => {
          if (preset.selectedModel !== void 0) this.plugin.settings.selectedModel = preset.selectedModel;
          if (preset.systemMessage !== void 0) this.plugin.settings.systemMessage = preset.systemMessage;
          if (preset.temperature !== void 0) this.plugin.settings.temperature = preset.temperature;
          if (preset.maxTokens !== void 0) this.plugin.settings.maxTokens = preset.maxTokens;
          if (preset.enableStreaming !== void 0) this.plugin.settings.enableStreaming = preset.enableStreaming;
          await this.plugin.saveSettings();
          new import_obsidian30.Notice(`Applied preset: ${preset.name}`);
        };
      });
    }
    new import_obsidian30.Setting(containerEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian30.Setting(containerEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian30.Setting(containerEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian30.Setting(containerEl).setName("Refresh Available Models").setDesc("Test connections to all configured providers and refresh available models").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
      button.setButtonText("Refreshing...");
      button.setDisabled(true);
      try {
        await this.refreshAllAvailableModels();
        new import_obsidian30.Notice("Successfully refreshed available models");
      } catch (error) {
        new import_obsidian30.Notice(`Error refreshing models: ${error.message}`);
      } finally {
        button.setButtonText("Refresh Models");
        button.setDisabled(false);
      }
    }));
    await this.renderUnifiedModelDropdown(containerEl);
  }
  /**
   * Renders the unified model selection dropdown
   */
  async renderUnifiedModelDropdown(containerEl) {
    if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
      this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
      await this.plugin.saveSettings();
    }
    new import_obsidian30.Setting(containerEl).setName("Selected Model").setDesc("Choose from all available models across all configured providers").addDropdown((dropdown) => {
      if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
        dropdown.addOption("", "No models available - configure providers above");
      } else {
        dropdown.addOption("", "Select a model...");
        const modelsByProvider = {};
        const enabledModels = this.plugin.settings.enabledModels || {};
        const filteredModels = this.plugin.settings.availableModels.filter((model) => enabledModels[model.id] !== false);
        filteredModels.forEach((model) => {
          if (!modelsByProvider[model.provider]) {
            modelsByProvider[model.provider] = [];
          }
          modelsByProvider[model.provider].push(model);
        });
        Object.entries(modelsByProvider).forEach(([provider, models]) => {
          models.forEach((model) => {
            dropdown.addOption(model.id, model.name);
          });
        });
      }
      dropdown.setValue(this.plugin.settings.selectedModel || "").onChange(async (value) => {
        this.plugin.settings.selectedModel = value;
        if (value) {
          const provider = getProviderFromUnifiedModel(value);
          this.plugin.settings.provider = provider;
        }
        await this.plugin.saveSettings();
      });
    });
    if (this.plugin.settings.selectedModel && this.plugin.settings.availableModels) {
      const selectedModel = this.plugin.settings.availableModels.find(
        (model) => model.id === this.plugin.settings.selectedModel
      );
      if (selectedModel) {
        const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
        infoEl.setText(`Currently using: ${selectedModel.name}`);
      }
    }
  }
  /**
   * Refreshes available models from all configured providers
   */
  async refreshAllAvailableModels() {
    const providers = ["openai", "anthropic", "gemini", "ollama"];
    for (const providerType of providers) {
      try {
        const originalProvider = this.plugin.settings.provider;
        this.plugin.settings.provider = providerType;
        const providerInstance = createProvider(this.plugin.settings);
        const result = await providerInstance.testConnection();
        this.plugin.settings.provider = originalProvider;
        const providerSettings = this.plugin.settings[`${providerType}Settings`];
        if (result.success && result.models) {
          providerSettings.availableModels = result.models;
          providerSettings.lastTestResult = {
            timestamp: Date.now(),
            success: true,
            message: result.message
          };
        } else {
          providerSettings.lastTestResult = {
            timestamp: Date.now(),
            success: false,
            message: result.message
          };
        }
      } catch (error) {
        console.error(`Error testing ${providerType}:`, error);
      }
    }
    this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
    await this.plugin.saveSettings();
  }
  /**
   * Renders the Available Models section with checkboxes for each model.
   */
  async renderAvailableModelsSection(containerEl) {
    containerEl.createEl("div", {
      text: "Choose which models are available in model selection menus throughout the plugin.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const buttonRow = containerEl.createDiv({ cls: "ai-models-button-row" });
    new import_obsidian30.Setting(buttonRow).addButton((btn) => {
      btn.setButtonText("Refresh Models").setCta().onClick(async () => {
        btn.setButtonText("Refreshing...");
        btn.setDisabled(true);
        try {
          this.plugin.settings.availableModels = await getAllAvailableModels(this.plugin.settings);
          await this.plugin.saveSettings();
          new import_obsidian30.Notice("Available models refreshed.");
        } catch (e) {
          new import_obsidian30.Notice("Error refreshing models: " + ((e == null ? void 0 : e.message) || e));
        } finally {
          btn.setButtonText("Refresh Models");
          btn.setDisabled(false);
        }
      });
    }).addButton((btn) => {
      btn.setButtonText("All On").onClick(async () => {
        let allModels2 = this.plugin.settings.availableModels || [];
        if (allModels2.length === 0) {
          allModels2 = await getAllAvailableModels(this.plugin.settings);
        }
        if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
        allModels2.forEach((model) => {
          this.plugin.settings.enabledModels[model.id] = true;
        });
        await this.plugin.saveSettings();
      });
    }).addButton((btn) => {
      btn.setButtonText("All Off").onClick(async () => {
        let allModels2 = this.plugin.settings.availableModels || [];
        if (allModels2.length === 0) {
          allModels2 = await getAllAvailableModels(this.plugin.settings);
        }
        if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
        allModels2.forEach((model) => {
          this.plugin.settings.enabledModels[model.id] = false;
        });
        await this.plugin.saveSettings();
      });
    });
    let allModels = this.plugin.settings.availableModels || [];
    if (allModels.length === 0) {
      allModels = await getAllAvailableModels(this.plugin.settings);
    }
    if (!this.plugin.settings.enabledModels) this.plugin.settings.enabledModels = {};
    if (allModels.length === 0) {
      containerEl.createEl("div", { text: "No models found. Please configure your providers and refresh available models.", cls: "setting-item-description" });
    } else {
      allModels = allModels.slice().sort((a, b) => {
        if (a.provider !== b.provider) {
          return a.provider.localeCompare(b.provider);
        }
        return (a.name || a.id).localeCompare(b.name || b.id);
      });
      allModels.forEach((model) => {
        this.settingCreators.createToggleSetting(
          containerEl,
          model.name || model.id,
          `Enable or disable "${model.name || model.id}" (${model.id}) in model selection menus.`,
          () => this.plugin.settings.enabledModels[model.id] !== false,
          // default to true
          async (value) => {
            this.plugin.settings.enabledModels[model.id] = value;
            await this.plugin.saveSettings();
          }
        );
      });
    }
  }
  /**
   * Renders the Model Setting Presets section.
   */
  renderModelSettingPresets(containerEl) {
    containerEl.createEl("div", {
      text: "Presets let you save and quickly apply common model settings (model, temperature, system message, etc). You can add, edit, or remove presets here. In the AI Model Settings panel, you will see buttons for each preset above the model selection. Clicking a preset button will instantly apply those settings. This is useful for switching between different model configurations with one click.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const presetList = this.plugin.settings.modelSettingPresets || [];
    presetList.forEach((preset, idx) => {
      new import_obsidian30.Setting(containerEl).setName("Preset Name").setDesc("Edit the name of this preset").addText((text) => {
        text.setPlaceholder("Preset Name").setValue(preset.name).onChange(async (value) => {
          preset.name = value != null ? value : "";
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian30.Setting(containerEl).setName("Model ID (provider:model)").setDesc("Edit the model for this preset").addText((text) => {
        text.setPlaceholder("Model ID (provider:model)").setValue(preset.selectedModel || "").onChange(async (value) => {
          preset.selectedModel = value != null ? value : "";
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian30.Setting(containerEl).setName("System Message").setDesc("Edit the system message for this preset").addTextArea((text) => {
        text.setPlaceholder("System message").setValue(preset.systemMessage || "").onChange(async (value) => {
          preset.systemMessage = value != null ? value : "";
          await this.plugin.saveSettings();
        });
      });
      this.settingCreators.createSliderSetting(containerEl, "Temperature", "", { min: 0, max: 1, step: 0.1 }, () => {
        var _a2;
        return (_a2 = preset.temperature) != null ? _a2 : 0.7;
      }, async (value) => {
        preset.temperature = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian30.Setting(containerEl).setName("Max Tokens").setDesc("Edit the max tokens for this preset").addText((text) => {
        var _a2;
        text.setPlaceholder("Max tokens").setValue(((_a2 = preset.maxTokens) == null ? void 0 : _a2.toString()) || "").onChange(async (value) => {
          const num = parseInt(value != null ? value : "", 10);
          preset.maxTokens = isNaN(num) ? void 0 : num;
          await this.plugin.saveSettings();
        });
      });
      this.settingCreators.createToggleSetting(containerEl, "Enable Streaming", "", () => {
        var _a2;
        return (_a2 = preset.enableStreaming) != null ? _a2 : true;
      }, async (value) => {
        preset.enableStreaming = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian30.Setting(containerEl).addExtraButton(
        (btn) => btn.setIcon("cross").setTooltip("Delete").onClick(async () => {
          var _a2;
          (_a2 = this.plugin.settings.modelSettingPresets) == null ? void 0 : _a2.splice(idx, 1);
          await this.plugin.saveSettings();
        })
      );
    });
    new import_obsidian30.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Add Preset").setCta().onClick(async () => {
        if (!this.plugin.settings.modelSettingPresets) this.plugin.settings.modelSettingPresets = [];
        this.plugin.settings.modelSettingPresets.push(JSON.parse(JSON.stringify({
          name: `Preset ${this.plugin.settings.modelSettingPresets.length + 1}`,
          selectedModel: this.plugin.settings.selectedModel,
          systemMessage: this.plugin.settings.systemMessage,
          temperature: this.plugin.settings.temperature,
          maxTokens: this.plugin.settings.maxTokens,
          enableStreaming: this.plugin.settings.enableStreaming
        })));
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/settings/sections/AgentSettingsSection.ts
init_toolcollect();
init_promptConstants();
var AgentSettingsSection = class {
  constructor(app, plugin, settingCreators) {
    __publicField(this, "app");
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.app = app;
    this.plugin = plugin;
    this.settingCreators = settingCreators;
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("debug", "[AgentSettingsSection] constructor called");
    }
  }
  async render(containerEl) {
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("info", "[AgentSettingsSection] render called");
    }
    containerEl.createEl("h3", { text: "Agent Mode Settings" });
    containerEl.createEl("div", {
      text: "Agent Mode allows the AI to use tools like file creation, reading, and modification. Configure the limits and behavior for tool usage.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Enable Agent Mode by Default",
      "Start new conversations with Agent Mode enabled.",
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.enabled) != null ? _b : false;
      },
      async (value) => {
        if (!this.plugin.settings.agentMode) {
          this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
        }
        this.plugin.settings.agentMode.enabled = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createSliderSetting(
      containerEl,
      "Max Tool Calls per Conversation",
      "Maximum number of tools the AI can use in a single conversation to prevent runaway execution.",
      { min: 1, max: 50, step: 1 },
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxToolCalls) != null ? _b : 10;
      },
      async (value) => {
        if (!this.plugin.settings.agentMode) {
          this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
        }
        this.plugin.settings.agentMode.maxToolCalls = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createSliderSetting(
      containerEl,
      "Tool Execution Timeout (seconds)",
      "Maximum time to wait for each tool to complete before timing out.",
      { min: 5, max: 300, step: 5 },
      () => {
        var _a2, _b;
        return ((_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.timeoutMs) != null ? _b : 3e4) / 1e3;
      },
      async (value) => {
        if (!this.plugin.settings.agentMode) {
          this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
        }
        this.plugin.settings.agentMode.timeoutMs = value * 1e3;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createSliderSetting(
      containerEl,
      "Max Iterations per Task Continuation",
      "Maximum number of times the agent can iterate in a single task continuation to prevent infinite loops.",
      { min: 1, max: 20, step: 1 },
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxIterations) != null ? _b : 10;
      },
      async (value) => {
        if (!this.plugin.settings.agentMode) {
          this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
        }
        this.plugin.settings.agentMode.maxIterations = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h3", { text: "Agent System Message" });
    containerEl.createEl("div", {
      text: "Customize the system message used when Agent Mode is enabled. Use {{TOOL_DESCRIPTIONS}} to include the available tools list.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const agentMessageContainer = containerEl.createDiv("agent-message-container");
    agentMessageContainer.style.display = "flex";
    agentMessageContainer.style.gap = "0.5em";
    agentMessageContainer.style.alignItems = "flex-start";
    agentMessageContainer.style.marginBottom = "1em";
    const textareaContainer = agentMessageContainer.createDiv();
    textareaContainer.style.flex = "1";
    const textarea = textareaContainer.createEl("textarea");
    textarea.rows = 8;
    textarea.style.width = "100%";
    textarea.style.minHeight = "120px";
    textarea.style.fontFamily = "monospace";
    textarea.style.fontSize = "0.9em";
    textarea.placeholder = "Enter custom agent system message template...";
    textarea.value = this.plugin.settings.customAgentSystemMessage || "";
    const buttonContainer = agentMessageContainer.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.flexDirection = "column";
    buttonContainer.style.gap = "0.25em";
    const resetButton = buttonContainer.createEl("button", { text: "Reset to Default" });
    resetButton.style.padding = "0.25em 0.5em";
    resetButton.style.fontSize = "0.8em";
    resetButton.addEventListener("click", async () => {
      textarea.value = AGENT_SYSTEM_PROMPT_TEMPLATE;
      this.plugin.settings.customAgentSystemMessage = AGENT_SYSTEM_PROMPT_TEMPLATE;
      await this.plugin.saveSettings();
    });
    const clearButton = buttonContainer.createEl("button", { text: "Use Default" });
    clearButton.style.padding = "0.25em 0.5em";
    clearButton.style.fontSize = "0.8em";
    clearButton.addEventListener("click", async () => {
      textarea.value = "";
      this.plugin.settings.customAgentSystemMessage = void 0;
      await this.plugin.saveSettings();
    });
    textarea.addEventListener("input", async () => {
      const value = textarea.value.trim();
      this.plugin.settings.customAgentSystemMessage = value || void 0;
      await this.plugin.saveSettings();
    });
    containerEl.createEl("h3", { text: "Agent Tools" });
    this.renderToolToggles(containerEl);
  }
  /**
   * Renders the Tool Enable/Disable section.
   */
  renderToolToggles(containerEl) {
    containerEl.createEl("div", {
      text: "Enable or disable individual agent tools. Disabled tools will not be available to the agent or appear in the system prompt.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const tools = createToolInstances(this.app, this.plugin);
    if (!this.plugin.settings.enabledTools) {
      this.plugin.settings.enabledTools = {};
    }
    tools.forEach((tool) => {
      if (!tool) {
        console.error("[AI Assistant] Settings: Encountered an undefined tool object in tools array!");
        return;
      }
      if (typeof tool.name === "undefined") {
        console.error("[AI Assistant] Settings: CRITICAL - Tool object has undefined name:", tool);
      }
      if (tool.name === "thought") {
        if (!this.plugin.settings.enabledTools) {
          this.plugin.settings.enabledTools = {};
        }
        this.plugin.settings.enabledTools["thought"] = true;
        return;
      }
      this.settingCreators.createToggleSetting(
        containerEl,
        `${tool.name} (${tool.description})`,
        `Enable or disable the "${tool.name}" tool.`,
        () => {
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to get toggle state for tool with undefined name!");
            return false;
          }
          return !!this.plugin.settings.enabledTools && this.plugin.settings.enabledTools[tool.name] !== false;
        },
        async (value) => {
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to set toggle state for tool with undefined name! Skipping save.");
            return;
          }
          if (!this.plugin.settings.enabledTools) {
            this.plugin.settings.enabledTools = {};
          }
          this.plugin.settings.enabledTools[tool.name] = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
};

// src/settings/sections/ContentNoteHandlingSection.ts
var import_obsidian31 = require("obsidian");
var ContentNoteHandlingSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  async render(containerEl) {
    containerEl.createEl("h3", { text: "Chat Customization" });
    this.settingCreators.createTextSetting(
      containerEl,
      "Chat Separator",
      "The string used to separate chat messages.",
      "----",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.chatSeparator) != null ? _a2 : "";
      },
      async (value) => {
        this.plugin.settings.chatSeparator = value != null ? value : "";
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createTextSetting(
      containerEl,
      "Chat Start String",
      "The string that indicates where to start taking the note for context.",
      "===START===",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.chatStartString) != null ? _a2 : "";
      },
      async (value) => {
        this.plugin.settings.chatStartString = value != null ? value : "";
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createTextSetting(
      containerEl,
      "Chat End String",
      "The string that indicates where to end taking the note for context.",
      "===END===",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.chatEndString) != null ? _a2 : "";
      },
      async (value) => {
        this.plugin.settings.chatEndString = value != null ? value : "";
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createTextSetting(
      containerEl,
      "Title Prompt",
      "The prompt used for generating note titles.",
      "You are a title generator...",
      () => this.plugin.settings.titlePrompt,
      async (value) => {
        this.plugin.settings.titlePrompt = value != null ? value : "";
        await this.plugin.saveSettings();
      },
      { isTextArea: true }
    );
    this.settingCreators.createDropdownSetting(
      containerEl,
      "Title Output Mode",
      "Choose what to do with the generated note title.",
      { "clipboard": "Copy to clipboard", "replace-filename": "Replace note filename", "metadata": "Insert into metadata" },
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.titleOutputMode) != null ? _a2 : "clipboard";
      },
      async (value) => {
        this.plugin.settings.titleOutputMode = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createDropdownSetting(
      containerEl,
      "Summary Output Mode",
      "Choose what to do with the generated note summary.",
      { "clipboard": "Copy to clipboard", "metadata": "Insert into metadata" },
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.summaryOutputMode) != null ? _a2 : "clipboard";
      },
      async (value) => {
        this.plugin.settings.summaryOutputMode = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h3", { text: "Note Reference Settings" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Enable Obsidian Links",
      "Read Obsidian links in messages using [[filename]] syntax",
      () => this.plugin.settings.enableObsidianLinks,
      async (value) => {
        this.plugin.settings.enableObsidianLinks = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createToggleSetting(
      containerEl,
      "Enable Context Notes",
      "Attach specified note content to chat messages",
      () => this.plugin.settings.enableContextNotes,
      async (value) => {
        this.plugin.settings.enableContextNotes = value;
        await this.plugin.saveSettings();
      }
    );
    const contextNotesContainer = containerEl.createDiv("context-notes-container");
    contextNotesContainer.style.marginBottom = "24px";
    new import_obsidian31.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
      text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange(async (value) => {
        this.plugin.settings.contextNotes = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    containerEl.createEl("h3", { text: "Data Handling" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Expand Linked Notes Recursively",
      "If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false;
      },
      async (value) => {
        this.plugin.settings.expandLinkedNotesRecursively = value;
        await this.plugin.saveSettings();
      }
    );
    if (this.plugin.settings.expandLinkedNotesRecursively) {
      this.settingCreators.createSliderSetting(
        containerEl,
        "Max Link Expansion Depth",
        "Maximum depth for recursively expanding linked notes (1-3).",
        { min: 1, max: 3, step: 1 },
        () => {
          var _a2;
          return (_a2 = this.plugin.settings.maxLinkExpansionDepth) != null ? _a2 : 2;
        },
        async (value) => {
          this.plugin.settings.maxLinkExpansionDepth = value;
          await this.plugin.saveSettings();
        }
      );
    }
    this.settingCreators.createTextSetting(
      containerEl,
      "Chat Note Folder",
      "Folder to save exported chat notes (relative to vault root, leave blank for root)",
      "e.g. AI Chats",
      () => {
        var _a2;
        return (_a2 = this.plugin.settings.chatNoteFolder) != null ? _a2 : "";
      },
      async (value) => {
        this.plugin.settings.chatNoteFolder = value != null ? value : "";
        await this.plugin.saveSettings();
      },
      { trim: true }
    );
    containerEl.createEl("h3", { text: "YAML Attribute Generators" });
    this.renderYamlAttributeGenerators(containerEl);
  }
  /**
   * Renders the YAML Attribute Generators section.
   */
  renderYamlAttributeGenerators(containerEl) {
    var _a2;
    containerEl.createEl("div", {
      text: "Configure custom YAML attribute generators. Each entry will create a command to generate and insert/update a YAML field in your notes.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const yamlGens = (_a2 = this.plugin.settings.yamlAttributeGenerators) != null ? _a2 : [];
    yamlGens.forEach((gen, idx) => {
      const autoCommandName = gen.attributeName ? `Generate YAML: ${gen.attributeName}` : `YAML Generator #${idx + 1}`;
      const genContainer = containerEl.createDiv({ cls: "yaml-generator-container" });
      genContainer.style.border = "1px solid var(--background-modifier-border)";
      genContainer.style.borderRadius = "6px";
      genContainer.style.padding = "1em";
      genContainer.style.marginBottom = "1em";
      genContainer.createEl("h4", { text: autoCommandName });
      new import_obsidian31.Setting(genContainer).setName("YAML Attribute Name").setDesc("The YAML field name to insert/update").addText((text) => {
        text.setPlaceholder("YAML Attribute Name").setValue(gen.attributeName).onChange(async (value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].attributeName = value != null ? value : "";
            this.plugin.settings.yamlAttributeGenerators[idx].commandName = value ? `Generate YAML: ${value}` : "";
            await this.plugin.saveSettings();
          }
        });
      });
      new import_obsidian31.Setting(genContainer).setName("Prompt for LLM").setDesc("The prompt to send to the AI for generating the YAML value").addTextArea((text) => {
        text.setPlaceholder("Prompt for LLM").setValue(gen.prompt).onChange(async (value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].prompt = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        });
        text.inputEl.rows = 3;
        text.inputEl.style.width = "100%";
      });
      new import_obsidian31.Setting(genContainer).setName("Output Mode").setDesc("Where to put the generated YAML attribute").addDropdown((drop) => {
        drop.addOption("clipboard", "Copy to clipboard");
        drop.addOption("metadata", "Insert into metadata");
        drop.setValue(gen.outputMode);
        drop.onChange(async (value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].outputMode = value;
            await this.plugin.saveSettings();
          }
        });
      });
      new import_obsidian31.Setting(genContainer).addExtraButton((btn) => {
        btn.setIcon("cross").setTooltip("Delete this YAML generator").onClick(async () => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators.splice(idx, 1);
            await this.plugin.saveSettings();
          }
        });
      });
    });
    new import_obsidian31.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add YAML Attribute Generator").setCta().onClick(async () => {
        if (!this.plugin.settings.yamlAttributeGenerators) this.plugin.settings.yamlAttributeGenerators = [];
        this.plugin.settings.yamlAttributeGenerators.push({
          attributeName: "",
          prompt: "",
          outputMode: "metadata",
          commandName: "New YAML Generator"
        });
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/settings/sections/BackupManagementSection.ts
var import_obsidian32 = require("obsidian");

// src/settings/components/DialogHelpers.ts
var DialogHelpers = class {
  /**
   * Shows a confirmation dialog
   */
  static showConfirmationDialog(title, message) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "modal";
      modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
      const content = modal.createDiv();
      content.className = "modal-content";
      content.style.cssText = `
                background-color: var(--background-primary);
                padding: 2rem;
                border-radius: 8px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;
      content.createEl("h3", { text: title });
      content.createEl("p", { text: message });
      const buttonContainer = content.createDiv();
      buttonContainer.style.cssText = `
                display: flex;
                gap: 1rem;
                justify-content: flex-end;
                margin-top: 1rem;
            `;
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(false);
      };
      const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" });
      confirmBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(true);
      };
      document.body.appendChild(modal);
      modal.onclick = (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          resolve(false);
        }
      };
    });
  }
};

// src/settings/sections/BackupManagementSection.ts
var BackupManagementSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  async render(containerEl) {
    await this.renderBackupManagement(containerEl);
    await this.renderTrashManagement(containerEl);
  }
  /**
   * Renders the Backup Management section.
   * @param containerEl The HTML element to append the section to.
   */
  async renderBackupManagement(containerEl) {
    containerEl.createEl("h3", { text: "Backup Management" });
    containerEl.createEl("div", {
      text: "Manage backups created when files are modified by AI tools. Backups are stored in the plugin data folder, not in your vault.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const backupManager = this.plugin.backupManager;
    const totalBackups = await backupManager.getTotalBackupCount();
    const totalSize = await backupManager.getTotalBackupSize();
    const sizeInKB = Math.round(totalSize / 1024);
    containerEl.createEl("div", {
      text: `Total backups: ${totalBackups} (${sizeInKB} KB)`,
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em; font-weight: bold;" }
    });
    const actionsContainer = containerEl.createDiv({ attr: { style: "margin-bottom: 1em;" } });
    const refreshButton = actionsContainer.createEl("button", {
      text: "Refresh Backup List",
      cls: "mod-cta"
    });
    refreshButton.style.marginRight = "0.5em";
    refreshButton.onclick = () => {
      this.renderBackupManagement(containerEl.parentElement);
    };
    const backupFiles = await backupManager.getAllBackupFiles();
    if (backupFiles.length > 0) {
      const deleteAllBtn = actionsContainer.createEl("button", {
        text: "Delete All Backups",
        cls: "mod-warning"
      });
      deleteAllBtn.onclick = async () => {
        const totalBackups2 = await backupManager.getTotalBackupCount();
        const confirmed = await DialogHelpers.showConfirmationDialog(
          "Delete All Backups",
          `Are you sure you want to delete ALL ${totalBackups2} backups for ALL files? This action cannot be undone and will permanently remove all backup data.`
        );
        if (confirmed) {
          try {
            await backupManager.deleteAllBackups();
            new import_obsidian32.Notice("Deleted all backups successfully");
            this.renderBackupManagement(containerEl.parentElement);
          } catch (error) {
            new import_obsidian32.Notice(`Error deleting all backups: ${error.message}`);
          }
        }
      };
    }
    if (backupFiles.length === 0) {
      containerEl.createEl("div", {
        text: "No backups found.",
        cls: "setting-item-description"
      });
      return;
    }
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Backup Files List",
      (backupListEl) => {
        this.renderBackupFilesList(backupListEl, backupFiles, backupManager);
      },
      this.plugin,
      "backupManagementExpanded"
    );
  }
  async renderBackupFilesList(containerEl, backupFiles, backupManager) {
    for (const filePath of backupFiles) {
      const backups = await backupManager.getBackupsForFile(filePath);
      if (backups.length === 0) continue;
      const fileSection = containerEl.createDiv({ cls: "backup-file-section" });
      fileSection.createEl("h4", { text: filePath, cls: "backup-file-path" });
      const backupList = fileSection.createDiv({ cls: "backup-list" });
      backups.forEach((backup) => {
        const backupItem = backupList.createDiv({ cls: "backup-item" });
        const backupInfo = backupItem.createDiv({ cls: "backup-info" });
        const sizeKB = backup.fileSize ? Math.round(backup.fileSize / 1024) : 0;
        const fileType = backup.isBinary ? "Binary" : "Text";
        backupInfo.createEl("span", {
          text: `${backup.readableTimestamp} (${sizeKB} KB, ${fileType})`,
          cls: "backup-timestamp"
        });
        const backupActions = backupItem.createDiv({ cls: "backup-actions" });
        const restoreBtn = backupActions.createEl("button", {
          text: "Restore",
          cls: "mod-cta"
        });
        restoreBtn.onclick = async () => {
          const confirmed = await DialogHelpers.showConfirmationDialog(
            // Use DialogHelpers
            "Restore Backup",
            `Are you sure you want to restore the backup from ${backup.readableTimestamp}? This will overwrite the current file content.`
          );
          if (confirmed) {
            try {
              const result = await backupManager.restoreBackup(backup);
              if (result.success) {
                new import_obsidian32.Notice(`Successfully restored backup for ${filePath}`);
              } else {
                new import_obsidian32.Notice(`Failed to restore backup: ${result.error}`);
              }
            } catch (error) {
              new import_obsidian32.Notice(`Error restoring backup: ${error.message}`);
            }
          }
        };
        const deleteBtn = backupActions.createEl("button", {
          text: "Delete",
          cls: "mod-warning"
        });
        deleteBtn.onclick = async () => {
          const confirmed = await DialogHelpers.showConfirmationDialog(
            // Use DialogHelpers
            "Delete Backup",
            `Are you sure you want to delete the backup from ${backup.readableTimestamp}?`
          );
          if (confirmed) {
            try {
              await backupManager.deleteSpecificBackup(filePath, backup.timestamp);
              new import_obsidian32.Notice(`Deleted backup for ${filePath}`);
            } catch (error) {
              new import_obsidian32.Notice(`Error deleting backup: ${error.message}`);
            }
          }
        };
        if (!backup.isBinary && backup.content) {
          const previewBtn = backupActions.createEl("button", {
            text: "Preview",
            cls: "mod-muted"
          });
          previewBtn.onclick = () => {
            const preview = backup.content.substring(0, 200);
            const truncated = backup.content.length > 200 ? "..." : "";
            new import_obsidian32.Notice(`Preview: ${preview}${truncated}`, 1e4);
          };
        } else if (backup.isBinary) {
          const infoBtn = backupActions.createEl("button", {
            text: "File Info",
            cls: "mod-muted"
          });
          infoBtn.onclick = () => {
            const sizeKB2 = backup.fileSize ? Math.round(backup.fileSize / 1024) : 0;
            new import_obsidian32.Notice(`Binary file backup: ${sizeKB2} KB
Stored at: ${backup.backupFilePath || "Unknown location"}`, 5e3);
          };
        }
      });
      const deleteAllBtn = fileSection.createEl("button", {
        text: `Delete All Backups for ${filePath}`,
        cls: "mod-warning"
      });
      deleteAllBtn.onclick = async () => {
        const confirmed = await DialogHelpers.showConfirmationDialog(
          // Use DialogHelpers
          "Delete All Backups",
          `Are you sure you want to delete all ${backups.length} backups for ${filePath}?`
        );
        if (confirmed) {
          try {
            await backupManager.deleteBackupsForFile(filePath);
            new import_obsidian32.Notice(`Deleted all backups for ${filePath}`);
          } catch (error) {
            new import_obsidian32.Notice(`Error deleting backups: ${error.message}`);
          }
        }
      };
    }
  }
  /**
   * Renders the Trash Management section.
   * @param containerEl The HTML element to append the section to.
   */
  async renderTrashManagement(containerEl) {
    var _a2;
    containerEl.createEl("div", { attr: { style: "margin-top: 2em; border-top: 1px solid var(--background-modifier-border); padding-top: 1em;" } });
    containerEl.createEl("h3", { text: "Trash Management" });
    containerEl.createEl("div", {
      text: "Manage files and folders moved to the .trash folder. Files in trash can be restored or permanently deleted.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const trashPath = ".trash";
    let trashFolder = this.plugin.app.vault.getAbstractFileByPath(trashPath);
    console.log("[AI Assistant Debug] .trash lookup:", trashFolder, "Type:", (_a2 = trashFolder == null ? void 0 : trashFolder.constructor) == null ? void 0 : _a2.name);
    let trashItems = [];
    let fallbackUsed = false;
    if (!trashFolder) {
      fallbackUsed = true;
      try {
        const adapter = this.plugin.app.vault.adapter;
        if (await adapter.exists(trashPath)) {
          const files = await adapter.list(trashPath);
          trashItems = [
            ...files.files.map((f) => ({ name: f.substring(f.lastIndexOf("/") + 1), isFolder: false })),
            ...files.folders.map((f) => ({ name: f.substring(f.lastIndexOf("/") + 1), isFolder: true }))
          ];
        } else {
          containerEl.createEl("div", {
            text: "No trash folder found. Trash folder will be created automatically when files are deleted with soft delete.",
            cls: "setting-item-description"
          });
          return;
        }
      } catch (e) {
        containerEl.createEl("div", {
          text: "Error reading trash folder from file system.",
          cls: "setting-item-description"
        });
        return;
      }
    } else if (trashFolder instanceof import_obsidian32.TFolder) {
      trashItems = trashFolder.children.map((item) => ({
        name: item.name,
        isFolder: item instanceof import_obsidian32.TFolder,
        size: item instanceof import_obsidian32.TFile && item.stat ? item.stat.size : void 0
      }));
    } else {
      containerEl.createEl("div", {
        text: "Error: .trash exists but is not a folder.",
        cls: "setting-item-description"
      });
      return;
    }
    const fileCount = trashItems.filter((item) => !item.isFolder).length;
    const folderCount = trashItems.filter((item) => item.isFolder).length;
    containerEl.createEl("div", {
      text: `Trash contains: ${fileCount} files, ${folderCount} folders${fallbackUsed ? " (filesystem fallback)" : ""}`,
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em; font-weight: bold;" }
    });
    const actionsContainer = containerEl.createDiv({ attr: { style: "margin-bottom: 1em;" } });
    const refreshBtn = actionsContainer.createEl("button", {
      text: "Refresh Trash",
      cls: "mod-cta"
    });
    refreshBtn.style.marginRight = "0.5em";
    refreshBtn.onclick = () => {
      this.renderTrashManagement(containerEl.parentElement);
    };
    if (trashItems.length > 0) {
      const emptyTrashBtn = actionsContainer.createEl("button", {
        text: "Empty Trash",
        cls: "mod-warning"
      });
      emptyTrashBtn.style.marginRight = "0.5em";
      emptyTrashBtn.onclick = async () => {
        const confirmed = await DialogHelpers.showConfirmationDialog(
          "Empty Trash",
          `Are you sure you want to permanently delete all ${trashItems.length} items in trash? This cannot be undone.`
        );
        if (confirmed) {
          try {
            const adapter = this.plugin.app.vault.adapter;
            for (const item of trashItems) {
              const fullPath = `${trashPath}/${item.name}`;
              if (item.isFolder) {
                await adapter.rmdir(fullPath, true);
              } else {
                await adapter.remove(fullPath);
              }
            }
            new import_obsidian32.Notice(`Emptied trash - permanently deleted ${trashItems.length} items`);
            this.renderTrashManagement(containerEl.parentElement);
          } catch (error) {
            new import_obsidian32.Notice(`Error emptying trash: ${error.message}`);
          }
        }
      };
    }
    if (trashItems.length === 0) {
      containerEl.createEl("div", {
        text: "Trash is empty.",
        cls: "setting-item-description"
      });
      return;
    }
    const trashList = containerEl.createDiv({ cls: "trash-list" });
    for (const item of trashItems.slice(0, 20)) {
      const trashItem = trashList.createDiv({ cls: "trash-item", attr: { style: "margin-bottom: 0.5em; padding: 0.5em; border: 1px solid var(--background-modifier-border); border-radius: 4px;" } });
      const itemInfo = trashItem.createDiv({ cls: "trash-item-info" });
      const icon = item.isFolder ? "\u{1F4C1}" : "\u{1F4C4}";
      const size = !item.isFolder && item.size ? ` (${Math.round(item.size / 1024)} KB)` : "";
      itemInfo.createEl("span", {
        text: `${icon} ${item.name}${size}`,
        cls: "trash-item-name"
      });
      const itemActions = trashItem.createDiv({ cls: "trash-item-actions", attr: { style: "margin-top: 0.5em;" } });
      if (!fallbackUsed) {
        const restoreBtn = itemActions.createEl("button", {
          text: "Restore",
          cls: "mod-cta"
        });
        restoreBtn.style.marginRight = "0.5em";
        restoreBtn.onclick = async () => {
          const confirmed = await DialogHelpers.showConfirmationDialog(
            "Restore Item",
            `Restore "${item.name}" to vault root? If an item with the same name exists, it will be overwritten.`
          );
          if (confirmed) {
            try {
              const trashFolderObj = this.plugin.app.vault.getAbstractFileByPath(trashPath);
              if (trashFolderObj instanceof import_obsidian32.TFolder) {
                const fileObj = trashFolderObj.children.find((child) => child.name === item.name);
                if (fileObj) {
                  const newPath = item.name;
                  await this.plugin.app.fileManager.renameFile(fileObj, newPath);
                  new import_obsidian32.Notice(`Restored "${item.name}" to vault root`);
                  this.renderTrashManagement(containerEl.parentElement);
                }
              }
            } catch (error) {
              new import_obsidian32.Notice(`Error restoring item: ${error.message}`);
            }
          }
        };
      }
      const deleteBtn = itemActions.createEl("button", {
        text: "Delete Permanently",
        cls: "mod-warning"
      });
      deleteBtn.onclick = async () => {
        const confirmed = await DialogHelpers.showConfirmationDialog(
          "Delete Permanently",
          `Permanently delete "${item.name}"? This cannot be undone.`
        );
        if (confirmed) {
          try {
            const adapter = this.plugin.app.vault.adapter;
            const fullPath = `${trashPath}/${item.name}`;
            if (item.isFolder) {
              await adapter.rmdir(fullPath, true);
            } else {
              await adapter.remove(fullPath);
            }
            new import_obsidian32.Notice(`Permanently deleted "${item.name}"`);
            this.renderTrashManagement(containerEl.parentElement);
          } catch (error) {
            new import_obsidian32.Notice(`Error deleting item: ${error.message}`);
          }
        }
      };
    }
    if (trashItems.length > 20) {
      containerEl.createEl("div", {
        text: `... and ${trashItems.length - 20} more items. Empty trash to remove all items.`,
        cls: "setting-item-description",
        attr: { style: "margin-top: 1em; font-style: italic;" }
      });
    }
  }
};

// src/settings/sections/ChatHistorySettingsSection.ts
var ChatHistorySettingsSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  async render(containerEl) {
    containerEl.createEl("h3", { text: "Chat History & Sessions" });
    this.settingCreators.createSliderSetting(
      containerEl,
      "Max Chat Sessions",
      "Maximum number of chat sessions to keep in history.",
      { min: 1, max: 50, step: 1 },
      () => this.plugin.settings.maxSessions,
      async (value) => {
        this.plugin.settings.maxSessions = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createToggleSetting(
      containerEl,
      "Auto-Save Sessions",
      "Automatically save chat sessions as you use them.",
      () => this.plugin.settings.autoSaveSessions,
      async (value) => {
        this.plugin.settings.autoSaveSessions = value;
        await this.plugin.saveSettings();
      }
    );
    containerEl.createEl("h3", { text: "UI Behavior" });
    this.settingCreators.createToggleSetting(
      containerEl,
      "Collapse Old Reasoning",
      "Automatically collapse reasoning sections in older messages to keep the UI clean",
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.collapseOldReasoning) != null ? _b : true;
      },
      async (value) => {
        if (!this.plugin.settings.uiBehavior) {
          this.plugin.settings.uiBehavior = {};
        }
        this.plugin.settings.uiBehavior.collapseOldReasoning = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createToggleSetting(
      containerEl,
      "Show Completion Notifications",
      "Show notifications when AI responses are completed",
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.showCompletionNotifications) != null ? _b : true;
      },
      async (value) => {
        if (!this.plugin.settings.uiBehavior) {
          this.plugin.settings.uiBehavior = {};
        }
        this.plugin.settings.uiBehavior.showCompletionNotifications = value;
        await this.plugin.saveSettings();
      }
    );
    this.settingCreators.createToggleSetting(
      containerEl,
      "Include Reasoning in Exports",
      "Include reasoning sections when copying or exporting chat content",
      () => {
        var _a2, _b;
        return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.includeReasoningInExports) != null ? _b : true;
      },
      async (value) => {
        if (!this.plugin.settings.uiBehavior) {
          this.plugin.settings.uiBehavior = {};
        }
        this.plugin.settings.uiBehavior.includeReasoningInExports = value;
        await this.plugin.saveSettings();
      }
    );
  }
};

// src/settings/SettingTab.ts
var MyPluginSettingTab = class extends import_obsidian33.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    // Section instances
    __publicField(this, "generalSettingsSection");
    __publicField(this, "aiModelConfigurationSection");
    __publicField(this, "agentSettingsSection");
    __publicField(this, "contentNoteHandlingSection");
    __publicField(this, "backupManagementSection");
    __publicField(this, "chatHistorySettingsSection");
    __publicField(this, "settingsChangeListener", null);
    this.plugin = plugin;
    this.settingCreators = new SettingCreators(this.plugin, () => this.display());
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("debug", "[MyPluginSettingTab] constructor called");
    }
    this.generalSettingsSection = new GeneralSettingsSection(this.plugin, this.settingCreators);
    this.aiModelConfigurationSection = new AIModelConfigurationSection(this.plugin, this.settingCreators);
    this.agentSettingsSection = new AgentSettingsSection(this.app, this.plugin, this.settingCreators);
    this.contentNoteHandlingSection = new ContentNoteHandlingSection(this.plugin, this.settingCreators);
    this.backupManagementSection = new BackupManagementSection(this.plugin, this.settingCreators);
    this.chatHistorySettingsSection = new ChatHistorySettingsSection(this.plugin, this.settingCreators);
    this.settingsChangeListener = () => {
      if (this.containerEl.isConnected) {
        this.display();
      }
    };
    this.plugin.onSettingsChange(this.settingsChangeListener);
  }
  hide() {
    if (this.settingsChangeListener) {
      this.plugin.offSettingsChange(this.settingsChangeListener);
      this.settingsChangeListener = null;
    }
    super.hide();
  }
  /**
   * Display the settings tab.
   * This method orchestrates the rendering of all setting sections.
   */
  display() {
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("info", "[MyPluginSettingTab] display called");
    }
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Assistant Settings" });
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "General Settings",
      (sectionEl) => this.generalSettingsSection.render(sectionEl),
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "AI Model Configuration",
      (sectionEl) => this.aiModelConfigurationSection.render(sectionEl),
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Settings",
      (sectionEl) => this.agentSettingsSection.render(sectionEl),
      this.plugin,
      "agentConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Content & Note Handling",
      (sectionEl) => this.contentNoteHandlingSection.render(sectionEl),
      this.plugin,
      "contentChatExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Chat History & UI",
      (sectionEl) => this.chatHistorySettingsSection.render(sectionEl),
      this.plugin,
      "dataHandlingExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Backup & Trash Management",
      (sectionEl) => this.backupManagementSection.render(sectionEl),
      this.plugin,
      "backupManagementExpanded"
    );
    new import_obsidian33.Setting(containerEl).setName("Reset All Settings to Default").setDesc("Reset all plugin settings (except API keys) to their original default values.").addButton((button) => button.setButtonText("Reset").onClick(async () => {
      const { DEFAULT_SETTINGS: DEFAULT_SETTINGS2 } = await Promise.resolve().then(() => (init_types(), types_exports));
      const { DEFAULT_TITLE_PROMPT: DEFAULT_TITLE_PROMPT2 } = await Promise.resolve().then(() => (init_promptConstants(), promptConstants_exports));
      const preservedApiKeys = {
        openai: this.plugin.settings.openaiSettings.apiKey,
        anthropic: this.plugin.settings.anthropicSettings.apiKey,
        gemini: this.plugin.settings.geminiSettings.apiKey
      };
      this.plugin.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS2));
      this.plugin.settings.openaiSettings.apiKey = preservedApiKeys.openai;
      this.plugin.settings.anthropicSettings.apiKey = preservedApiKeys.anthropic;
      this.plugin.settings.geminiSettings.apiKey = preservedApiKeys.gemini;
      this.plugin.settings.titlePrompt = DEFAULT_TITLE_PROMPT2;
      await this.plugin.saveSettings();
      this.display();
      setTimeout(() => {
        activateView(this.plugin.app, VIEW_TYPE_MODEL_SETTINGS);
      }, 100);
      new import_obsidian33.Notice("All settings (except API keys) reset to default.");
    }));
  }
};

// src/components/ModelSettingsView.ts
var import_obsidian34 = require("obsidian");
var VIEW_TYPE_MODEL_SETTINGS2 = "model-settings-view";
var ModelSettingsView = class extends import_obsidian34.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "_onSettingsChange", () => {
      this.onOpen();
    });
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MODEL_SETTINGS2;
  }
  getDisplayText() {
    return "AI Model Settings";
  }
  getIcon() {
    return "file-sliders";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.plugin.offSettingsChange(this._onSettingsChange);
    this.plugin.onSettingsChange(this._onSettingsChange);
    const settingsSections = new (await Promise.resolve().then(() => (init_SettingsSections(), SettingsSections_exports))).SettingsSections(this.plugin);
    await settingsSections.renderAllSettings(contentEl, { onRefresh: () => this.onOpen() });
  }
  async onClose() {
    this.plugin.offSettingsChange(this._onSettingsChange);
  }
};

// src/utils/logger.ts
function debugLog(debugMode, level = "debug", ...args) {
  if (!debugMode) return;
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
  const prefix = `[AI Assistant ${level.toUpperCase()} ${timestamp2}]`;
  switch (level) {
    case "info":
      console.info(prefix, ...args);
      break;
    case "warn":
      console.warn(prefix, ...args);
      break;
    case "error":
      console.error(prefix, ...args);
      break;
    default:
      console.debug(prefix, ...args);
  }
}

// src/components/chat/agent/agentModeManager.ts
var AgentModeManager = class {
  constructor(settings, saveSettings, emitSettingsChange, debugLog2) {
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.emitSettingsChange = emitSettingsChange;
    this.debugLog = debugLog2;
  }
  getAgentModeSettings() {
    return this.settings.agentMode || {
      enabled: false,
      maxToolCalls: 5,
      timeoutMs: 3e4,
      maxIterations: 10
    };
  }
  isAgentModeEnabled() {
    return this.getAgentModeSettings().enabled;
  }
  // Debug: Log when agent mode is toggled
  async setAgentModeEnabled(enabled) {
    this.debugLog("info", "[agentModeManager.ts] setAgentModeEnabled called", { enabled });
    if (!this.settings.agentMode) {
      this.settings.agentMode = {
        enabled: false,
        maxToolCalls: 5,
        timeoutMs: 3e4,
        maxIterations: 10
      };
      this.debugLog("debug", "[agentModeManager.ts] Initialized agentMode settings");
    }
    this.settings.agentMode.enabled = enabled;
    await this.saveSettings();
    this.emitSettingsChange();
    this.debugLog("info", "[agentModeManager.ts] Agent mode enabled state set", { enabled });
  }
};

// src/main.ts
init_BackupManager();
init_ToolRichDisplay();
init_YAMLHandler();
var _MyPlugin = class _MyPlugin extends import_obsidian35.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "modelSettingsView", null);
    __publicField(this, "activeStream", null);
    __publicField(this, "_yamlAttributeCommandIds", []);
    __publicField(this, "settingsListeners", []);
    __publicField(this, "backupManager");
    __publicField(this, "agentModeManager");
  }
  onSettingsChange(listener) {
    this.settingsListeners.push(listener);
  }
  offSettingsChange(listener) {
    this.settingsListeners = this.settingsListeners.filter((l) => l !== listener);
  }
  emitSettingsChange() {
    for (const listener of this.settingsListeners) {
      try {
        listener();
      } catch (e) {
        console.error(e);
      }
    }
  }
  // --- Agent Mode State Integration ---
  getAgentModeSettings() {
    return this.settings.agentMode || {
      enabled: false,
      maxToolCalls: 5,
      timeoutMs: 3e4,
      maxIterations: 10
    };
  }
  isAgentModeEnabled() {
    return this.getAgentModeSettings().enabled;
  }
  // Debug: Log when agent mode is toggled
  async setAgentModeEnabled(enabled) {
    this.debugLog("info", "[main.ts] setAgentModeEnabled called", { enabled });
    if (!this.settings.agentMode) {
      this.settings.agentMode = {
        enabled: false,
        maxToolCalls: 5,
        timeoutMs: 3e4,
        maxIterations: 10
      };
      this.debugLog("debug", "[main.ts] Initialized agentMode settings");
    }
    this.settings.agentMode.enabled = enabled;
    await this.saveSettings();
    this.emitSettingsChange();
    this.debugLog("info", "[main.ts] Agent mode enabled state set", { enabled });
  }
  /**
   * Helper to activate the chat view and load messages into it.
   * @param messages An array of messages to load.
   */
  async activateChatViewAndLoadMessages(messages) {
    this.debugLog("info", "[main.ts] activateChatViewAndLoadMessages called", { messageCount: messages.length });
    await activateView(this.app, VIEW_TYPE_CHAT);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CHAT);
    if (!leaves.length) {
      showNotice("Could not find chat view.");
      this.debugLog("warn", "[main.ts] No chat view found");
      return;
    }
    const chatView = leaves[0].view;
    chatView.clearMessages();
    const { MessageRenderer: MessageRenderer2 } = (init_MessageRenderer(), __toCommonJS(MessageRenderer_exports));
    const messageRenderer = new MessageRenderer2(this.app);
    for (const msg of messages) {
      if (msg.role === "user" || msg.role === "assistant") {
        const toolData = messageRenderer.parseToolDataFromContent(msg.content);
        if (toolData) {
          const cleanContent = messageRenderer.cleanContentFromToolData(msg.content);
          await chatView["addMessage"](msg.role, cleanContent, false, {
            toolResults: toolData.toolResults,
            reasoning: toolData.reasoning,
            taskStatus: toolData.taskStatus
          });
          this.debugLog("debug", "[main.ts] Added message with tool data", { role: msg.role, toolData });
        } else {
          await chatView["addMessage"](msg.role, msg.content);
          this.debugLog("debug", "[main.ts] Added regular message", { role: msg.role });
        }
      }
    }
    chatView.scrollMessagesToBottom();
    showNotice("Loaded chat note into chat.");
    this.debugLog("info", "[main.ts] Chat note loaded into chat view");
  }
  /**
   * Registers a view type with Obsidian.
   * @param viewType The type of the view.
   * @param viewCreator The function that creates the view.
   */
  registerPluginView(viewType, viewCreator) {
    if (!_MyPlugin.registeredViewTypes.has(viewType)) {
      this.registerView(viewType, viewCreator);
      _MyPlugin.registeredViewTypes.add(viewType);
    }
  }
  async onload() {
    await this.loadSettings();
    const pluginDataPath = this.app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
    this.backupManager = new BackupManager(this.app, pluginDataPath);
    await this.backupManager.initialize();
    this.agentModeManager = new AgentModeManager(
      this.settings,
      () => this.saveSettings(),
      () => this.emitSettingsChange(),
      (level, ...args) => {
        var _a2;
        return debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
      }
    );
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.registerPluginView(VIEW_TYPE_MODEL_SETTINGS, (leaf) => new ModelSettingsView(leaf, this));
    this.registerPluginView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));
    registerViewCommands(this);
    registerAIStreamCommands(
      this,
      this.settings,
      (messages) => this.processMessages(messages),
      { current: this.activeStream },
      (stream) => {
        this.activeStream = stream;
      }
    );
    registerNoteCommands(
      this,
      this.settings,
      (messages) => this.activateChatViewAndLoadMessages(messages)
    );
    registerGenerateNoteTitleCommand(
      this,
      this.settings,
      (messages) => this.processMessages(messages)
    );
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.autoOpenModelSettings) {
        activateView(this.app, VIEW_TYPE_MODEL_SETTINGS);
      }
    });
    this._yamlAttributeCommandIds = registerYamlAttributeCommands(
      this,
      this.settings,
      (messages) => this.processMessages(messages),
      this._yamlAttributeCommandIds,
      (level, ...args) => {
        var _a2;
        return debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
      }
    );
    this.registerMarkdownPostProcessor((element, context) => {
      this.processToolExecutionBlocks(element, context);
    });
    this.registerMarkdownCodeBlockProcessor("ai-tool-execution", (source, el, ctx) => {
      this.processToolExecutionCodeBlock(source, el, ctx);
    });
  }
  /**
   * Enhanced debug logger for the plugin.
   * @param level Log level: 'debug' | 'info' | 'warn' | 'error'. Defaults to 'debug'.
   * @param args Arguments to log.
   */
  debugLog(level = "debug", ...args) {
    var _a2;
    debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
  }
  /**
   * Loads plugin settings from data.
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Saves plugin settings to data.
   * Also re-registers YAML attribute commands and emits a settings change event.
   */
  async saveSettings() {
    await this.saveData(this.settings);
    this._yamlAttributeCommandIds = registerYamlAttributeCommands(
      this,
      this.settings,
      (messages) => this.processMessages(messages),
      this._yamlAttributeCommandIds,
      (level, ...args) => {
        var _a2;
        return debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
      }
    );
    this.emitSettingsChange();
  }
  /**
   * Processes an array of messages, potentially adding context notes.
   * @param messages The messages to process.
   * @returns A promise that resolves to the processed messages.
   */
  async processMessages(messages) {
    return processMessages(messages, this.app, this.settings);
  }
  /**
   * Called when the plugin is unloaded.
   * Unregisters views to prevent issues on reload.
   */
  onunload() {
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_MODEL_SETTINGS);
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_CHAT);
  }
  /**
   * Process ai-tool-execution code blocks specifically for Live Preview mode
   */
  processToolExecutionCodeBlock(source, element, context) {
    this.debugLog("debug", "[main.ts] processToolExecutionCodeBlock called for Live Preview", { source: source.substring(0, 100) + "...", element, context });
    try {
      const toolData = JSON.parse(source);
      this.debugLog("debug", "[main.ts] Parsed tool data from code block", { toolData });
      ToolRichDisplay.renderToolExecutionBlock(toolData, element, async (resultText) => {
        try {
          await navigator.clipboard.writeText(resultText);
          showNotice("Copied to clipboard!");
        } catch (error) {
          console.error("Failed to copy to clipboard:", error);
          showNotice("Failed to copy to clipboard");
        }
      });
      this.debugLog("info", "[main.ts] Rendered tool displays in Live Preview");
    } catch (error) {
      console.error("Failed to parse ai-tool-execution code block:", error);
      this.debugLog("error", "[main.ts] Failed to parse ai-tool-execution code block", { error });
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.textContent = source;
      pre.appendChild(code);
      element.innerHTML = "";
      element.appendChild(pre);
    }
  }
  /**
   * Process ai-tool-execution blocks in markdown and replace them with rich tool displays
   */
  processToolExecutionBlocks(element, context) {
    var _a2, _b;
    this.debugLog("debug", "[main.ts] processToolExecutionBlocks called", { element, context });
    const codeBlocks = element.querySelectorAll("pre > code");
    this.debugLog("debug", "[main.ts] Found code blocks", { count: codeBlocks.length });
    for (const codeBlock of Array.from(codeBlocks)) {
      const codeElement = codeBlock;
      const preElement = codeElement.parentElement;
      this.debugLog("debug", "[main.ts] Checking code block", {
        className: codeElement.className,
        textContent: ((_a2 = codeElement.textContent) == null ? void 0 : _a2.substring(0, 100)) + "..."
      });
      const text = ((_b = codeElement.textContent) == null ? void 0 : _b.trim()) || "";
      const isAIToolExecution = codeElement.className.includes("language-ai-tool-execution") || text.startsWith('{"toolResults"') || text.startsWith('{\n  "toolResults"');
      if (isAIToolExecution) {
        this.debugLog("info", "[main.ts] Found ai-tool-execution block");
        try {
          const toolData = JSON.parse(text);
          this.debugLog("debug", "[main.ts] Parsed tool data", { toolData });
          const toolContainer = document.createElement("div");
          toolContainer.className = "ai-tool-execution-container";
          ToolRichDisplay.renderToolExecutionBlock(toolData, toolContainer, async (resultText) => {
            try {
              await navigator.clipboard.writeText(resultText);
              showNotice("Copied to clipboard!");
            } catch (error) {
              console.error("Failed to copy to clipboard:", error);
              showNotice("Failed to copy to clipboard");
            }
          });
          preElement.replaceWith(toolContainer);
          this.debugLog("info", "[main.ts] Replaced code block with tool displays");
        } catch (error) {
          console.error("Failed to parse ai-tool-execution block:", error);
          this.debugLog("error", "[main.ts] Failed to parse ai-tool-execution block", { error });
        }
      }
    }
  }
};
__publicField(_MyPlugin, "registeredViewTypes", /* @__PURE__ */ new Set());
var MyPlugin = _MyPlugin;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
