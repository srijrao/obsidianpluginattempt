/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/components/agent/tools/FileSearchTool.ts
var FileSearchTool;
var init_FileSearchTool = __esm({
  "src/components/agent/tools/FileSearchTool.ts"() {
    FileSearchTool = class {
      /**
       * The constructor takes the Obsidian app instance so we can access the vault.
       * @param app The main Obsidian app object
       */
      constructor(app) {
        this.app = app;
        // Name of the tool (used for referencing in the plugin system)
        __publicField(this, "name", "file_search");
        // Description of what this tool does
        __publicField(this, "description", "Searches for files within the vault based on a query and specified file types, returning a limited number of results. This tool is useful for quickly locating relevant documents and assets.");
        // Parameters that can be passed to this tool
        __publicField(this, "parameters", {
          query: {
            type: "string",
            description: "Search query for files.",
            required: false
          },
          filterType: {
            type: "string",
            enum: ["markdown", "image", "all"],
            description: "Type of files to include.",
            default: "markdown"
          },
          maxResults: {
            type: "number",
            description: "Maximum number of results.",
            default: 10
          },
          searchContent: {
            type: "boolean",
            description: "Whether to search within file contents. Defaults to false.",
            required: false
          },
          useRegex: {
            type: "boolean",
            description: "If true, treat the query as a regular expression.",
            required: false
          }
        });
      }
      /**
       * Main function to execute the file search.
       * @param params The search parameters (query, filterType, etc)
       * @param context (Unused, but required by Tool interface)
       * @returns ToolResult with matching files or an error message
       */
      async execute(params, context) {
        const { query = "", filterType = "markdown", maxResults = 10, searchContent = false, useRegex = false } = params;
        try {
          const allFiles = filterType === "markdown" ? this.app.vault.getMarkdownFiles() : filterType === "image" ? this.app.vault.getFiles().filter((f) => {
            var _a2;
            return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = f.extension) == null ? void 0 : _a2.toLowerCase());
          }) : this.app.vault.getFiles();
          let matchingFiles = [];
          if (query.trim()) {
            let regex = null;
            if (useRegex) {
              try {
                regex = new RegExp(query, "i");
              } catch (e) {
                return {
                  success: false,
                  error: `Invalid regular expression: ${e.message}`
                };
              }
            }
            const normalizedQuery = query.toLowerCase();
            const queryWords = useRegex ? [] : normalizedQuery.split(/\s+/).filter((word) => word.length > 0);
            for (const file of allFiles) {
              let contentMatch = false;
              if (searchContent && file.extension === "md") {
                const fileContent = await this.app.vault.read(file);
                if (useRegex && regex) {
                  contentMatch = regex.test(fileContent);
                } else {
                  contentMatch = queryWords.every((word) => fileContent.toLowerCase().includes(word));
                }
              }
              const searchText = `${file.path} ${file.basename}`.toLowerCase();
              const searchTextNormalized = searchText.replace(/_/g, " ");
              let pathAndNameMatch = false;
              if (useRegex && regex) {
                pathAndNameMatch = regex.test(file.path) || regex.test(file.basename);
              } else {
                pathAndNameMatch = queryWords.every((word) => searchText.includes(word) || searchTextNormalized.includes(word));
              }
              if (pathAndNameMatch || contentMatch) {
                matchingFiles.push(file);
                if (matchingFiles.length >= maxResults) break;
              }
            }
          } else {
            matchingFiles = allFiles.slice(0, maxResults);
          }
          if (matchingFiles.length === 0) {
            return {
              success: false,
              error: `No files found matching query: "${query}"`
            };
          }
          const limitedFiles = matchingFiles.sort((a, b) => {
            var _a2, _b;
            return (((_a2 = b.stat) == null ? void 0 : _a2.mtime) || 0) - (((_b = a.stat) == null ? void 0 : _b.mtime) || 0);
          }).slice(0, maxResults);
          const files = limitedFiles.map((file) => {
            var _a2, _b, _c;
            return {
              path: file.path,
              // Full path in the vault
              name: file.name,
              // File name with extension
              basename: file.basename,
              // File name without extension
              extension: file.extension,
              // File extension (e.g. 'md')
              size: ((_a2 = file.stat) == null ? void 0 : _a2.size) || 0,
              // File size in bytes
              created: ((_b = file.stat) == null ? void 0 : _b.ctime) || 0,
              // Creation time (timestamp)
              modified: ((_c = file.stat) == null ? void 0 : _c.mtime) || 0
              // Last modified time (timestamp)
            };
          });
          return {
            success: true,
            data: {
              files,
              count: files.length,
              query: query || "all files"
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to search files: ${error.message}`
          };
        }
      }
      /**
       * (Advanced) Returns a filter function for files based on filterType.
       * Not used in the main logic, but can be used for custom filtering.
       * @param filterType The type of files to filter ('markdown', 'image', 'all')
       * @returns A function that returns true if the file matches the filter
       */
      getFileFilter(filterType) {
        switch (filterType) {
          case "markdown":
            return (file) => file.extension === "md";
          case "image":
            return (file) => {
              var _a2;
              return ["png", "jpg", "jpeg", "gif", "svg", "webp"].includes((_a2 = file.extension) == null ? void 0 : _a2.toLowerCase());
            };
          case "all":
          default:
            return () => true;
        }
      }
    };
  }
});

// src/utils/typeGuards.ts
function isValidProviderName(value) {
  return typeof value === "string" && VALID_PROVIDER_NAMES.includes(value);
}
function isPluginSettings(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const obj = value;
  return (obj.provider === void 0 || isValidProviderName(obj.provider)) && (obj.debugMode === void 0 || typeof obj.debugMode === "boolean") && (obj.selectedModel === void 0 || typeof obj.selectedModel === "string");
}
function isVaultAdapterWithBasePath(value) {
  return value !== null && typeof value === "object" && "basePath" in value && typeof value.basePath === "string";
}
function getVaultBasePath(app) {
  var _a2;
  try {
    const adapter = (_a2 = app == null ? void 0 : app.vault) == null ? void 0 : _a2.adapter;
    if (isVaultAdapterWithBasePath(adapter)) {
      return adapter.basePath;
    }
    console.warn("Vault adapter basePath not found or not a string. Using empty string as fallback.");
    return "";
  } catch (error) {
    console.warn("Error accessing vault adapter:", error);
    return "";
  }
}
function isPluginWithApp(value) {
  return value !== null && typeof value === "object" && "app" in value && "settings" in value && "saveSettings" in value && typeof value.saveSettings === "function";
}
function isProviderSettings(value) {
  return value !== null && typeof value === "object" && ("apiKey" in value && (typeof value.apiKey === "string" || value.apiKey === void 0) || "serverUrl" in value && (typeof value.serverUrl === "string" || value.serverUrl === void 0));
}
function isObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function validatePluginSettings(value) {
  if (!isPluginSettings(value)) {
    throw new Error("Invalid plugin settings object");
  }
  return value;
}
function isTFile(value) {
  return value !== null && typeof value === "object" && "stat" in value && "basename" in value && "extension" in value;
}
function isTFolder(value) {
  return value !== null && typeof value === "object" && "children" in value && "isRoot" in value;
}
async function withTemporarySetting(settings, property, temporaryValue, operation) {
  if (!isObject(settings)) {
    throw new Error("Settings must be an object");
  }
  const originalValue = settings[property];
  try {
    settings[property] = temporaryValue;
    return await operation();
  } finally {
    settings[property] = originalValue;
  }
}
function getProviderSettings(settings, providerType) {
  if (!isObject(settings)) {
    return void 0;
  }
  const settingsKey = `${providerType}Settings`;
  if (!(settingsKey in settings)) {
    return void 0;
  }
  const providerSettings = settings[settingsKey];
  return isProviderSettings(providerSettings) ? providerSettings : void 0;
}
function getPluginApp(plugin) {
  if (isPluginWithApp(plugin)) {
    return plugin.app;
  }
  return void 0;
}
var VALID_PROVIDER_NAMES;
var init_typeGuards = __esm({
  "src/utils/typeGuards.ts"() {
    VALID_PROVIDER_NAMES = ["openai", "anthropic", "gemini", "ollama"];
  }
});

// src/components/agent/tools/pathValidation.ts
var import_path, PathValidator;
var init_pathValidation = __esm({
  "src/components/agent/tools/pathValidation.ts"() {
    import_path = require("path");
    init_typeGuards();
    PathValidator = class {
      /**
       * Constructs a PathValidator for the given Obsidian app.
       * @param app The Obsidian App instance.
       */
      constructor(app) {
        this.app = app;
        __publicField(this, "vaultPath");
        this.vaultPath = getVaultBasePath(this.app);
      }
      /**
       * Validates and normalizes a path to ensure it's within the vault.
       * Converts absolute paths to vault-relative, and prevents directory traversal.
       * @param inputPath The input path (can be relative to vault or absolute).
       * @returns The normalized vault-relative path, or throws an error if invalid.
       */
      validateAndNormalizePath(inputPath) {
        if (inputPath === void 0 || inputPath === null || typeof inputPath !== "string") {
          throw new Error("Path must be a string");
        }
        const cleanPath = inputPath.trim();
        if (cleanPath === "" || cleanPath === "." || cleanPath === "./" || cleanPath === "/") {
          return "";
        }
        let normalizedPath;
        if ((0, import_path.isAbsolute)(cleanPath)) {
          const absoluteVaultPath = (0, import_path.normalize)(this.vaultPath);
          const absoluteInputPath = (0, import_path.normalize)(cleanPath);
          if (!absoluteInputPath.startsWith(absoluteVaultPath)) {
            throw new Error(`Path '${cleanPath}' is outside the vault. Only paths within the vault are allowed.`);
          }
          normalizedPath = (0, import_path.relative)(absoluteVaultPath, absoluteInputPath);
        } else {
          normalizedPath = (0, import_path.normalize)(cleanPath);
          if (normalizedPath.startsWith("../") || normalizedPath.includes("/../") || normalizedPath === "..") {
            throw new Error(`Path '${cleanPath}' attempts to access files outside the vault. Only paths within the vault are allowed.`);
          }
        }
        normalizedPath = normalizedPath.replace(/\\/g, "/");
        if (normalizedPath.startsWith("/")) {
          normalizedPath = normalizedPath.substring(1);
        }
        if (normalizedPath === "." || normalizedPath === "./") {
          normalizedPath = "";
        }
        return normalizedPath;
      }
      /**
       * Validates that a path is safe for use within the vault.
       * Throws if invalid, returns true if valid.
       * @param inputPath The path to validate.
       * @returns True if the path is valid, throws an error otherwise.
       */
      validatePath(inputPath) {
        try {
          this.validateAndNormalizePath(inputPath);
          return true;
        } catch (error) {
          throw error;
        }
      }
      /**
       * Gets the vault's base path (absolute path on disk).
       * @returns The absolute path to the vault root.
       */
      getVaultPath() {
        return this.vaultPath;
      }
      /**
       * Converts a vault-relative path to an absolute path.
       * @param vaultRelativePath The vault-relative path.
       * @returns The absolute path on disk.
       */
      toAbsolutePath(vaultRelativePath) {
        const normalizedVaultPath = this.validateAndNormalizePath(vaultRelativePath);
        return (0, import_path.join)(this.vaultPath, normalizedVaultPath);
      }
      /**
       * Checks if two paths refer to the same file within the vault.
       * @param path1 First path.
       * @param path2 Second path.
       * @returns True if the normalized paths are equal.
       */
      pathsEqual(path1, path22) {
        try {
          const normalized1 = this.validateAndNormalizePath(path1);
          const normalized2 = this.validateAndNormalizePath(path22);
          return normalized1 === normalized2;
        } catch (error) {
          return false;
        }
      }
    };
  }
});

// src/utils/logger.ts
function debugLog(debugMode, level = "debug", ...args) {
  if (!debugMode) return;
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
  const prefix = `[AI Assistant ${level.toUpperCase()} ${timestamp2}]`;
  switch (level) {
    case "info":
      console.info(prefix, ...args);
      break;
    case "warn":
      console.warn(prefix, ...args);
      break;
    case "error":
      console.error(prefix, ...args);
      break;
    default:
      console.debug(prefix, ...args);
  }
}
var init_logger = __esm({
  "src/utils/logger.ts"() {
  }
});

// src/utils/fileUtils.ts
function getFileOrFolderByPath(app, path3, debugMode) {
  debugLog(debugMode, "debug", "[fileUtils] Attempting to get file or folder by path:", path3);
  let fileOrFolder = null;
  if (path3 === "" || path3 === "/") {
    fileOrFolder = app.vault.getRoot();
  } else {
    fileOrFolder = app.vault.getAbstractFileByPath(path3);
    if (!fileOrFolder && path3.endsWith("/")) {
      const allFolders = app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian.TFolder);
      const match = allFolders.find((f) => f.path.toLowerCase() === path3.toLowerCase());
      if (match) fileOrFolder = match;
    }
  }
  if (fileOrFolder) {
    debugLog(debugMode, "debug", "[fileUtils] Found file or folder:", fileOrFolder.path);
    return fileOrFolder;
  }
  debugLog(debugMode, "warn", "[fileUtils] File or folder not found:", path3);
  return void 0;
}
function getTFileByPath(app, path3, debugMode) {
  const fileOrFolder = getFileOrFolderByPath(app, path3, debugMode);
  if (fileOrFolder && isTFile(fileOrFolder)) {
    return fileOrFolder;
  }
  debugLog(debugMode, "warn", "[fileUtils] Path does not point to a valid TFile:", path3);
  return void 0;
}
function getTFolderByPath(app, path3, debugMode) {
  const fileOrFolder = getFileOrFolderByPath(app, path3, debugMode);
  if (fileOrFolder && isTFolder(fileOrFolder)) {
    return fileOrFolder;
  }
  debugLog(debugMode, "warn", "[fileUtils] Path does not point to a valid TFolder:", path3);
  return void 0;
}
async function ensureFolderExists(app, folderPath, debugMode) {
  debugLog(debugMode, "debug", "[fileUtils] Ensuring folder exists:", folderPath);
  if (!folderPath) return true;
  const folder = app.vault.getAbstractFileByPath(folderPath);
  if (folder) {
    if (isTFolder(folder)) {
      debugLog(debugMode, "debug", "[fileUtils] Folder already exists:", folderPath);
      return true;
    } else {
      debugLog(debugMode, "warn", "[fileUtils] Path exists but is not a folder:", folderPath);
      return false;
    }
  }
  try {
    await app.vault.createFolder(folderPath);
    debugLog(debugMode, "info", "[fileUtils] Created folder:", folderPath);
    return true;
  } catch (error) {
    if (error.message && /already exists/i.test(error.message)) {
      debugLog(debugMode, "warn", "[fileUtils] Folder already exists (race condition):", folderPath);
      return true;
    }
    debugLog(debugMode, "error", "[fileUtils] Failed to create folder:", folderPath, error);
    return false;
  }
}
var import_obsidian;
var init_fileUtils = __esm({
  "src/utils/fileUtils.ts"() {
    import_obsidian = require("obsidian");
    init_logger();
    init_typeGuards();
  }
});

// src/components/agent/tools/FileReadTool.ts
var FileReadTool;
var init_FileReadTool = __esm({
  "src/components/agent/tools/FileReadTool.ts"() {
    init_pathValidation();
    init_fileUtils();
    init_logger();
    FileReadTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_read");
        __publicField(this, "description", "Reads and retrieves the content of a specified file from the vault, with an option to limit the maximum file size. This tool is fundamental for accessing and processing file data.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          maxSize: {
            type: "number",
            description: "Maximum file size in bytes.",
            default: 1024 * 1024
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file read operation.
       * Validates the path, checks file size, reads content, and returns cleaned content.
       * @param params FileReadParams
       * @param context Execution context (unused)
       * @returns ToolResult with file content or error
       */
      async execute(params, context) {
        var _a2, _b, _c, _d, _e, _f;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        const inputPath = params.path || params.filePath;
        const { maxSize = 1024 * 1024 } = params;
        if (inputPath === void 0 || inputPath === null) {
          debugLog(debugMode, "warn", "[FileReadTool] Missing path parameter");
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
          debugLog(debugMode, "debug", "[FileReadTool] Normalized filePath:", filePath);
        } catch (error) {
          debugLog(debugMode, "error", "[FileReadTool] Path validation failed:", error);
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        try {
          const file = getTFileByPath(this.app, filePath, debugMode);
          if (!file) {
            debugLog(debugMode, "warn", "[FileReadTool] File not found:", filePath);
            return {
              success: false,
              error: `File not found: ${filePath}`
            };
          }
          if (((_d = file.stat) == null ? void 0 : _d.size) && file.stat.size > maxSize) {
            debugLog(debugMode, "warn", "[FileReadTool] File too large:", { filePath, size: file.stat.size, maxSize });
            return {
              success: false,
              error: `File too large (${file.stat.size} bytes, max ${maxSize} bytes): ${filePath}`
            };
          }
          let content = await this.app.vault.read(file);
          debugLog(debugMode, "info", "[FileReadTool] File content read", { filePath, size: content.length });
          content = content.split("\n").map((line) => line.replace(/\s+$/g, "")).join("\n").replace(/\n{3,}/g, "\n\n").replace(/ {3,}/g, "  ").replace(/-{6,}/g, "-----").trim();
          return {
            success: true,
            data: {
              content,
              filePath,
              size: ((_e = file.stat) == null ? void 0 : _e.size) || 0,
              modified: ((_f = file.stat) == null ? void 0 : _f.mtime) || 0,
              extension: file.extension
            }
          };
        } catch (error) {
          debugLog(debugMode, "error", "[FileReadTool] Failed to read file:", error);
          return {
            success: false,
            error: `Failed to read file: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/BackupManager.ts
var BackupManager;
var init_BackupManager = __esm({
  "src/components/BackupManager.ts"() {
    init_typeGuards();
    BackupManager = class {
      // Maximum number of backups to keep per file
      /**
       * @param app The Obsidian App instance.
       * @param pluginDataPath The absolute path to the plugin's data folder.
       */
      constructor(app, pluginDataPath) {
        __publicField(this, "app");
        __publicField(this, "backupFilePath");
        __publicField(this, "binaryBackupFolder");
        __publicField(this, "maxBackupsPerFile", 10);
        this.app = app;
        this.backupFilePath = `${pluginDataPath}/backups.json`;
        this.binaryBackupFolder = `${pluginDataPath}/binary-backups`;
      }
      /**
       * Determines if a file is binary based on its extension.
       * Uses a whitelist of known text extensions - everything else is treated as binary.
       * @param filePath The path of the file.
       * @returns True if the file is considered binary, false otherwise.
       */
      isBinaryFile(filePath) {
        const textExtensions = [
          // Markdown and text files
          ".md",
          ".txt",
          ".text",
          ".rtf",
          // Code files
          ".js",
          ".ts",
          ".jsx",
          ".tsx",
          ".html",
          ".htm",
          ".css",
          ".scss",
          ".sass",
          ".less",
          ".json",
          ".xml",
          ".yaml",
          ".yml",
          ".toml",
          ".ini",
          ".conf",
          ".config",
          ".py",
          ".java",
          ".c",
          ".cpp",
          ".h",
          ".hpp",
          ".cs",
          ".php",
          ".rb",
          ".go",
          ".rs",
          ".swift",
          ".kt",
          ".scala",
          ".clj",
          ".hs",
          ".elm",
          ".dart",
          ".r",
          ".m",
          ".pl",
          ".sh",
          ".bash",
          ".zsh",
          ".fish",
          ".ps1",
          ".bat",
          ".cmd",
          // Other common text formats
          ".svg",
          ".csv",
          ".tsv",
          ".log",
          ".sql",
          ".graphql",
          ".gql",
          // Documentation/markup
          ".tex",
          ".latex",
          ".bib",
          ".org",
          ".rst",
          ".asciidoc",
          ".adoc",
          // Config/dotfiles
          ".gitignore",
          ".gitattributes",
          ".editorconfig",
          ".env",
          ".properties",
          // No extension
          ""
        ];
        const extension = filePath.toLowerCase().substring(filePath.lastIndexOf("."));
        return !textExtensions.includes(extension);
      }
      /**
       * Generates a unique backup file path for binary files.
       * Replaces slashes in the original file path to create a flat name.
       * @param filePath The original file path.
       * @param timestamp The timestamp for the backup.
       * @returns The generated backup file path.
       */
      generateBinaryBackupPath(filePath, timestamp2) {
        const fileName = filePath.replace(/[\/\\]/g, "_");
        const extension = filePath.substring(filePath.lastIndexOf("."));
        const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf("."));
        return `${this.binaryBackupFolder}/${nameWithoutExt}_${timestamp2}${extension}`;
      }
      /**
       * Creates a backup of a file's current content.
       * For text files, content is stored directly in JSON. For binary files, content is saved to a separate file.
       * @param filePath The path of the file to backup.
       * @param currentContent Optional: The content of the file if already read (for text files).
       */
      async createBackup(filePath, currentContent) {
        try {
          const backupData = await this.loadBackupData();
          if (!backupData.backups[filePath]) {
            backupData.backups[filePath] = [];
          }
          const timestamp2 = Date.now();
          const readableTimestamp = new Date(timestamp2).toLocaleString();
          const isBinary2 = this.isBinaryFile(filePath);
          let backup;
          if (isBinary2) {
            const file = this.app.vault.getAbstractFileByPath(filePath);
            if (file && isTFile(file)) {
              const fileBuffer = await this.app.vault.readBinary(file);
              const backupFilePath = this.generateBinaryBackupPath(filePath, timestamp2);
              const adapter = this.app.vault.adapter;
              if (!await adapter.exists(this.binaryBackupFolder)) {
                await adapter.mkdir(this.binaryBackupFolder);
              }
              await adapter.writeBinary(backupFilePath, fileBuffer);
              backup = {
                filePath,
                timestamp: timestamp2,
                readableTimestamp,
                isBinary: true,
                fileSize: fileBuffer.byteLength,
                backupFilePath
              };
            } else {
              console.error("Binary file not found or not accessible:", filePath);
              return;
            }
          } else {
            if (currentContent === void 0) {
              const file = this.app.vault.getAbstractFileByPath(filePath);
              if (file && isTFile(file)) {
                currentContent = await this.app.vault.read(file);
              } else {
                console.error("Text file not found or not accessible:", filePath);
                return;
              }
            }
            backup = {
              filePath,
              content: currentContent,
              timestamp: timestamp2,
              readableTimestamp,
              isBinary: false,
              fileSize: currentContent.length
            };
          }
          backupData.backups[filePath].unshift(backup);
          if (backupData.backups[filePath].length > this.maxBackupsPerFile) {
            const removedBackups = backupData.backups[filePath].slice(this.maxBackupsPerFile);
            backupData.backups[filePath] = backupData.backups[filePath].slice(0, this.maxBackupsPerFile);
            for (const removedBackup of removedBackups) {
              if (removedBackup.isBinary && removedBackup.backupFilePath) {
                try {
                  const adapter = this.app.vault.adapter;
                  if (await adapter.exists(removedBackup.backupFilePath)) {
                    await adapter.remove(removedBackup.backupFilePath);
                  }
                } catch (error) {
                  console.error("Failed to clean up old binary backup:", error);
                }
              }
            }
          }
          await this.saveBackupData(backupData);
        } catch (error) {
          console.error("Failed to create backup:", error);
        }
      }
      /**
       * Gets all backups for a specific file.
       * @param filePath The path of the file.
       * @returns An array of FileBackup objects for the specified file.
       */
      async getBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          return backupData.backups[filePath] || [];
        } catch (error) {
          console.error("Failed to get backups for file:", error);
          return [];
        }
      }
      /**
       * Gets all file paths that currently have backups.
       * @returns An array of file paths.
       */
      async getAllBackupFiles() {
        try {
          const backupData = await this.loadBackupData();
          return Object.keys(backupData.backups).filter(
            (path3) => backupData.backups[path3] && backupData.backups[path3].length > 0
          );
        } catch (error) {
          console.error("Failed to get backup files:", error);
          return [];
        }
      }
      /**
       * Restores a specific backup to the vault, overwriting the current file.
       * Creates the file if it doesn't exist.
       * @param backup The FileBackup object to restore.
       * @returns An object indicating success or failure with an error message.
       */
      async restoreBackup(backup) {
        try {
          const file = this.app.vault.getAbstractFileByPath(backup.filePath);
          if (backup.isBinary) {
            if (!backup.backupFilePath) {
              return { success: false, error: "Binary backup file path is missing" };
            }
            const adapter = this.app.vault.adapter;
            if (!await adapter.exists(backup.backupFilePath)) {
              return { success: false, error: `Backup file not found: ${backup.backupFilePath}` };
            }
            const binaryData = await adapter.readBinary(backup.backupFilePath);
            if (!file) {
              await this.app.vault.createBinary(backup.filePath, binaryData);
              return { success: true };
            }
            if (!isTFile(file)) {
              return { success: false, error: `Path is not a file: ${backup.filePath}` };
            }
            await this.app.vault.modifyBinary(file, binaryData);
            return { success: true };
          } else {
            if (!backup.content) {
              return { success: false, error: "Text backup content is missing" };
            }
            if (!file) {
              await this.app.vault.create(backup.filePath, backup.content);
              return { success: true };
            }
            if (!isTFile(file)) {
              return { success: false, error: `Path is not a file: ${backup.filePath}` };
            }
            await this.app.vault.modify(file, backup.content);
            return { success: true };
          }
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
      /**
       * Deletes all backups associated with a specific file.
       * Also removes physical binary backup files.
       * @param filePath The path of the file whose backups are to be deleted.
       */
      async deleteBackupsForFile(filePath) {
        try {
          const backupData = await this.loadBackupData();
          const backups = backupData.backups[filePath];
          if (backups) {
            for (const backup of backups) {
              if (backup.isBinary && backup.backupFilePath) {
                try {
                  const adapter = this.app.vault.adapter;
                  if (await adapter.exists(backup.backupFilePath)) {
                    await adapter.remove(backup.backupFilePath);
                  }
                } catch (error) {
                  console.error("Failed to clean up binary backup file:", error);
                }
              }
            }
          }
          delete backupData.backups[filePath];
          await this.saveBackupData(backupData);
        } catch (error) {
          console.error("Failed to delete backups for file:", error);
        }
      }
      /**
       * Deletes a specific backup entry by file path and timestamp.
       * Also removes the physical binary backup file if applicable.
       * @param filePath The path of the file.
       * @param timestamp The timestamp of the specific backup to delete.
       */
      async deleteSpecificBackup(filePath, timestamp2) {
        try {
          const backupData = await this.loadBackupData();
          if (backupData.backups[filePath]) {
            const backupToDelete = backupData.backups[filePath].find((b) => b.timestamp === timestamp2);
            if (backupToDelete && backupToDelete.isBinary && backupToDelete.backupFilePath) {
              try {
                const adapter = this.app.vault.adapter;
                if (await adapter.exists(backupToDelete.backupFilePath)) {
                  await adapter.remove(backupToDelete.backupFilePath);
                }
              } catch (error) {
                console.error("Failed to clean up binary backup file:", error);
              }
            }
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp !== timestamp2
            );
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to delete specific backup:", error);
        }
      }
      /**
       * Deletes all backups for all files.
       * Removes all metadata and all physical binary backup files.
       */
      async deleteAllBackups() {
        try {
          const backupData = await this.loadBackupData();
          for (const filePath in backupData.backups) {
            const backups = backupData.backups[filePath];
            if (backups) {
              for (const backup of backups) {
                if (backup.isBinary && backup.backupFilePath) {
                  try {
                    const adapter = this.app.vault.adapter;
                    if (await adapter.exists(backup.backupFilePath)) {
                      await adapter.remove(backup.backupFilePath);
                    }
                  } catch (error) {
                    console.error("Failed to clean up binary backup file:", error);
                  }
                }
              }
            }
          }
          await this.saveBackupData({ backups: {} });
        } catch (error) {
          console.error("Failed to delete all backups:", error);
          throw error;
        }
      }
      /**
       * Checks if a new backup should be created for a file.
       * A backup is created if there are no existing backups, or if the new content differs from the most recent backup.
       * For binary files, it always returns true as content comparison is complex.
       * @param filePath The path of the file.
       * @param newContent Optional: The new content of the file (for text files).
       * @returns True if a backup should be created, false otherwise.
       */
      async shouldCreateBackup(filePath, newContent) {
        try {
          const backups = await this.getBackupsForFile(filePath);
          if (backups.length === 0) {
            return true;
          }
          const mostRecentBackup = backups[0];
          if (mostRecentBackup.isBinary) {
            return true;
          } else {
            if (newContent === void 0) {
              const file = this.app.vault.getAbstractFileByPath(filePath);
              if (file && isTFile(file)) {
                newContent = await this.app.vault.read(file);
              } else {
                return true;
              }
            }
            return mostRecentBackup.content !== newContent;
          }
        } catch (error) {
          console.error("Failed to check if backup should be created:", error);
          return true;
        }
      }
      /**
       * Loads backup data from the JSON file.
       * @returns A Promise resolving to the BackupData object.
       */
      async loadBackupData() {
        try {
          const adapter = this.app.vault.adapter;
          if (await adapter.exists(this.backupFilePath)) {
            const content = await adapter.read(this.backupFilePath);
            const parsed = JSON.parse(content);
            if (parsed && typeof parsed === "object" && parsed.backups) {
              return parsed;
            }
          }
        } catch (error) {
          console.error("Failed to load backup data:", error);
        }
        return { backups: {} };
      }
      /**
       * Saves backup data to the JSON file.
       * Ensures the backup directory exists before writing.
       * @param backupData The BackupData object to save.
       */
      async saveBackupData(backupData) {
        var _a2;
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          try {
            if (!await adapter.exists(backupDir)) {
              await adapter.mkdir(backupDir);
            }
          } catch (mkdirError) {
          }
          const debug2 = (_a2 = window == null ? void 0 : window.aiAssistantPlugin) == null ? void 0 : _a2.debugMode;
          const json2 = debug2 ? JSON.stringify(backupData, null, 2) : JSON.stringify(backupData);
          await adapter.write(this.backupFilePath, json2);
        } catch (error) {
          console.error("Failed to save backup data:", error);
          throw error;
        }
      }
      /**
       * Gets the total number of backups across all files.
       * @returns A Promise resolving to the total count.
       */
      async getTotalBackupCount() {
        try {
          const backupData = await this.loadBackupData();
          return Object.values(backupData.backups).reduce((total, backups) => total + backups.length, 0);
        } catch (error) {
          console.error("Failed to get total backup count:", error);
          return 0;
        }
      }
      /**
       * Gets the total size of all backups in bytes (approximate).
       * For text files, it's content length. For binary, it's file size.
       * @returns A Promise resolving to the total size in bytes.
       */
      async getTotalBackupSize() {
        try {
          const backupData = await this.loadBackupData();
          let totalSize = 0;
          Object.values(backupData.backups).forEach((backups) => {
            backups.forEach((backup) => {
              if (backup.fileSize) {
                totalSize += backup.fileSize;
              } else if (backup.content) {
                totalSize += backup.content.length;
              }
            });
          });
          return totalSize;
        } catch (error) {
          console.error("Failed to get total backup size:", error);
          return 0;
        }
      }
      /**
       * Initializes the backup system by ensuring necessary directories and files exist.
       */
      async initialize() {
        try {
          const adapter = this.app.vault.adapter;
          const backupDir = this.backupFilePath.substring(0, this.backupFilePath.lastIndexOf("/"));
          if (!await adapter.exists(backupDir)) {
            await adapter.mkdir(backupDir);
          }
          if (!await adapter.exists(this.binaryBackupFolder)) {
            await adapter.mkdir(this.binaryBackupFolder);
          }
          if (!await adapter.exists(this.backupFilePath)) {
            await this.saveBackupData({ backups: {} });
          }
        } catch (error) {
          console.error("Failed to initialize backup system:", error);
        }
      }
      /**
       * Cleans up old backups to prevent unlimited growth.
       * Removes backups older than a specified number of days.
       * @param maxDays The maximum number of days to keep backups (default: 30 days).
       */
      async cleanupOldBackups(maxDays = 30) {
        try {
          const backupData = await this.loadBackupData();
          const cutoffTime = Date.now() - maxDays * 24 * 60 * 60 * 1e3;
          let cleaned = false;
          for (const filePath in backupData.backups) {
            const originalLength = backupData.backups[filePath].length;
            const removedBackups = backupData.backups[filePath].filter(
              (backup) => backup.timestamp <= cutoffTime
            );
            backupData.backups[filePath] = backupData.backups[filePath].filter(
              (backup) => backup.timestamp > cutoffTime
            );
            if (backupData.backups[filePath].length < originalLength) {
              cleaned = true;
              for (const removedBackup of removedBackups) {
                if (removedBackup.isBinary && removedBackup.backupFilePath) {
                  try {
                    const adapter = this.app.vault.adapter;
                    if (await adapter.exists(removedBackup.backupFilePath)) {
                      await adapter.remove(removedBackup.backupFilePath);
                    }
                  } catch (error) {
                    console.error("Failed to clean up old binary backup:", error);
                  }
                }
              }
            }
            if (backupData.backups[filePath].length === 0) {
              delete backupData.backups[filePath];
            }
          }
          if (cleaned) {
            await this.saveBackupData(backupData);
          }
        } catch (error) {
          console.error("Failed to cleanup old backups:", error);
        }
      }
    };
  }
});

// src/components/agent/tools/FileWriteTool.ts
var import_obsidian2, FileWriteTool;
var init_FileWriteTool = __esm({
  "src/components/agent/tools/FileWriteTool.ts"() {
    import_obsidian2 = require("obsidian");
    init_BackupManager();
    init_pathValidation();
    init_fileUtils();
    init_logger();
    FileWriteTool = class {
      constructor(app, backupManager) {
        this.app = app;
        __publicField(this, "name", "file_write");
        __publicField(this, "description", "Writes or modifies the content of a file in the vault, with options for creating new files, backing up existing ones, and creating parent directories. This tool is essential for managing file content.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          content: {
            type: "string",
            description: "Content to write.",
            required: true
          },
          createIfNotExists: {
            type: "boolean",
            description: "Create file if it doesn't exist.",
            default: true
          },
          backup: {
            type: "boolean",
            description: "Create backup before modifying.",
            default: true
          },
          createParentFolders: {
            type: "boolean",
            description: "Create parent folders if they don't exist.",
            default: true
            // Changed default to true
          }
        });
        __publicField(this, "backupManager");
        __publicField(this, "pathValidator");
        const defaultPath = app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
        this.backupManager = backupManager || new BackupManager(app, defaultPath);
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file write operation.
       * Handles file creation, backup, and content writing.
       * @param params FileWriteParams (with legacy/alternate keys supported)
       * @param context Execution context (unused)
       * @returns ToolResult indicating success or failure
       */
      async execute(params, context) {
        var _a2, _b, _c;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        const inputPath = params.path || params.filePath || params.filename;
        const { content, createIfNotExists = true, backup = true, createParentFolders = true } = params;
        if (inputPath === void 0 || inputPath === null) {
          debugLog(debugMode, "warn", "[FileWriteTool] Missing path parameter");
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
          debugLog(debugMode, "debug", "[FileWriteTool] Normalized filePath:", filePath);
        } catch (error) {
          debugLog(debugMode, "error", "[FileWriteTool] Path validation failed:", error);
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (content === void 0 || content === null) {
          debugLog(debugMode, "warn", "[FileWriteTool] Missing content parameter");
          return {
            success: false,
            error: "content parameter is required"
          };
        }
        try {
          let file = getTFileByPath(this.app, filePath, debugMode);
          if (!file) {
            if (!createIfNotExists) {
              debugLog(debugMode, "warn", "[FileWriteTool] File not found and createIfNotExists is false", { filePath });
              return {
                success: false,
                error: `File not found and createIfNotExists is false: ${filePath}`
              };
            }
            if (createParentFolders) {
              const parentPath = filePath.substring(0, filePath.lastIndexOf("/"));
              if (parentPath && !await ensureFolderExists(this.app, parentPath, debugMode)) {
                return {
                  success: false,
                  error: `Failed to create parent folder(s) for ${filePath}`
                };
              }
            } else {
              const parentPath = filePath.substring(0, filePath.lastIndexOf("/"));
              if (parentPath && !getTFileByPath(this.app, parentPath, debugMode)) {
                return {
                  success: false,
                  error: `Parent folder does not exist for ${filePath} and createParentFolders is false`
                };
              }
            }
            try {
              file = await this.app.vault.create(filePath, content);
              debugLog(debugMode, "info", "[FileWriteTool] Created file", { filePath });
              return {
                success: true,
                data: {
                  action: "created",
                  filePath,
                  size: content.length
                }
              };
            } catch (createError) {
              debugLog(debugMode, "error", "[FileWriteTool] Failed to create file", { filePath, createError });
              return {
                success: false,
                error: `Failed to create file: ${createError.message}`
              };
            }
          }
          if (!(file instanceof import_obsidian2.TFile)) {
            debugLog(debugMode, "warn", "[FileWriteTool] Path is not a file", { filePath });
            return {
              success: false,
              error: `Path is not a file: ${filePath}`
            };
          }
          let originalContent = void 0;
          if (backup) {
            originalContent = await this.app.vault.read(file);
            const shouldBackup = await this.backupManager.shouldCreateBackup(filePath, content);
            if (shouldBackup) {
              await this.backupManager.createBackup(filePath, originalContent);
              debugLog(debugMode, "info", "[FileWriteTool] Created backup", { filePath });
            }
          }
          if (originalContent === content) {
            debugLog(debugMode, "info", "[FileWriteTool] Content unchanged, skipping write", { filePath });
            return {
              success: true,
              data: {
                action: "unchanged",
                filePath,
                size: content.length,
                backupCreated: backup
              }
            };
          }
          try {
            await this.app.vault.modify(file, content);
            debugLog(debugMode, "info", "[FileWriteTool] Modified file", { filePath });
            return {
              success: true,
              data: {
                action: "modified",
                filePath,
                size: content.length,
                backupCreated: backup
              }
            };
          } catch (modifyError) {
            debugLog(debugMode, "error", "[FileWriteTool] Failed to modify file", { filePath, modifyError });
            return {
              success: false,
              error: `Failed to write file: ${modifyError.message}`
            };
          }
        } catch (error) {
          debugLog(debugMode, "error", "[FileWriteTool] Unexpected error during file write", { filePath, error });
          return {
            success: false,
            error: `Failed to write file: ${error.message}`
          };
        }
      }
    };
  }
});

// node_modules/diff/libesm/diff/base.js
var Diff;
var init_base = __esm({
  "node_modules/diff/libesm/diff/base.js"() {
    Diff = class {
      diff(oldStr, newStr, options = {}) {
        let callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if ("callback" in options) {
          callback = options.callback;
        }
        const oldString = this.castInput(oldStr, options);
        const newString = this.castInput(newStr, options);
        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
        const newTokens = this.removeEmpty(this.tokenize(newString, options));
        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
      }
      diffWithOptionsObj(oldTokens, newTokens, options, callback) {
        var _a2;
        const done = (value) => {
          value = this.postProcess(value, options);
          if (callback) {
            setTimeout(function() {
              callback(value);
            }, 0);
            return void 0;
          } else {
            return value;
          }
        };
        const newLen = newTokens.length, oldLen = oldTokens.length;
        let editLength = 1;
        let maxEditLength = newLen + oldLen;
        if (options.maxEditLength != null) {
          maxEditLength = Math.min(maxEditLength, options.maxEditLength);
        }
        const maxExecutionTime = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : Infinity;
        const abortAfterTimestamp = Date.now() + maxExecutionTime;
        const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
        }
        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
        const execEditLength = () => {
          for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
            let basePath;
            const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
            if (removePath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            let canAdd = false;
            if (addPath) {
              const addPathNewPos = addPath.oldPos - diagonalPath;
              canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
            }
            const canRemove = removePath && removePath.oldPos + 1 < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
              basePath = this.addToPath(addPath, true, false, 0, options);
            } else {
              basePath = this.addToPath(removePath, false, true, 1, options);
            }
            newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
            if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
              return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
            } else {
              bestPath[diagonalPath] = basePath;
              if (basePath.oldPos + 1 >= oldLen) {
                maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
              }
              if (newPos + 1 >= newLen) {
                minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
              }
            }
          }
          editLength++;
        };
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                return callback(void 0);
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
            const ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      }
      addToPath(path3, added, removed, oldPosInc, options) {
        const last = path3.lastComponent;
        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
          return {
            oldPos: path3.oldPos + oldPosInc,
            lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
          };
        } else {
          return {
            oldPos: path3.oldPos + oldPosInc,
            lastComponent: { count: 1, added, removed, previousComponent: last }
          };
        }
      }
      extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
        const newLen = newTokens.length, oldLen = oldTokens.length;
        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
          newPos++;
          oldPos++;
          commonCount++;
          if (options.oneChangePerToken) {
            basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
          }
        }
        if (commonCount && !options.oneChangePerToken) {
          basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
        }
        basePath.oldPos = oldPos;
        return newPos;
      }
      equals(left, right, options) {
        if (options.comparator) {
          return options.comparator(left, right);
        } else {
          return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      }
      removeEmpty(array) {
        const ret = [];
        for (let i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      castInput(value, options) {
        return value;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      tokenize(value, options) {
        return Array.from(value);
      }
      join(chars) {
        return chars.join("");
      }
      postProcess(changeObjects, options) {
        return changeObjects;
      }
      get useLongestToken() {
        return false;
      }
      buildValues(lastComponent, newTokens, oldTokens) {
        const components = [];
        let nextComponent;
        while (lastComponent) {
          components.push(lastComponent);
          nextComponent = lastComponent.previousComponent;
          delete lastComponent.previousComponent;
          lastComponent = nextComponent;
        }
        components.reverse();
        const componentLen = components.length;
        let componentPos = 0, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          const component = components[componentPos];
          if (!component.removed) {
            if (!component.added && this.useLongestToken) {
              let value = newTokens.slice(newPos, newPos + component.count);
              value = value.map(function(value2, i) {
                const oldValue = oldTokens[oldPos + i];
                return oldValue.length > value2.length ? oldValue : value2;
              });
              component.value = this.join(value);
            } else {
              component.value = this.join(newTokens.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
          }
        }
        return components;
      }
    };
  }
});

// node_modules/diff/libesm/diff/line.js
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i = 0; i < linesAndNewlines.length; i++) {
    const line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}
var LineDiff, lineDiff;
var init_line = __esm({
  "node_modules/diff/libesm/diff/line.js"() {
    init_base();
    LineDiff = class extends Diff {
      constructor() {
        super(...arguments);
        this.tokenize = tokenize;
      }
      equals(left, right, options) {
        if (options.ignoreWhitespace) {
          if (!options.newlineIsToken || !left.includes("\n")) {
            left = left.trim();
          }
          if (!options.newlineIsToken || !right.includes("\n")) {
            right = right.trim();
          }
        } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
          if (left.endsWith("\n")) {
            left = left.slice(0, -1);
          }
          if (right.endsWith("\n")) {
            right = right.slice(0, -1);
          }
        }
        return super.equals(left, right, options);
      }
    };
    lineDiff = new LineDiff();
  }
});

// node_modules/diff/libesm/index.js
var init_libesm = __esm({
  "node_modules/diff/libesm/index.js"() {
    init_line();
  }
});

// src/utils/editorUtils.ts
async function getOrOpenFileEditor(app, file, debugMode) {
  debugLog(debugMode, "debug", "[editorUtils] Attempting to get or open editor for file:", file.path);
  try {
    const leaves = app.workspace.getLeavesOfType("markdown");
    for (const leaf2 of leaves) {
      if (leaf2.view && "file" in leaf2.view && leaf2.view.file === file) {
        debugLog(debugMode, "debug", "[editorUtils] Found existing editor for file");
        if ("editor" in leaf2.view && leaf2.view.editor) {
          app.workspace.setActiveLeaf(leaf2);
          return leaf2.view.editor;
        }
      }
    }
    debugLog(debugMode, "debug", "[editorUtils] File not open, attempting to open it");
    const leaf = app.workspace.getUnpinnedLeaf();
    if (leaf) {
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      if (leaf.view && "editor" in leaf.view && leaf.view.editor) {
        debugLog(debugMode, "debug", "[editorUtils] Successfully opened file and got editor");
        return leaf.view.editor;
      }
    }
    debugLog(debugMode, "warn", "[editorUtils] Could not get or create editor for file");
    return void 0;
  } catch (error) {
    debugLog(debugMode, "error", "[editorUtils] Error getting or opening editor:", error);
    return void 0;
  }
}
var init_editorUtils = __esm({
  "src/utils/editorUtils.ts"() {
    init_logger();
  }
});

// src/components/agent/tools/FileDiffTool.ts
function showFileChangeSuggestionsModal(app, suggestions) {
  new FileChangeSuggestionsModal(app, suggestions).open();
}
var import_obsidian3, FileChangeSuggestionsModal, FileDiffTool;
var init_FileDiffTool = __esm({
  "src/components/agent/tools/FileDiffTool.ts"() {
    import_obsidian3 = require("obsidian");
    init_libesm();
    init_pathValidation();
    init_logger();
    init_editorUtils();
    init_fileUtils();
    FileChangeSuggestionsModal = class extends import_obsidian3.Modal {
      constructor(app, suggestions) {
        super(app);
        __publicField(this, "suggestions");
        this.suggestions = suggestions;
      }
      /**
       * Called when the modal is opened.
       * Sets up the modal UI and renders suggestions.
       */
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("ai-assistant-modal");
        contentEl.style.minWidth = "600px";
        contentEl.style.maxWidth = "80vw";
        contentEl.style.minHeight = "400px";
        contentEl.style.maxHeight = "80vh";
        contentEl.style.overflowY = "auto";
        contentEl.createEl("h2", { text: "File Change Suggestions" });
        this.renderSuggestions();
      }
      /**
       * Renders all suggestions in the modal.
       * Each suggestion shows the file path, diff, and accept/reject buttons.
       */
      renderSuggestions() {
        const { contentEl } = this;
        Array.from(contentEl.querySelectorAll(".suggestion-container, .no-suggestions")).forEach((el) => el.remove());
        if (!this.suggestions.length) {
          contentEl.createEl("div", { text: "No suggestions available.", cls: "no-suggestions" });
          return;
        }
        this.suggestions.forEach((s, idx) => {
          var _a2;
          const container = contentEl.createDiv("suggestion-container");
          container.createEl("h4", { text: ((_a2 = s.file) == null ? void 0 : _a2.path) || "(No file path)" });
          const diffEl = container.createEl("pre", { cls: "suggestion-diff" });
          diffEl.style.backgroundColor = "#f5f5f5";
          diffEl.style.border = "1px solid #ddd";
          diffEl.style.borderRadius = "4px";
          diffEl.style.padding = "12px";
          diffEl.style.maxHeight = "300px";
          diffEl.style.overflowY = "auto";
          diffEl.style.fontSize = "12px";
          diffEl.style.lineHeight = "1.4";
          if (s.suggestionText) {
            const lines = s.suggestionText.split("\n");
            lines.forEach((line) => {
              const lineEl = diffEl.createEl("div");
              if (line.startsWith("+")) {
                lineEl.style.backgroundColor = "#d4edda";
                lineEl.style.color = "#155724";
              } else if (line.startsWith("-")) {
                lineEl.style.backgroundColor = "#f8d7da";
                lineEl.style.color = "#721c24";
              }
              lineEl.textContent = line;
            });
          } else {
            diffEl.textContent = "(No suggestion text)";
          }
          const btnRow = container.createDiv("suggestion-btn-row");
          const acceptBtn = btnRow.createEl("button", { text: "Accept" });
          const rejectBtn = btnRow.createEl("button", { text: "Reject" });
          acceptBtn.style.backgroundColor = "#28a745";
          acceptBtn.style.color = "white";
          acceptBtn.style.border = "none";
          acceptBtn.style.padding = "8px 16px";
          acceptBtn.style.marginRight = "8px";
          acceptBtn.style.borderRadius = "4px";
          acceptBtn.style.cursor = "pointer";
          rejectBtn.style.backgroundColor = "#dc3545";
          rejectBtn.style.color = "white";
          rejectBtn.style.border = "none";
          rejectBtn.style.padding = "8px 16px";
          rejectBtn.style.borderRadius = "4px";
          rejectBtn.style.cursor = "pointer";
          acceptBtn.onclick = async () => {
            try {
              if (s.onAccept) await s.onAccept();
              new import_obsidian3.Notice("Suggestion accepted");
            } catch (e) {
              new import_obsidian3.Notice("Failed to accept suggestion: " + ((e == null ? void 0 : e.message) || e));
            }
            this.suggestions.splice(idx, 1);
            this.renderSuggestions();
            if (this.suggestions.length === 0) {
              this.close();
            }
          };
          rejectBtn.onclick = async () => {
            try {
              if (s.onReject) await s.onReject();
              new import_obsidian3.Notice("Suggestion rejected");
            } catch (e) {
              new import_obsidian3.Notice("Failed to reject suggestion: " + ((e == null ? void 0 : e.message) || e));
            }
            this.suggestions.splice(idx, 1);
            this.renderSuggestions();
            if (this.suggestions.length === 0) {
              this.close();
            }
          };
        });
      }
      /**
       * Called when the modal is closed.
       * Cleans up the modal content.
       */
      onClose() {
        this.contentEl.empty();
      }
    };
    FileDiffTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_diff");
        __publicField(this, "description", "Manages file changes: presents suggestions for user review. This tool is essential for precise file manipulation and collaborative editing workflows.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file.",
            required: true
          },
          originalContent: {
            type: "string",
            description: "Original content for comparison.",
            required: false
          },
          suggestedContent: {
            type: "string",
            description: "New content for the file.",
            required: true
          },
          insertPosition: {
            type: "number",
            description: "Line number for suggestion insertion.",
            required: false
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file diff tool.
       * Loads the file, generates a diff, and presents a modal for user review.
       * @param params FileDiffParams
       * @param context Execution context (may include debugMode)
       * @returns ToolResult indicating success or failure
       */
      async execute(params, context) {
        var _a2, _b, _c;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        debugLog(debugMode, "debug", "[FileDiffTool] execute called with params:", params);
        const inputPath = params.path || params.filePath;
        const suggestedContent = params.suggestedContent || params.text;
        const { originalContent, insertPosition, editor } = params;
        if (inputPath === void 0 || inputPath === null) {
          debugLog(debugMode, "warn", "[FileDiffTool] Missing path parameter");
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
          debugLog(debugMode, "debug", "[FileDiffTool] Normalized filePath:", filePath);
        } catch (error) {
          debugLog(debugMode, "error", "[FileDiffTool] Path validation failed:", error);
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (!suggestedContent) {
          debugLog(debugMode, "warn", "[FileDiffTool] Missing suggestedContent parameter");
          return {
            success: false,
            error: "suggestedContent parameter is required"
          };
        }
        try {
          const file = getTFileByPath(this.app, filePath, debugMode);
          debugLog(debugMode, "debug", "[FileDiffTool] Got file:", file);
          if (!file) {
            debugLog(debugMode, "warn", "[FileDiffTool] File not found or not a TFile:", filePath);
            return {
              success: false,
              error: `File not found: ${filePath}`
            };
          }
          const currentContent = originalContent || await this.app.vault.read(file);
          debugLog(debugMode, "debug", "[FileDiffTool] Current content loaded.");
          let activeEditor = editor;
          if (!activeEditor) {
            activeEditor = await getOrOpenFileEditor(this.app, file, debugMode);
          }
          if (activeEditor) {
            return await this.showInlineSuggestion(activeEditor, file, currentContent, suggestedContent, insertPosition, debugMode);
          } else {
            debugLog(debugMode, "debug", "[FileDiffTool] No editor available, generating text-based diff suggestion");
            const diff = this.generateDiff(currentContent, suggestedContent, debugMode);
            if (diff.length === 0) {
              debugLog(debugMode, "debug", "[FileDiffTool] No changes detected");
              return {
                success: true,
                data: {
                  action: "suggest",
                  filePath: file.path,
                  message: "No changes detected between current and suggested content"
                }
              };
            }
            return {
              success: true,
              data: {
                action: "suggest",
                filePath: file.path,
                diff,
                originalContent: currentContent,
                suggestedContent,
                message: `Suggested changes for ${file.path}:

${diff}`
              }
            };
          }
        } catch (error) {
          debugLog(debugMode, "error", "[FileDiffTool] Failed to process file diff:", error);
          return {
            success: false,
            error: `Failed to process file diff: ${error.message}`
          };
        }
      }
      /**
       * Shows a modal with the diff suggestion and handles user acceptance/rejection.
       * @param editor The active editor for the file.
       * @param file The TFile being edited.
       * @param currentContent The current file content.
       * @param suggestedContent The new content to suggest.
       * @param insertPosition Optional line number for insertion.
       * @param debugMode Whether to log debug output.
       * @returns ToolResult indicating modal was shown.
       */
      async showInlineSuggestion(editor, file, currentContent, suggestedContent, insertPosition, debugMode) {
        debugLog(debugMode, "debug", "[FileDiffTool] showInlineSuggestion called");
        const diff = this.generateDiff(currentContent, suggestedContent, debugMode);
        debugLog(debugMode, "debug", "[FileDiffTool] Suggestion diff:", diff);
        if (diff.length === 0) {
          debugLog(debugMode, "debug", "[FileDiffTool] No changes detected");
          return {
            success: true,
            data: {
              action: "suggest",
              filePath: file.path,
              message: "No changes detected"
            }
          };
        }
        debugLog(debugMode, "debug", "[FileDiffTool] Showing file change suggestion modal");
        const suggestion = {
          file,
          suggestionText: diff,
          onAccept: async () => {
            debugLog(debugMode, "debug", "[FileDiffTool] User accepted suggestion");
            await this.app.vault.modify(file, suggestedContent);
            new import_obsidian3.Notice(`Applied changes to ${file.path}`);
          },
          onReject: async () => {
            debugLog(debugMode, "debug", "[FileDiffTool] User rejected suggestion");
            new import_obsidian3.Notice(`Rejected changes to ${file.path}`);
          }
        };
        showFileChangeSuggestionsModal(this.app, [suggestion]);
        return {
          success: true,
          data: {
            action: "modal-suggest",
            filePath: file.path,
            diff,
            message: `Showing diff suggestion modal for ${file.path}`
          }
        };
      }
      /**
       * Generates a unified diff string between the original and suggested content.
       * Uses the diffLines function to compute line-by-line differences.
       * Lines added are prefixed with '+', removed with '-', unchanged lines are omitted.
       * @param original The original file content.
       * @param suggested The new (suggested) file content.
       * @param debugMode Whether to log debug output.
       * @returns A unified diff string.
       */
      generateDiff(original, suggested, debugMode) {
        debugLog(debugMode, "debug", "[FileDiffTool] generateDiff called");
        const diffParts = diffLines(original, suggested);
        const diff = [];
        for (const part of diffParts) {
          const lines = part.value.split("\n");
          if (lines[lines.length - 1] === "") lines.pop();
          for (const line of lines) {
            if (part.added) {
              diff.push(`+${line}`);
            } else if (part.removed) {
              diff.push(`-${line}`);
            }
          }
        }
        debugLog(debugMode, "debug", "[FileDiffTool] Diff result:", diff);
        return diff.join("\n");
      }
      /**
       * Utility function to clean up any remaining suggestion blocks from a file.
       * Can be called manually if needed to remove leftover suggestion blocks.
       * @param filePath The path of the file to clean up.
       * @returns ToolResult indicating cleanup status.
       */
      async cleanupSuggestionBlocks(filePath) {
        const debugMode = true;
        try {
          const file = getTFileByPath(this.app, filePath, debugMode);
          if (!file) {
            return {
              success: false,
              error: `File not found: ${filePath}`
            };
          }
          const content = await this.app.vault.read(file);
          const cleanedContent = content.replace(/```suggestion[\s\S]*?```\s*/gm, "");
          if (content !== cleanedContent) {
            await this.app.vault.modify(file, cleanedContent);
            return {
              success: true,
              data: {
                action: "cleanup",
                filePath: file.path,
                message: "Cleaned up suggestion blocks from file"
              }
            };
          } else {
            return {
              success: true,
              data: {
                action: "cleanup",
                filePath: file.path,
                message: "No suggestion blocks found to clean up"
              }
            };
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to clean up suggestion blocks: ${error.message}`
          };
        }
      }
    };
  }
});

// src/components/agent/tools/FileMoveTool.ts
var import_obsidian4, FileMoveTool;
var init_FileMoveTool = __esm({
  "src/components/agent/tools/FileMoveTool.ts"() {
    import_obsidian4 = require("obsidian");
    init_pathValidation();
    init_fileUtils();
    FileMoveTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_move");
        __publicField(this, "description", "Relocates or renames files within the vault, providing options to create necessary directories and handle existing files. This tool is vital for organizing and restructuring content.");
        __publicField(this, "parameters", {
          sourcePath: {
            type: "string",
            description: "Path of the source file.",
            required: false
          },
          path: {
            type: "string",
            description: "Alias for sourcePath.",
            required: false
          },
          destinationPath: {
            type: "string",
            description: "New path for the file.",
            required: false
          },
          newName: {
            type: "string",
            description: "New name for the file (if renaming within same folder). If provided, destinationPath is ignored.",
            required: false
          },
          createFolders: {
            type: "boolean",
            description: "Create parent folders if they don't exist.",
            default: true
          },
          overwrite: {
            type: "boolean",
            description: "Whether to overwrite destination if it exists.",
            default: false
          }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file move/rename operation.
       * @param params FileMoveParams (with possible legacy/alias keys)
       * @param context Execution context (unused)
       * @returns ToolResult indicating success or failure
       */
      async execute(params, context) {
        var _a2, _b, _c;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        let inputSourcePath = params.sourcePath || params.path;
        let inputDestinationPath = params.destinationPath;
        const newName = params.newName;
        const { createFolders = true, overwrite = false } = params;
        if (!inputSourcePath) {
          return {
            success: false,
            error: "sourcePath or path parameter is required."
          };
        }
        let sourcePath;
        try {
          sourcePath = this.pathValidator.validateAndNormalizePath(inputSourcePath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed for sourcePath: ${error.message}`
          };
        }
        let finalDestinationPath;
        if (newName) {
          const sourceFile = getTFileByPath(this.app, sourcePath, debugMode);
          if (!sourceFile) {
            return {
              success: false,
              error: `Source file not found or is not a file: ${sourcePath}`
            };
          }
          const parent = sourceFile.parent;
          if (!parent) {
            return {
              success: false,
              error: `Parent folder not found for file: ${sourcePath}`
            };
          }
          finalDestinationPath = parent.path ? `${parent.path}/${newName}` : newName;
        } else if (inputDestinationPath) {
          try {
            finalDestinationPath = this.pathValidator.validateAndNormalizePath(inputDestinationPath);
          } catch (error) {
            return {
              success: false,
              error: `Path validation failed for destinationPath: ${error.message}`
            };
          }
        } else {
          return {
            success: false,
            error: "destinationPath or newName parameter is required."
          };
        }
        try {
          const sourceFile = getTFileByPath(this.app, sourcePath, debugMode);
          if (!sourceFile) {
            return {
              success: false,
              error: `Source file not found: ${sourcePath}`
            };
          }
          const destinationExists = this.app.vault.getAbstractFileByPath(finalDestinationPath);
          if (destinationExists && !overwrite) {
            return {
              success: false,
              error: `Destination already exists and overwrite is not enabled: ${finalDestinationPath}`
            };
          }
          const lastSlashIndex = finalDestinationPath.lastIndexOf("/");
          const destinationFolder = lastSlashIndex !== -1 ? finalDestinationPath.substring(0, lastSlashIndex) : "";
          if (destinationFolder && createFolders) {
            const folderExists = getTFolderByPath(this.app, destinationFolder, debugMode);
            if (!folderExists) {
              await this.app.vault.createFolder(destinationFolder);
            } else if (!(folderExists instanceof import_obsidian4.TFolder)) {
              return {
                success: false,
                error: `Destination parent path is not a folder: ${destinationFolder}`
              };
            }
          }
          await this.app.fileManager.renameFile(sourceFile, finalDestinationPath);
          return {
            success: true,
            data: {
              action: "moved",
              sourcePath,
              destinationPath: finalDestinationPath
            }
          };
        } catch (error) {
          return {
            success: false,
            error: `Failed to move/rename file: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }
    };
  }
});

// src/components/agent/tools/ThoughtTool.ts
var ThoughtTool;
var init_ThoughtTool = __esm({
  "src/components/agent/tools/ThoughtTool.ts"() {
    ThoughtTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "thought");
        __publicField(this, "description", 'Record AI reasoning and suggest next tool. When nextTool is "finished", include final response in thought parameter. When planning, check the file list tool for available files and folders.');
        __publicField(this, "parameters", {
          thought: {
            type: "string",
            description: "The reasoning step to record",
            required: true
          },
          nextTool: {
            type: "string",
            description: 'Next tool name or "finished" if complete. ALWAYS use "finished" to indicate no further action is needed.',
            required: true
          },
          nextActionDescription: {
            type: "string",
            description: "Brief description of next step",
            required: true
          }
        });
      }
      /**
       * Executes the ThoughtTool.
       * Validates parameters, formats the thought, and returns a structured result.
       * @param params ThoughtParams or object with a `parameters` property.
       * @param context Execution context (may include debugLog).
       * @returns ToolResult with formatted thought and metadata.
       */
      async execute(params, context) {
        var _a2;
        if (context && context.plugin && typeof context.plugin.debugLog === "function") {
          context.plugin.debugLog("info", "[ThoughtTool] execute called", { params, context });
        }
        const actualParams = params.parameters || params;
        if ((!actualParams.thought || actualParams.thought.trim().length === 0) && actualParams.reasoning) {
          if (context && context.plugin && typeof context.plugin.debugLog === "function") {
            context.plugin.debugLog("debug", "[ThoughtTool] Aliasing reasoning to thought", { params: actualParams });
          }
          actualParams.thought = actualParams.reasoning;
        }
        if (!actualParams.thought || typeof actualParams.thought !== "string" || actualParams.thought.trim().length === 0) {
          if (context && context.plugin && typeof context.plugin.debugLog === "function") {
            context.plugin.debugLog("warn", "[ThoughtTool] Missing or invalid thought parameter", { params: actualParams });
          }
          return { success: false, error: 'Parameter "thought" is required and must be a non-empty string.' };
        }
        if (!actualParams.nextTool || typeof actualParams.nextTool !== "string" || actualParams.nextTool.trim().length === 0) {
          return {
            success: false,
            error: 'Parameter "nextTool" is required and must be a non-empty string.'
          };
        }
        const thought = actualParams.thought.trim();
        const nextTool = actualParams.nextTool.trim();
        const nextActionDescription = ((_a2 = actualParams.nextActionDescription) == null ? void 0 : _a2.trim()) || void 0;
        const finished = nextTool.toLowerCase() === "finished";
        const step = typeof actualParams.step === "number" && actualParams.step > 0 ? actualParams.step : void 0;
        const totalSteps = typeof actualParams.totalSteps === "number" && actualParams.totalSteps > 0 ? actualParams.totalSteps : void 0;
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const stepInfo = step && totalSteps ? `Step ${step}/${totalSteps}` : step ? `Step ${step}` : "";
        const formattedThought = this.renderThought({
          thought,
          stepInfo,
          timestamp: timestamp2,
          nextTool,
          nextActionDescription,
          finished
        });
        if (context && context.plugin && typeof context.plugin.debugLog === "function") {
          context.plugin.debugLog("info", "[ThoughtTool] ThoughtTool execution complete", { result: { thought: actualParams.thought } });
        }
        return {
          success: true,
          data: {
            thought,
            step,
            totalSteps,
            timestamp: timestamp2,
            nextTool,
            nextActionDescription,
            finished,
            formattedThought
          }
        };
      }
      /**
       * Render a thought in a visually distinct, concise format for MCP tool output.
       * Enhanced to include next tool information and completion status.
       * @param opts - Rendering options
       * @returns Formatted string
       */
      renderThought(opts) {
        const { thought, stepInfo, nextTool, finished } = opts;
        const statusEmoji = finished ? "\u2705" : "\u{1F914}";
        const stepPrefix = stepInfo ? `${stepInfo} ` : "";
        const header = `${statusEmoji} ${stepPrefix}${finished ? "Complete" : `\u2192 ${nextTool}`}`;
        return `${header}
> ${thought}`;
      }
    };
  }
});

// src/components/agent/tools/FileListTool.ts
var import_obsidian5, FileListTool;
var init_FileListTool = __esm({
  "src/components/agent/tools/FileListTool.ts"() {
    import_obsidian5 = require("obsidian");
    init_pathValidation();
    init_fileUtils();
    FileListTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "file_list");
        __publicField(this, "description", "Retrieves a comprehensive list of files and folders within a specified directory, offering options for recursive traversal. This tool is crucial for understanding project structure and navigating the file system.");
        __publicField(this, "parameters", {
          path: { type: "string", description: "Path to the folder.", required: false },
          recursive: { type: "boolean", description: "List files recursively.", default: false },
          maxResults: { type: "number", description: "Maximum number of results to return.", default: 100 }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file listing operation.
       * @param params FileListParams
       * @param context Execution context (unused)
       * @returns ToolResult with the list of files/folders or error
       */
      async execute(params, context) {
        var _a2, _b, _c;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        const inputPath = params.path || params.folderPath || params.folder || "";
        const { recursive = false, maxResults = 100 } = params;
        let folderPath;
        try {
          folderPath = this.pathValidator.validateAndNormalizePath(inputPath);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        const vault = this.app.vault;
        let folder;
        folder = getTFolderByPath(this.app, folderPath, debugMode);
        if (!folder) {
          return {
            success: false,
            error: "Folder not found: " + (folderPath || "(root)")
          };
        }
        const itemsList = [];
        let totalItems = 0;
        const walk = (currentFolder, indent = "", remainingLimit = maxResults) => {
          if (totalItems >= maxResults || remainingLimit <= 0) {
            return;
          }
          const files = currentFolder.children.filter((child) => child instanceof import_obsidian5.TFile);
          const folders = currentFolder.children.filter((child) => child instanceof import_obsidian5.TFolder);
          const folderCount = recursive ? folders.length : 0;
          const fileSlots = Math.max(1, Math.floor(remainingLimit / Math.max(1, folderCount + 1)));
          let filesAdded = 0;
          for (const file of files) {
            if (totalItems >= maxResults || filesAdded >= fileSlots) {
              break;
            }
            itemsList.push(`${indent}\u{1F4C4}${file.name}`);
            totalItems++;
            filesAdded++;
          }
          if (recursive && folderCount > 0) {
            const remainingAfterFiles = remainingLimit - filesAdded;
            const perFolderLimit = Math.max(1, Math.floor(remainingAfterFiles / folderCount));
            for (const subfolder of folders) {
              if (totalItems >= maxResults) {
                break;
              }
              itemsList.push(`${indent}\u{1F4C1}${subfolder.name}/(`);
              totalItems++;
              walk(subfolder, indent + "  ", perFolderLimit);
              if (totalItems < maxResults) {
                itemsList.push(`${indent})`);
              }
            }
          } else {
            for (const subfolder of folders) {
              if (totalItems >= maxResults) {
                break;
              }
              itemsList.push(`${indent}\u{1F4C1}${subfolder.name}/(`);
              totalItems++;
              itemsList.push(`${indent})`);
            }
          }
        };
        try {
          walk(folder);
          const truncated = totalItems >= maxResults;
          const listing = itemsList.join(",\n");
          return {
            success: true,
            data: {
              items: listing,
              count: totalItems,
              path: folderPath,
              recursive,
              maxResults,
              truncated
            }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
    };
  }
});

// src/components/agent/tools/VaultTreeTool.ts
var import_obsidian6, VaultTreeTool;
var init_VaultTreeTool = __esm({
  "src/components/agent/tools/VaultTreeTool.ts"() {
    import_obsidian6 = require("obsidian");
    init_pathValidation();
    init_typeGuards();
    VaultTreeTool = class {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "vault_tree");
        __publicField(this, "description", "Generates a hierarchical tree view of the vault structure, showing only folders and their organization in a visual tree format. Perfect for understanding the overall vault organization.");
        __publicField(this, "parameters", {
          path: { type: "string", description: "Starting path for the tree (defaults to vault root)", required: false },
          maxDepth: { type: "number", description: "Maximum depth to traverse", default: 10 },
          maxItems: { type: "number", description: "Maximum total items to include", default: 200 },
          showFolders: { type: "boolean", description: "Whether to include folders in the tree", default: true }
        });
        __publicField(this, "pathValidator");
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the vault tree generation.
       * Traverses the vault folder structure and builds a tree representation.
       * @param params VaultTreeParams
       * @param context Execution context (unused)
       * @returns ToolResult with the tree string and stats or error
       */
      async execute(params, context) {
        const {
          path: path3 = "",
          maxDepth = 10,
          maxItems = 200,
          showFolders = true
        } = params;
        let startPath;
        try {
          startPath = this.pathValidator.validateAndNormalizePath(path3);
        } catch (error) {
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        const vault = this.app.vault;
        let startFolder;
        if (startPath === "" || startPath === "/") {
          startFolder = vault.getRoot();
        } else {
          startFolder = vault.getAbstractFileByPath(startPath);
        }
        if (!startFolder || !(startFolder instanceof import_obsidian6.TFolder)) {
          return {
            success: false,
            error: "Folder not found: " + (startPath || "(root)")
          };
        }
        const treeLines = [];
        let totalItems = 0;
        let truncated = false;
        const buildTree = (folder, prefix = "", depth = 0) => {
          if (depth > maxDepth || totalItems >= maxItems) {
            if (totalItems >= maxItems) {
              truncated = true;
            }
            return;
          }
          if (depth > 0 && showFolders) {
            const itemCount = folder.children.length;
            treeLines.push(`${prefix}\u{1F4C1}${folder.name}/(${itemCount} items)`);
            totalItems++;
            if (totalItems >= maxItems) {
              truncated = true;
              return;
            }
          }
          const children = [...folder.children];
          children.sort((a, b) => {
            if (isTFolder(a) && isTFile(b)) return -1;
            if (isTFile(a) && isTFolder(b)) return 1;
            if (isTFile(a) && isTFile(b)) return 1;
            if (!isTFile(a) && isTFile(b)) return -1;
            return a.name.localeCompare(b.name);
          });
          const filteredChildren = children.filter((child) => {
            if (isTFolder(child)) return showFolders;
            return false;
          });
          filteredChildren.forEach((child, index) => {
            if (totalItems >= maxItems) {
              truncated = true;
              return;
            }
            const newPrefix = depth > 0 ? prefix + "  " : "";
            if (isTFile(child)) {
            } else if (isTFolder(child)) {
              buildTree(child, newPrefix, depth + 1);
            }
          });
        };
        try {
          if (startPath === "" || startPath === "/") {
            const rootItemCount = startFolder.children.length;
            treeLines.push(`\u{1F4C1}Vault Root/(${rootItemCount} items)`);
            totalItems++;
          }
          buildTree(startFolder, "", startPath === "" || startPath === "/" ? 0 : -1);
          const tree = treeLines.join(",\n");
          const stats = {
            totalItems,
            maxDepth,
            maxItems,
            truncated,
            startPath: startPath || "/",
            showFolders
          };
          return {
            success: true,
            data: {
              tree,
              stats,
              // For compatibility with other tools
              items: tree,
              count: totalItems,
              path: startPath || "/"
            }
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
      /**
       * Returns an emoji icon for a given file extension.
       * Not used in the current tree output, but available for extension.
       * @param extension File extension (without dot)
       * @returns Emoji string
       */
      getFileIcon(extension) {
        const iconMap = {
          "md": "\u{1F4DD}",
          "txt": "\u{1F4C4}",
          "pdf": "\u{1F4D5}",
          "doc": "\u{1F4D8}",
          "docx": "\u{1F4D8}",
          "xls": "\u{1F4CA}",
          "xlsx": "\u{1F4CA}",
          "ppt": "\u{1F4CA}",
          "pptx": "\u{1F4CA}",
          "png": "\u{1F5BC}\uFE0F",
          "jpg": "\u{1F5BC}\uFE0F",
          "jpeg": "\u{1F5BC}\uFE0F",
          "gif": "\u{1F5BC}\uFE0F",
          "svg": "\u{1F5BC}\uFE0F",
          "mp3": "\u{1F3B5}",
          "wav": "\u{1F3B5}",
          "mp4": "\u{1F3AC}",
          "avi": "\u{1F3AC}",
          "zip": "\u{1F4E6}",
          "rar": "\u{1F4E6}",
          "json": "\u2699\uFE0F",
          "yaml": "\u2699\uFE0F",
          "yml": "\u2699\uFE0F",
          "css": "\u{1F3A8}",
          "js": "\u26A1",
          "ts": "\u26A1",
          "html": "\u{1F310}",
          "xml": "\u{1F310}"
        };
        return iconMap[extension.toLowerCase()] || "\u{1F4C4}";
      }
    };
  }
});

// src/components/agent/tools/FileDeleteTool.ts
var FileDeleteTool;
var init_FileDeleteTool = __esm({
  "src/components/agent/tools/FileDeleteTool.ts"() {
    init_BackupManager();
    init_pathValidation();
    init_typeGuards();
    init_fileUtils();
    init_logger();
    FileDeleteTool = class {
      /**
       * Constructor for FileDeleteTool.
       * @param app Obsidian App instance
       * @param backupManager Optional custom BackupManager
       */
      constructor(app, backupManager) {
        this.app = app;
        __publicField(this, "name", "file_delete");
        __publicField(this, "description", "Safely deletes files or folders from the vault by moving them to a .trash folder (default) or permanently deleting them. The trash option provides safer file management and allows restoration. For folders, creates backups of all contained files before deletion.");
        __publicField(this, "parameters", {
          path: {
            type: "string",
            description: "Path to the file or folder to delete.",
            required: true
          },
          backup: {
            type: "boolean",
            description: "Create backup before deletion.",
            default: true
          },
          confirmDeletion: {
            type: "boolean",
            description: "Extra confirmation that deletion is intended.",
            default: true
          },
          useTrash: {
            type: "boolean",
            description: "Move to .trash folder instead of permanent deletion (default: true for safety).",
            default: true
          }
        });
        __publicField(this, "backupManager");
        __publicField(this, "pathValidator");
        const defaultPath = app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
        this.backupManager = backupManager || new BackupManager(app, defaultPath);
        this.pathValidator = new PathValidator(app);
      }
      /**
       * Executes the file/folder deletion operation.
       * @param params FileDeleteParams
       * @param context Execution context (unused)
       * @returns ToolResult indicating success or failure
       */
      async execute(params, context) {
        var _a2, _b, _c;
        const debugMode = (_c = (_b = (_a2 = context == null ? void 0 : context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) != null ? _c : true;
        const inputPath = params.path || params.filePath;
        const { backup = true, confirmDeletion = true, useTrash = true } = params;
        if (inputPath === void 0 || inputPath === null) {
          debugLog(debugMode, "warn", "[FileDeleteTool] Missing path parameter");
          return {
            success: false,
            error: "path parameter is required"
          };
        }
        let filePath;
        try {
          filePath = this.pathValidator.validateAndNormalizePath(inputPath);
          debugLog(debugMode, "debug", "[FileDeleteTool] Normalized filePath:", filePath);
        } catch (error) {
          debugLog(debugMode, "error", "[FileDeleteTool] Path validation failed:", error);
          return {
            success: false,
            error: `Path validation failed: ${error.message}`
          };
        }
        if (confirmDeletion !== true) {
          debugLog(debugMode, "warn", "[FileDeleteTool] Deletion not confirmed");
          return {
            success: false,
            error: "confirmDeletion must be set to true to proceed with deletion. This is a safety measure."
          };
        }
        try {
          const targetFile = getTFileByPath(this.app, filePath, debugMode);
          const targetFolder = getTFolderByPath(this.app, filePath, debugMode);
          let target;
          if (targetFile) {
            target = targetFile;
          } else if (targetFolder) {
            target = targetFolder;
          }
          if (!target) {
            debugLog(debugMode, "warn", "[FileDeleteTool] File or folder not found:", filePath);
            return {
              success: false,
              error: `File or folder not found: ${filePath}`
            };
          }
          let backupCreated = false;
          let totalSize = 0;
          let backupCount = 0;
          if (isTFile(target)) {
            debugLog(debugMode, "info", "[FileDeleteTool] Deleting file:", filePath);
            let originalContent = "";
            if (backup) {
              try {
                originalContent = await this.app.vault.read(target);
                await this.backupManager.createBackup(filePath, originalContent);
                backupCreated = true;
                backupCount = 1;
                debugLog(debugMode, "info", "[FileDeleteTool] File backup created", { filePath });
              } catch (backupError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to create backup before deletion:", backupError);
                return {
                  success: false,
                  error: `Failed to create backup before deletion: ${backupError.message}`
                };
              }
            }
            let actionTaken = "";
            let trashPath = "";
            if (useTrash) {
              try {
                trashPath = await this.moveToTrash(target, filePath, debugMode);
                actionTaken = "moved to trash";
                debugLog(debugMode, "info", "[FileDeleteTool] File moved to trash", { filePath, trashPath });
              } catch (trashError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to move file to trash:", trashError);
                return {
                  success: false,
                  error: `Failed to move file to trash: ${trashError.message}`
                };
              }
            } else {
              try {
                await this.app.vault.delete(target);
                actionTaken = "permanently deleted";
                debugLog(debugMode, "info", "[FileDeleteTool] File permanently deleted", { filePath });
              } catch (deleteError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete file:", deleteError);
                if (deleteError.message && deleteError.message.includes("EPERM")) {
                  try {
                    await this.app.vault.adapter.remove(filePath);
                    actionTaken = "permanently deleted";
                    debugLog(debugMode, "info", "[FileDeleteTool] File deleted using adapter.remove", { filePath });
                  } catch (adapterError) {
                    debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete file (tried multiple methods):", adapterError);
                    return {
                      success: false,
                      error: `Failed to delete file (tried multiple methods): ${deleteError.message}. Adapter error: ${adapterError.message}`
                    };
                  }
                } else {
                  return {
                    success: false,
                    error: `Failed to delete file: ${deleteError.message}`
                  };
                }
              }
            }
            totalSize = originalContent.length;
            return {
              success: true,
              data: {
                action: actionTaken,
                type: "file",
                filePath,
                trashPath: useTrash ? trashPath : void 0,
                size: totalSize,
                backupCreated,
                backupCount,
                message: `File '${filePath}' has been ${actionTaken}${backupCreated ? " (backup created)" : ""}${useTrash ? `. Location: ${trashPath}` : ""}.`
              }
            };
          } else if (isTFolder(target)) {
            debugLog(debugMode, "info", "[FileDeleteTool] Deleting folder:", filePath);
            if (backup) {
              try {
                const result = await this.createFolderBackups(target, "", debugMode);
                backupCreated = result.backupCreated;
                backupCount = result.backupCount;
                totalSize = result.totalSize;
                debugLog(debugMode, "info", "[FileDeleteTool] Folder backups created", { filePath, backupCount, totalSize });
              } catch (backupError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to create backups before folder deletion:", backupError);
                return {
                  success: false,
                  error: `Failed to create backups before folder deletion: ${backupError.message}`
                };
              }
            }
            let actionTaken = "";
            let trashPath = "";
            if (useTrash) {
              try {
                trashPath = await this.moveToTrash(target, filePath, debugMode);
                actionTaken = "moved to trash";
                debugLog(debugMode, "info", "[FileDeleteTool] Folder moved to trash", { filePath, trashPath });
              } catch (trashError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to move folder to trash:", trashError);
                return {
                  success: false,
                  error: `Failed to move folder to trash: ${trashError.message}`
                };
              }
            } else {
              try {
                await this.app.vault.delete(target);
                actionTaken = "permanently deleted";
                debugLog(debugMode, "info", "[FileDeleteTool] Folder permanently deleted", { filePath });
              } catch (deleteError) {
                debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete folder:", deleteError);
                if (deleteError.message && deleteError.message.includes("EPERM")) {
                  try {
                    await this.app.vault.adapter.rmdir(filePath, true);
                    actionTaken = "permanently deleted";
                    debugLog(debugMode, "info", "[FileDeleteTool] Folder deleted using adapter.rmdir", { filePath });
                  } catch (adapterError) {
                    debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete folder (tried adapter.rmdir):", adapterError);
                    try {
                      await this.recursivelyDeleteFolder(target, debugMode);
                      actionTaken = "permanently deleted";
                      debugLog(debugMode, "info", "[FileDeleteTool] Folder deleted using recursive fallback", { filePath });
                    } catch (recursiveError) {
                      debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete folder (tried recursive fallback):", recursiveError);
                      return {
                        success: false,
                        error: `Failed to delete folder (tried multiple methods): ${deleteError.message}. Last attempt: ${recursiveError.message}`
                      };
                    }
                  }
                } else {
                  return {
                    success: false,
                    error: `Failed to delete folder: ${deleteError.message}`
                  };
                }
              }
            }
            return {
              success: true,
              data: {
                action: actionTaken,
                type: "folder",
                filePath,
                trashPath: useTrash ? trashPath : void 0,
                size: totalSize,
                backupCreated,
                backupCount,
                message: `Folder '${filePath}' has been ${actionTaken}${backupCreated ? ` (${backupCount} files backed up)` : ""}${useTrash ? `. Location: ${trashPath}` : ""}.`
              }
            };
          } else {
            debugLog(debugMode, "error", "[FileDeleteTool] Unsupported file type:", filePath);
            return {
              success: false,
              error: `Unsupported file type: ${filePath}`
            };
          }
        } catch (error) {
          debugLog(debugMode, "error", "[FileDeleteTool] Unexpected error during file deletion:", error);
          return {
            success: false,
            error: `Failed to delete: ${error.message}`
          };
        }
      }
      /**
       * Recursively creates backups for all files in a folder.
       * @param folder TFolder to backup
       * @param basePath Relative path for backup naming
       * @returns Object with backupCreated, backupCount, and totalSize
       */
      async createFolderBackups(folder, basePath, debugMode) {
        debugLog(debugMode, "debug", "[FileDeleteTool] createFolderBackups called for:", folder.path);
        let backupCount = 0;
        let totalSize = 0;
        let anyBackupCreated = false;
        for (const child of folder.children) {
          if (isTFile(child)) {
            try {
              const content = await this.app.vault.read(child);
              const childPath = basePath ? `${basePath}/${child.name}` : child.path;
              await this.backupManager.createBackup(childPath, content);
              backupCount++;
              totalSize += content.length;
              anyBackupCreated = true;
              debugLog(debugMode, "debug", "[FileDeleteTool] Backed up file:", child.path);
            } catch (error) {
              debugLog(debugMode, "error", `[FileDeleteTool] Failed to backup file ${child.path}:`, error);
            }
          } else if (isTFolder(child)) {
            const subResult = await this.createFolderBackups(child, basePath ? `${basePath}/${child.name}` : child.path, debugMode);
            backupCount += subResult.backupCount;
            totalSize += subResult.totalSize;
            if (subResult.backupCreated) {
              anyBackupCreated = true;
            }
          }
        }
        return {
          backupCreated: anyBackupCreated,
          backupCount,
          totalSize
        };
      }
      /**
       * Recursively deletes a folder by deleting all its contents first.
       * This is a fallback method for Windows permission issues.
       * @param folder TFolder to delete
       */
      async recursivelyDeleteFolder(folder, debugMode) {
        debugLog(debugMode, "debug", "[FileDeleteTool] recursivelyDeleteFolder called for:", folder.path);
        for (const child of [...folder.children]) {
          if (isTFile(child)) {
            try {
              await this.app.vault.delete(child);
              debugLog(debugMode, "debug", "[FileDeleteTool] Deleted file in recursive delete:", child.path);
            } catch (error) {
              debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete file in recursive delete (trying adapter.remove):", child.path, error);
              await this.app.vault.adapter.remove(child.path);
            }
          } else if (isTFolder(child)) {
            await this.recursivelyDeleteFolder(child, debugMode);
          }
        }
        try {
          await this.app.vault.delete(folder);
          debugLog(debugMode, "debug", "[FileDeleteTool] Deleted folder in recursive delete:", folder.path);
        } catch (error) {
          debugLog(debugMode, "error", "[FileDeleteTool] Failed to delete folder in recursive delete (trying adapter.rmdir):", folder.path, error);
          await this.app.vault.adapter.rmdir(folder.path, false);
        }
      }
      /**
       * Ensures the .trash folder exists in the vault root.
       * @returns Path to the .trash folder
       */
      async ensureTrashFolderExists(debugMode) {
        debugLog(debugMode, "debug", "[FileDeleteTool] ensureTrashFolderExists called");
        const trashPath = ".trash";
        const success = await ensureFolderExists(this.app, trashPath, debugMode);
        if (!success) {
          throw new Error("Failed to ensure .trash folder exists");
        }
        return trashPath;
      }
      /**
       * Generates a unique name for the trash item to avoid conflicts.
       * @param originalPath Original file/folder path
       * @returns Unique trash name
       */
      generateTrashName(originalPath) {
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
        const basename = originalPath.split("/").pop() || "unknown";
        const extension = basename.includes(".") ? "" : "";
        const nameWithoutExt = basename.replace(/\.[^/.]+$/, "");
        const ext = basename.includes(".") ? basename.substring(basename.lastIndexOf(".")) : "";
        return `${nameWithoutExt}_deleted_${timestamp2}${ext}`;
      }
      /**
       * Moves a file or folder to the trash folder instead of permanently deleting it.
       * @param target TFile or TFolder to move
       * @param originalPath Original path for naming
       * @returns New path in the .trash folder
       */
      async moveToTrash(target, originalPath, debugMode) {
        debugLog(debugMode, "debug", "[FileDeleteTool] moveToTrash called for:", originalPath);
        const trashPath = await this.ensureTrashFolderExists(debugMode);
        const trashName = this.generateTrashName(originalPath);
        const destinationPath = `${trashPath}/${trashName}`;
        await this.app.fileManager.renameFile(target, destinationPath);
        debugLog(debugMode, "info", "[FileDeleteTool] Moved to trash:", destinationPath);
        return destinationPath;
      }
    };
  }
});

// src/components/agent/tools/GetUserFeedback.ts
var GetUserFeedback_exports = {};
__export(GetUserFeedback_exports, {
  GetUserFeedbackTool: () => GetUserFeedbackTool
});
var _GetUserFeedbackTool, GetUserFeedbackTool;
var init_GetUserFeedback = __esm({
  "src/components/agent/tools/GetUserFeedback.ts"() {
    _GetUserFeedbackTool = class _GetUserFeedbackTool {
      constructor(app) {
        this.app = app;
        __publicField(this, "name", "get_user_feedback");
        __publicField(this, "description", "Asks the user a question and waits for their response. Supports both text input and multiple choice questions with interactive buttons. Use this when you need user input to proceed with a task.");
        __publicField(this, "parameters", {
          question: {
            type: "string",
            description: "The question to ask the user",
            required: true
          },
          type: {
            type: "string",
            description: 'Type of response expected: "text" for free text input, "choice" for multiple choice',
            enum: ["text", "choice"],
            default: "text",
            required: false
          },
          choices: {
            type: "array",
            description: 'Array of choices for multiple choice questions (required if type is "choice")',
            items: { type: "string" },
            required: false
          },
          timeout: {
            type: "number",
            description: "Timeout in milliseconds to wait for response (default: 300000 = 5 minutes)",
            default: 3e5,
            required: false
          },
          allowCustomAnswer: {
            type: "boolean",
            description: "For choice type, allow user to provide custom text answer in addition to choices",
            default: false,
            required: false
          },
          placeholder: {
            type: "string",
            description: "Placeholder text for text input",
            required: false
          }
        });
      }
      /**
       * Executes the user feedback request.
       * Returns a special result that allows the UI to show interactive elements while waiting for user response.
       * @param params GetUserFeedbackParams
       * @param context Execution context (unused)
       * @returns ToolResult with pending status and request data for UI creation
       */
      async execute(params, context) {
        const {
          question,
          type: type2 = "text",
          choices = [],
          timeout = 3e5,
          // 5 minutes default
          allowCustomAnswer = false,
          placeholder
        } = params;
        if (!question || question.trim().length === 0) {
          return {
            success: false,
            error: "Question parameter is required and cannot be empty"
          };
        }
        if (type2 === "choice" && (!choices || choices.length === 0)) {
          return {
            success: false,
            error: 'Choices parameter is required and cannot be empty when type is "choice"'
          };
        }
        const requestId = `feedback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const startTime = Date.now();
        return {
          success: true,
          data: {
            requestId,
            status: "pending",
            question,
            type: type2,
            choices,
            timeout,
            allowCustomAnswer,
            placeholder,
            startTime
          }
        };
      }
      /**
       * Creates a pending feedback request after the UI has been displayed.
       * This should be called by the ToolRichDisplay when it creates the interactive UI.
       * @param requestId The request ID from the tool result
       * @param timeout Timeout in milliseconds
       * @returns Promise that resolves when user responds or times out
       */
      static createPendingRequest(requestId, timeout) {
        return new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            _GetUserFeedbackTool.pendingFeedback.delete(requestId);
            reject(new Error(`User feedback timeout after ${timeout}ms`));
          }, timeout);
          _GetUserFeedbackTool.pendingFeedback.set(requestId, {
            resolve,
            reject,
            timeoutId,
            startTime: Date.now()
          });
        });
      }
      /**
       * Static method to handle user response from the UI.
       * Called by the ToolRichDisplay when user interacts with the feedback UI.
       * @param requestId The request ID of the pending feedback
       * @param answer The user's answer
       * @param choiceIndex Optional index of selected choice (for choice type)
       * @param isCustomAnswer Whether this is a custom answer (for choice type with allowCustomAnswer)
       */
      static handleUserResponse(requestId, answer, choiceIndex, isCustomAnswer) {
        const pending = _GetUserFeedbackTool.pendingFeedback.get(requestId);
        if (!pending) {
          console.warn(`No pending feedback request found for ID: ${requestId}`);
          return;
        }
        clearTimeout(pending.timeoutId);
        _GetUserFeedbackTool.pendingFeedback.delete(requestId);
        const responseTimeMs = Date.now() - pending.startTime;
        const response = {
          question: "",
          // This will be populated by the tool execution context
          type: choiceIndex !== void 0 ? "choice" : "text",
          answer,
          choiceIndex,
          isCustomAnswer,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          responseTimeMs
        };
        pending.resolve(response);
      }
      /**
       * Static method to cancel a pending feedback request.
       * @param requestId The request ID to cancel
       */
      static cancelFeedbackRequest(requestId) {
        const pending = _GetUserFeedbackTool.pendingFeedback.get(requestId);
        if (pending) {
          clearTimeout(pending.timeoutId);
          _GetUserFeedbackTool.pendingFeedback.delete(requestId);
          pending.reject(new Error("Feedback request cancelled"));
        }
      }
      /**
       * Static method to get all pending feedback requests.
       * Used for debugging and UI management.
       */
      static getPendingRequests() {
        return Array.from(_GetUserFeedbackTool.pendingFeedback.keys());
      }
      /**
       * Static method to check if a request is pending.
       * @param requestId The request ID to check
       */
      static isPending(requestId) {
        return _GetUserFeedbackTool.pendingFeedback.has(requestId);
      }
    };
    __publicField(_GetUserFeedbackTool, "pendingFeedback", /* @__PURE__ */ new Map());
    GetUserFeedbackTool = _GetUserFeedbackTool;
  }
});

// src/components/agent/tools/toolcollect.ts
function getAllToolClasses() {
  return [
    FileSearchTool,
    FileReadTool,
    FileWriteTool,
    FileDiffTool,
    FileMoveTool,
    ThoughtTool,
    FileListTool,
    VaultTreeTool,
    FileDeleteTool,
    GetUserFeedbackTool
  ];
}
function getToolMetadata() {
  const mockApp = {
    vault: {
      configDir: "",
      adapter: {
        basePath: "/mock/vault/path"
      },
      getAbstractFileByPath: () => null,
      read: () => Promise.resolve(""),
      create: () => Promise.resolve(null),
      modify: () => Promise.resolve()
    }
  };
  const metadata = getAllToolClasses().map((ToolClass) => {
    let instance;
    try {
      instance = new ToolClass();
    } catch (e) {
      try {
        instance = new ToolClass(void 0, void 0);
      } catch (e2) {
        try {
          instance = new ToolClass(mockApp);
        } catch (e3) {
          try {
            instance = new ToolClass(mockApp, void 0);
          } catch (e4) {
            console.warn(`Failed to instantiate tool class ${ToolClass.name} for metadata:`, e4);
            return void 0;
          }
        }
      }
    }
    if (!instance || !instance.name || !instance.description || !instance.parameters) {
      console.warn(`Tool instance missing required properties:`, {
        name: instance == null ? void 0 : instance.name,
        description: instance == null ? void 0 : instance.description,
        parameters: instance == null ? void 0 : instance.parameters
      });
      return void 0;
    }
    let parameterDescriptions = {};
    let parameterRequired = {};
    if (instance.parameters && typeof instance.parameters === "object") {
      for (const [param, value] of Object.entries(instance.parameters)) {
        if (value && typeof value === "object") {
          if ("description" in value) {
            parameterDescriptions[param] = typeof value.description === "string" ? value.description : "";
          }
          if ("required" in value) {
            parameterRequired[param] = Boolean(value.required);
          }
        }
      }
    }
    return {
      name: instance.name,
      description: instance.description,
      parameters: instance.parameters,
      parameterDescriptions,
      parameterRequired
    };
  });
  const filteredMetadata = metadata.filter((item) => !!item);
  console.log("[toolcollect] getToolMetadata result:", filteredMetadata.map((m) => m.name));
  return filteredMetadata;
}
function getAllToolNames() {
  return getToolMetadata().map((tool) => tool.name);
}
function createToolInstances(app, plugin) {
  if (plugin && typeof plugin.debugLog === "function") {
    plugin.debugLog("info", "[toolcollect] createToolInstances called");
  }
  const toolClasses = getAllToolClasses();
  const tools = toolClasses.map((ToolClass) => {
    const instance = plugin && (ToolClass.name === "FileWriteTool" || ToolClass.name === "FileDeleteTool") ? new ToolClass(app, plugin.backupManager) : new ToolClass(app);
    return instance;
  });
  if (plugin && typeof plugin.debugLog === "function") {
    plugin.debugLog("debug", "[toolcollect] Tool instances created", { count: tools.length });
  }
  return tools;
}
var init_toolcollect = __esm({
  "src/components/agent/tools/toolcollect.ts"() {
    init_FileSearchTool();
    init_FileReadTool();
    init_FileWriteTool();
    init_FileDiffTool();
    init_FileMoveTool();
    init_ThoughtTool();
    init_FileListTool();
    init_VaultTreeTool();
    init_FileDeleteTool();
    init_GetUserFeedback();
  }
});

// src/promptConstants.ts
var promptConstants_exports = {};
__export(promptConstants_exports, {
  AGENT_SYSTEM_PROMPT: () => AGENT_SYSTEM_PROMPT,
  AGENT_SYSTEM_PROMPT_TEMPLATE: () => AGENT_SYSTEM_PROMPT_TEMPLATE,
  DEFAULT_GENERAL_SYSTEM_PROMPT: () => DEFAULT_GENERAL_SYSTEM_PROMPT,
  DEFAULT_SUMMARY_PROMPT: () => DEFAULT_SUMMARY_PROMPT,
  DEFAULT_TITLE_PROMPT: () => DEFAULT_TITLE_PROMPT,
  DEFAULT_YAML_SYSTEM_MESSAGE: () => DEFAULT_YAML_SYSTEM_MESSAGE,
  buildAgentSystemPrompt: () => buildAgentSystemPrompt,
  getDynamicToolList: () => getDynamicToolList
});
function buildAgentSystemPrompt(enabledTools, customTemplate) {
  if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
    window.aiAssistantPlugin.debugLog("debug", "[promptConstants] buildAgentSystemPrompt called", { enabledTools, customTemplate });
  }
  const toolList = getDynamicToolList(enabledTools);
  const toolDescriptions = toolList.map((tool, idx) => {
    let paramDesc = "";
    if (tool.parameterDescriptions && Object.keys(tool.parameterDescriptions).length > 0) {
      paramDesc = "\n    Parameters:\n" + Object.entries(tool.parameterDescriptions).map(([param, desc]) => `      - ${param}: ${desc}`).join("\n");
    }
    return `${idx + 1}. ${tool.name} - ${tool.description}${paramDesc}`;
  }).join("\n");
  const template = customTemplate || AGENT_SYSTEM_PROMPT_TEMPLATE;
  return template.replace("{{TOOL_DESCRIPTIONS}}", toolDescriptions);
}
var DEFAULT_TITLE_PROMPT, DEFAULT_SUMMARY_PROMPT, DEFAULT_GENERAL_SYSTEM_PROMPT, getDynamicToolList, AGENT_SYSTEM_PROMPT_TEMPLATE, AGENT_SYSTEM_PROMPT, DEFAULT_YAML_SYSTEM_MESSAGE;
var init_promptConstants = __esm({
  "src/promptConstants.ts"() {
    init_toolcollect();
    DEFAULT_TITLE_PROMPT = "You are a title generator. You will give succinct titles that do not contain backslashes, forward slashes, or colons. Only generate a title as your response.";
    DEFAULT_SUMMARY_PROMPT = "Summarize the note content in 1-2 sentences, focusing on the main ideas and purpose.";
    DEFAULT_GENERAL_SYSTEM_PROMPT = "You are a helpful assistant in an Obsidian Vault.";
    getDynamicToolList = (enabledTools) => {
      if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
        window.aiAssistantPlugin.debugLog("debug", "[promptConstants] getDynamicToolList called", { enabledTools });
      }
      const toolMetadata = getToolMetadata();
      return toolMetadata.filter((tool) => tool.name === "thought" || !enabledTools || enabledTools[tool.name] !== false).map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters,
        parameterDescriptions: tool.parameterDescriptions
      }));
    };
    AGENT_SYSTEM_PROMPT_TEMPLATE = `
- You are an AI assistant in an Obsidian Vault with access to powerful tools for vault management.
- ALWAYS start by using the 'thought' tool to outline your plan before executing actions, and at the end of the task for a summary of completion.
- ALWAYS use relative paths from the vault root.
- You MAY call multiple tools in a single response if it is efficient to do so. Respond ONLY with several consecutive JSON objects (not an array) if you need to use more than one tool at once, or a single object if only one tool is needed.

Available tools:
{{TOOL_DESCRIPTIONS}}

When using tools, respond ONLY with JSON objects using this parameter framework:

Multiple tool calls (no commas between objects):
{
  "action": "tool1",
  "parameters": { /* ... */ },
  "requestId": "..."
}
{
  "action": "tool2",
  "parameters": { /* ... */ },
  "requestId": "..."
}
`;
    AGENT_SYSTEM_PROMPT = buildAgentSystemPrompt();
    DEFAULT_YAML_SYSTEM_MESSAGE = "You are an assistant that generates YAML attribute values for Obsidian notes. Read the note and generate a value for the specified YAML field. Only output the value, not the key or extra text.";
  }
});

// src/types/settings.ts
var DEFAULT_SETTINGS;
var init_settings = __esm({
  "src/types/settings.ts"() {
    init_promptConstants();
    DEFAULT_SETTINGS = {
      /** @inheritdoc */
      referenceCurrentNote: false,
      /** @inheritdoc */
      provider: "openai",
      /** @inheritdoc */
      selectedModel: void 0,
      /** @inheritdoc */
      availableModels: [],
      /** @inheritdoc */
      openaiSettings: {
        apiKey: "",
        model: "gpt-4.1",
        availableModels: []
      },
      /** @inheritdoc */
      anthropicSettings: {
        apiKey: "",
        model: "claude-3-5-sonnet-latest",
        availableModels: []
      },
      /** @inheritdoc */
      geminiSettings: {
        apiKey: "",
        model: "gemini-2.5-flash-preview-05-20",
        availableModels: []
      },
      /** @inheritdoc */
      ollamaSettings: {
        serverUrl: "http://localhost:11434",
        model: "llama2",
        availableModels: []
      },
      /** @inheritdoc */
      systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
      /** @inheritdoc */
      temperature: 0.7,
      /** @inheritdoc */
      includeTimeWithSystemMessage: false,
      /** @inheritdoc */
      enableStreaming: true,
      /** @inheritdoc */
      autoOpenModelSettings: false,
      /** @inheritdoc */
      enableObsidianLinks: true,
      /** @inheritdoc */
      titleOutputMode: "clipboard",
      /** @inheritdoc */
      summaryOutputMode: "clipboard",
      /** @inheritdoc */
      chatSeparator: "----",
      /** @inheritdoc */
      chatStartString: void 0,
      /** @inheritdoc */
      chatEndString: void 0,
      /** @inheritdoc */
      enableContextNotes: false,
      /** @inheritdoc */
      contextNotes: "",
      /** @inheritdoc */
      titlePrompt: DEFAULT_TITLE_PROMPT,
      /** @inheritdoc */
      summaryPrompt: DEFAULT_SUMMARY_PROMPT,
      /** @inheritdoc */
      maxSessions: 10,
      /** @inheritdoc */
      autoSaveSessions: true,
      /** @inheritdoc */
      sessions: [],
      /** @inheritdoc */
      activeSessionId: void 0,
      /** @inheritdoc */
      expandLinkedNotesRecursively: false,
      /** @inheritdoc */
      maxLinkExpansionDepth: 2,
      /** @inheritdoc */
      chatNoteFolder: "",
      /** @inheritdoc */
      yamlAttributeGenerators: [
        {
          attributeName: "summary",
          prompt: DEFAULT_SUMMARY_PROMPT,
          outputMode: "metadata",
          commandName: "Generate YAML: summary"
        }
      ],
      /** @inheritdoc */
      providerConfigExpanded: {
        openai: false,
        anthropic: false,
        gemini: false,
        ollama: false
      },
      /** @inheritdoc */
      generalSectionsExpanded: {
        "AI Model Settings": true,
        "Date Settings": true,
        "Note Reference Settings": true,
        "Provider Configuration": true,
        "AI Model Configuration": true
      },
      /** @inheritdoc */
      apiKeysExpanded: {},
      /** @inheritdoc */
      modelManagementExpanded: {},
      /** @inheritdoc */
      agentConfigExpanded: {},
      /** @inheritdoc */
      contentChatExpanded: {},
      /** @inheritdoc */
      dataHandlingExpanded: {},
      /** @inheritdoc */
      pluginBehaviorExpanded: {},
      /** @inheritdoc */
      backupManagementExpanded: {},
      /** @inheritdoc */
      modelSettingPresets: [
        {
          name: "Default",
          selectedModel: void 0,
          systemMessage: DEFAULT_GENERAL_SYSTEM_PROMPT,
          temperature: 0,
          enableStreaming: true
        }
      ],
      /** @inheritdoc */
      customAgentSystemMessage: void 0,
      /** @inheritdoc */
      uiBehavior: {
        collapseOldReasoning: true,
        showCompletionNotifications: true,
        includeReasoningInExports: true
      },
      /** @inheritdoc */
      enabledTools: {},
      /** @inheritdoc */
      enabledModels: {},
      /** @inheritdoc */
      debugMode: false,
      /** @inheritdoc */
      agentMode: {
        enabled: false,
        maxToolCalls: 10,
        timeoutMs: 3e4,
        maxIterations: 10
      }
    };
  }
});

// src/types/index.ts
var types_exports = {};
__export(types_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS
});
var init_types = __esm({
  "src/types/index.ts"() {
    init_settings();
  }
});

// src/utils/pluginUtils.ts
function registerCommand(plugin, options, ribbonIcon, ribbonTitle) {
  plugin.addCommand(options);
  if (ribbonIcon && ribbonTitle) {
    plugin.addRibbonIcon(ribbonIcon, ribbonTitle, options.callback || (() => {
    }));
  }
}
var init_pluginUtils = __esm({
  "src/utils/pluginUtils.ts"() {
  }
});

// src/components/chat/Buttons.ts
function createActionButton(label, tooltip, callback) {
  const button = document.createElement("button");
  button.addClass("ai-chat-action-button");
  button.setAttribute("aria-label", tooltip);
  const labelEl = document.createElement("span");
  labelEl.textContent = label;
  button.appendChild(labelEl);
  button.addEventListener("click", callback);
  return button;
}
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
  } catch (error) {
  }
}
var import_obsidian8, Buttons;
var init_Buttons = __esm({
  "src/components/chat/Buttons.ts"() {
    import_obsidian8 = require("obsidian");
    Buttons = class extends import_obsidian8.Component {
      /**
       * Constructs the Buttons component and initializes all main chat buttons.
       */
      constructor() {
        super();
        __publicField(this, "container");
        __publicField(this, "sendButton");
        __publicField(this, "stopButton");
        __publicField(this, "clearButton");
        __publicField(this, "settingsButton");
        this.container = document.createElement("div");
        this.container.addClass("ai-chat-buttons");
        this.sendButton = new import_obsidian8.ButtonComponent(this.container).setButtonText("Send").setClass("mod-cta");
        this.sendButton.buttonEl.addClass("hidden-button");
        this.stopButton = new import_obsidian8.ButtonComponent(this.container).setButtonText("Stop");
        this.stopButton.buttonEl.addClass("hidden-button");
        this.clearButton = new import_obsidian8.ButtonComponent(this.container).setButtonText("Clear");
        this.clearButton.buttonEl.addClass("hidden-button");
        this.settingsButton = new import_obsidian8.ButtonComponent(this.container).setButtonText("Settings");
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Get the button container element.
       */
      getContainer() {
        return this.container;
      }
      /**
       * Get the main Send button.
       */
      getSendButton() {
        return this.sendButton;
      }
      /**
       * Get the main Stop button.
       */
      getStopButton() {
        return this.stopButton;
      }
      /**
       * Get the main Clear button.
       */
      getClearButton() {
        return this.clearButton;
      }
      /**
       * Get the main Settings button.
       */
      getSettingsButton() {
        return this.settingsButton;
      }
      /**
       * Show the Send button.
       */
      showSendButton() {
        this.sendButton.buttonEl.removeClass("hidden-button");
      }
      /**
       * Hide the Send button.
       */
      hideSendButton() {
        this.sendButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Show the Stop button.
       */
      showStopButton() {
        this.stopButton.buttonEl.removeClass("hidden-button");
      }
      /**
       * Hide the Stop button.
       */
      hideStopButton() {
        this.stopButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Show the Clear button.
       */
      showClearButton() {
        this.clearButton.buttonEl.removeClass("hidden-button");
      }
      /**
       * Hide the Clear button.
       */
      hideClearButton() {
        this.clearButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Show the Settings button.
       */
      showSettingsButton() {
        this.settingsButton.buttonEl.removeClass("hidden-button");
      }
      /**
       * Hide the Settings button.
       */
      hideSettingsButton() {
        this.settingsButton.buttonEl.addClass("hidden-button");
      }
      /**
       * Create action buttons for messages (e.g., copy, edit, delete, regenerate).
       * @param buttons Array of button configs
       * @returns HTMLElement containing all action buttons
       */
      createMessageActions(buttons) {
        const actionsContainer = document.createElement("div");
        actionsContainer.addClass("message-actions");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          actionsContainer.appendChild(button);
        });
        return actionsContainer;
      }
      /**
       * Create the main chat control buttons (send, stop, clear, settings).
       * @param buttons Array of button configs
       * @returns HTMLElement containing all control buttons
       */
      createChatControls(buttons) {
        const controlsContainer = document.createElement("div");
        controlsContainer.addClass("ai-chat-buttons");
        buttons.forEach((config) => {
          const button = this.createButton(config);
          if (config.isHidden) {
            button.addClass("hidden-button");
          }
          controlsContainer.appendChild(button);
        });
        return controlsContainer;
      }
      /**
       * Create a single button with the given configuration.
       * @param config Button configuration
       * @returns The created button element
       */
      createButton(config) {
        const button = document.createElement("button");
        button.addClass("ai-chat-action-button");
        if (config.className) {
          button.addClass(config.className);
        }
        button.setAttribute("aria-label", config.tooltip);
        const labelEl = document.createElement("span");
        labelEl.textContent = config.label;
        button.appendChild(labelEl);
        button.addEventListener("click", config.onClick);
        return button;
      }
      /**
       * Show or hide a specific button in a container by label.
       * @param container The container element
       * @param label The aria-label of the button
       * @param show Whether to show or hide the button
       */
      toggleButton(container, label, show) {
        const button = container.querySelector(`[aria-label="${label}"]`);
        if (button instanceof HTMLElement) {
          show ? button.removeClass("hidden-button") : button.addClass("hidden-button");
        }
      }
      /**
       * Set the send button state (enabled/disabled and visible/hidden).
       */
      setSendButtonState(enabled, visible = true) {
        this.sendButton.setDisabled(!enabled);
        if (visible) {
          this.sendButton.buttonEl.removeClass("hidden-button");
        } else {
          this.sendButton.buttonEl.addClass("hidden-button");
        }
      }
      /**
       * Set the stop button state (enabled/disabled and visible/hidden).
       */
      setStopButtonState(enabled, visible = true) {
        this.stopButton.setDisabled(!enabled);
        if (visible) {
          this.stopButton.buttonEl.removeClass("hidden-button");
        } else {
          this.stopButton.buttonEl.addClass("hidden-button");
        }
      }
    };
  }
});

// src/components/agent/ToolRichDisplay.ts
var import_obsidian9, ToolRichDisplay;
var init_ToolRichDisplay = __esm({
  "src/components/agent/ToolRichDisplay.ts"() {
    import_obsidian9 = require("obsidian");
    ToolRichDisplay = class _ToolRichDisplay extends import_obsidian9.Component {
      /**
       * Constructs a ToolRichDisplay instance.
       * @param options ToolDisplayOptions for rendering and actions
       */
      constructor(options) {
        super();
        __publicField(this, "element");
        __publicField(this, "options");
        this.options = options;
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[ToolRichDisplay] constructor called", { options });
        }
        this.element = this.createToolDisplay();
      }
      /**
       * Returns the root element for this display.
       */
      getElement() {
        return this.element;
      }
      /**
       * Creates the main display element for the tool result.
       * @returns HTMLElement representing the tool result
       */
      createToolDisplay() {
        if (window.aiAssistantPlugin && typeof window.aiAssistantPlugin.debugLog === "function") {
          window.aiAssistantPlugin.debugLog("debug", "[ToolRichDisplay] createToolDisplay called", { command: this.options.command, result: this.options.result });
        }
        return _ToolRichDisplay.createDisplayElement(this.options.command, this.options.result, {
          onRerun: this.options.onRerun,
          onCopy: this.options.onCopy
        });
      }
      /**
       * Returns an emoji icon for the tool action.
       */
      getToolIcon() {
        const iconMap = {
          "file_search": "\u{1F50D}",
          "file_read": "\u{1F4D6}",
          "file_write": "\u270D\uFE0F",
          "file_diff": "\u{1F504}",
          "file_move": "\u{1F4C1}",
          "file_rename": "\u{1F3F7}\uFE0F",
          "file_list": "\u{1F4CB}",
          "thought": "\u{1F9E0}",
          "get_user_feedback": "\u2753"
        };
        return iconMap[this.options.command.action] || "\u{1F527}";
      }
      /**
       * Returns a human-readable display name for the tool action.
       */
      getToolDisplayName() {
        const nameMap = {
          "file_search": "File Search",
          "file_read": "File Read",
          "file_write": "File Write",
          "file_diff": "File Diff",
          "file_move": "File Move",
          "file_rename": "File Rename",
          "file_list": "File List",
          "thought": "Thought Process",
          "get_user_feedback": "User Feedback"
        };
        return nameMap[this.options.command.action] || this.options.command.action;
      }
      /**
       * Formats the tool parameters for display.
       */
      formatParameters() {
        const params = this.options.command.parameters;
        const formatted = Object.entries(params).map(([key, value]) => `${key}: ${typeof value === "string" && value.length > 50 ? value.substring(0, 50) + "..." : JSON.stringify(value)}`).join(", ");
        return `<code>${formatted}</code>`;
      }
      /**
       * Returns a summary string for the tool result.
       */
      getResultSummary() {
        if (!this.options.result.success) {
          return `<span class="tool-error">${this.options.result.error || "Unknown error"}</span>`;
        }
        const data = this.options.result.data;
        if (this.options.command.action === "file_write" && data) {
          const action = data.action || "modified";
          const filePath = data.filePath || "unknown file";
          const size = data.size ? ` (${data.size} bytes)` : "";
          if (action === "created") {
            return `<span class="tool-success">\u{1F4DD} Created file: <strong>${filePath}</strong>${size}</span>`;
          } else {
            return `<span class="tool-success">\u{1F4BE} Saved file: <strong>${filePath}</strong>${size}</span>`;
          }
        }
        if (this.options.command.action === "file_read" && data) {
          const filePath = data.filePath || this.options.command.parameters.path;
          const size = data.content ? ` (${data.content.length} chars)` : "";
          return `<span class="tool-success">\u{1F4D6} Read file: <strong>${filePath}</strong>${size}</span>`;
        }
        if (this.options.command.action === "file_search" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          return `<span class="tool-success">\u{1F50D} Found ${count} file${count !== 1 ? "s" : ""}</span>`;
        }
        if (this.options.command.action === "file_list" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          const path3 = data.path || this.options.command.parameters.path;
          return `<span class="tool-success">\u{1F4CB} Listed ${count} file${count !== 1 ? "s" : ""} in <strong>${path3}</strong></span>`;
        }
        if (this.options.command.action === "file_move" && data) {
          const from = this.options.command.parameters.sourcePath;
          const to = this.options.command.parameters.destinationPath;
          return `<span class="tool-success">\u{1F4C1} Moved <strong>${from}</strong> \u2192 <strong>${to}</strong></span>`;
        }
        if (this.options.command.action === "file_rename" && data) {
          const oldName = this.options.command.parameters.path;
          const newName = this.options.command.parameters.newName;
          return `<span class="tool-success">\u{1F3F7}\uFE0F Renamed <strong>${oldName}</strong> \u2192 <strong>${newName}</strong></span>`;
        }
        if (this.options.command.action === "thought" && data) {
          const thought = data.thought || data.reasoning || "";
          return `<span class="tool-success">\u{1F9E0} ${thought}</span>`;
        }
        if (this.options.command.action === "get_user_feedback" && data) {
          if (data.status === "completed") {
            const answer = data.answer || "";
            const responseTime = data.responseTimeMs ? ` (responded in ${Math.round(data.responseTimeMs / 1e3)}s)` : "";
            return `<span class="tool-success">\u2753 User responded: <strong>${answer}</strong>${responseTime}</span>`;
          } else if (data.status === "failed") {
            return `<span class="tool-error">\u2753 Failed to get user response</span>`;
          } else {
            return `<span class="tool-pending">\u2753 Waiting for user response...</span>`;
          }
        }
        if (typeof data === "string") {
          return data;
        }
        if (Array.isArray(data)) {
          return `${data.length} items returned`;
        }
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data);
          return `Object with ${keys.length} properties`;
        }
        return "Success";
      }
      /**
       * Returns a detailed string (JSON or plain) for the tool result.
       */
      getDetailedResult() {
        if (!this.options.result.success) {
          return this.options.result.error || "Unknown error occurred";
        }
        if (this.options.result.data) {
          return typeof this.options.result.data === "string" ? this.options.result.data : JSON.stringify(this.options.result.data, null, 2);
        }
        return null;
      }
      /**
       * Updates the display with a new tool result.
       * @param result The new ToolResult to display
       */
      updateResult(result) {
        this.options.result = result;
        const newElement = _ToolRichDisplay.createDisplayElement(this.options.command, this.options.result, {
          onRerun: this.options.onRerun,
          onCopy: this.options.onCopy
        });
        this.element.replaceWith(newElement);
        this.element = newElement;
      }
      /**
       * Converts the tool display to markdown format for saving to notes.
       * @returns Markdown string representing the tool result
       */
      toMarkdown() {
        const { command, result } = this.options;
        const status = result.success ? "\u2705" : "\u274C";
        const toolName = this.getToolDisplayName();
        const icon = this.getToolIcon();
        let markdown = `
### ${icon} ${toolName} ${status}

`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          markdown += `**Parameters:**
`;
          Object.entries(command.parameters).forEach(([key, value]) => {
            const displayValue = typeof value === "string" && value.length > 100 ? value.substring(0, 100) + "..." : JSON.stringify(value);
            markdown += `- **${key}:** \`${displayValue}\`
`;
          });
          markdown += "\n";
        }
        if (result.success) {
          markdown += `**Result:** ${this.getResultSummary()}

`;
          const details = this.getDetailedResult();
          if (details && details !== this.getResultSummary()) {
            if (details.length <= 200) {
              markdown += `**Details:** \`${details}\`

`;
            } else {
              markdown += `<details>
<summary>Show Details</summary>

\`\`\`
${details}
\`\`\`

</details>

`;
            }
          }
        } else {
          markdown += `**Error:** ${result.error}

`;
        }
        return markdown;
      }
      /**
       * Static method to create a tool display element for notes (without re-run functionality).
       */
      static createNoteDisplay(command, result, options) {
        return _ToolRichDisplay.createDisplayElement(command, result, {
          ...options,
          isNote: true
        });
      }
      /**
       * Static method to create a tool display element with customizable options.
       * @param command The tool command
       * @param result The tool result
       * @param options Optional callbacks and flags
       * @returns HTMLElement representing the tool result
       */
      static createDisplayElement(command, result, options) {
        const container = document.createElement("div");
        container.className = (options == null ? void 0 : options.isNote) ? "tool-rich-display tool-rich-display-note" : "tool-rich-display";
        const iconDiv = document.createElement("div");
        iconDiv.className = "tool-rich-icon";
        iconDiv.innerHTML = _ToolRichDisplay.getStaticToolIcon(command.action);
        container.appendChild(iconDiv);
        const infoDiv = document.createElement("div");
        infoDiv.className = "tool-rich-info";
        const titleDiv = document.createElement("div");
        titleDiv.className = "tool-rich-title";
        titleDiv.innerText = _ToolRichDisplay.getStaticToolDisplayName(command.action);
        const statusSpan = document.createElement("span");
        statusSpan.className = `tool-rich-status ${result.success ? "success" : "error"}`;
        statusSpan.innerText = result.success ? "Success" : "Error";
        titleDiv.appendChild(statusSpan);
        infoDiv.appendChild(titleDiv);
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          const paramsDiv = document.createElement("div");
          paramsDiv.innerHTML = `<strong>Parameters:</strong> ${_ToolRichDisplay.formatStaticParameters(command.parameters)}`;
          infoDiv.appendChild(paramsDiv);
        }
        const resultDiv = document.createElement("div");
        resultDiv.innerHTML = `<strong>Result:</strong> ${_ToolRichDisplay.getStaticResultSummary(command, result)}`;
        infoDiv.appendChild(resultDiv);
        if (command.action === "get_user_feedback" && result.data && (result.data.status === "pending" || !result.data.status && result.data.requestId)) {
          const feedbackDiv = _ToolRichDisplay.createUserFeedbackUI(command, result);
          if (feedbackDiv) {
            infoDiv.appendChild(feedbackDiv);
          }
        }
        const details = _ToolRichDisplay.getStaticDetailedResult(result);
        if (details) {
          const toggle = document.createElement("div");
          toggle.className = "tool-rich-details-toggle";
          toggle.innerText = "Show details \u25BC";
          const detailsDiv = document.createElement("div");
          detailsDiv.className = "tool-rich-details";
          detailsDiv.style.display = "none";
          detailsDiv.innerHTML = `<pre>${details}</pre>`;
          toggle.onclick = () => {
            const isExpanded = detailsDiv.classList.contains("expanded");
            if (isExpanded) {
              detailsDiv.classList.remove("expanded");
              detailsDiv.style.display = "none";
              toggle.innerText = "Show details \u25BC";
            } else {
              detailsDiv.classList.add("expanded");
              detailsDiv.style.display = "block";
              toggle.innerText = "Hide details \u25B2";
            }
          };
          infoDiv.appendChild(toggle);
          infoDiv.appendChild(detailsDiv);
        }
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "tool-rich-actions";
        if (!(options == null ? void 0 : options.isNote) && (options == null ? void 0 : options.onRerun)) {
          const rerunBtn = document.createElement("button");
          rerunBtn.className = "tool-rich-action-btn";
          rerunBtn.innerText = "Re-run";
          rerunBtn.onclick = options.onRerun;
          actionsDiv.appendChild(rerunBtn);
        }
        if (options == null ? void 0 : options.onCopy) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "tool-rich-action-btn";
          copyBtn.innerText = "Copy";
          copyBtn.onclick = options.onCopy;
          actionsDiv.appendChild(copyBtn);
        }
        const copyResultBtn = document.createElement("button");
        copyResultBtn.className = "tool-rich-action-btn";
        copyResultBtn.innerText = "Copy Result";
        copyResultBtn.onclick = async () => {
          const resultText = result.success ? JSON.stringify(result.data, null, 2) : result.error || "Unknown error";
          try {
            await navigator.clipboard.writeText(resultText);
            copyResultBtn.innerText = "Copied!";
            setTimeout(() => {
              copyResultBtn.innerText = "Copy Result";
            }, 2e3);
          } catch (error) {
            console.error("Failed to copy to clipboard:", error);
          }
        };
        actionsDiv.appendChild(copyResultBtn);
        infoDiv.appendChild(actionsDiv);
        container.appendChild(infoDiv);
        return container;
      }
      /**
       * Returns a static emoji icon for a tool action.
       */
      static getStaticToolIcon(action) {
        const iconMap = {
          "file_search": "\u{1F50D}",
          "file_read": "\u{1F4D6}",
          "file_write": "\u270D\uFE0F",
          "file_diff": "\u{1F504}",
          "file_move": "\u{1F4C1}",
          "file_rename": "\u{1F3F7}\uFE0F",
          "file_list": "\u{1F4CB}",
          "thought": "\u{1F9E0}",
          "get_user_feedback": "\u2753"
        };
        return iconMap[action] || "\u{1F527}";
      }
      /**
       * Returns a static display name for a tool action.
       */
      static getStaticToolDisplayName(action) {
        const nameMap = {
          "file_search": "File Search",
          "file_read": "File Read",
          "file_write": "File Write",
          "file_diff": "File Diff",
          "file_move": "File Move",
          "file_rename": "File Rename",
          "file_list": "File List",
          "thought": "Thought Process",
          "get_user_feedback": "User Feedback"
        };
        return nameMap[action] || action;
      }
      /**
       * Formats parameters for static display.
       */
      static formatStaticParameters(params) {
        const formatted = Object.entries(params).map(([key, value]) => `${key}: ${typeof value === "string" && value.length > 50 ? value.substring(0, 50) + "..." : JSON.stringify(value)}`).join(", ");
        return `<code>${formatted}</code>`;
      }
      /**
       * Returns a static summary string for a tool result.
       */
      static getStaticResultSummary(command, result) {
        if (!result.success) {
          return `<span class="tool-error">${result.error || "Unknown error"}</span>`;
        }
        const data = result.data;
        if (command.action === "file_write" && data) {
          const action = data.action || "modified";
          const filePath = data.filePath || "unknown file";
          const size = data.size ? ` (${data.size} bytes)` : "";
          if (action === "created") {
            return `<span class="tool-success">\u{1F4DD} Created file: <strong>${filePath}</strong>${size}</span>`;
          } else {
            return `<span class="tool-success">\u{1F4BE} Saved file: <strong>${filePath}</strong>${size}</span>`;
          }
        }
        if (command.action === "file_read" && data) {
          const filePath = data.filePath || command.parameters.path;
          const size = data.content ? ` (${data.content.length} chars)` : "";
          return `<span class="tool-success">\u{1F4D6} Read file: <strong>${filePath}</strong>${size}</span>`;
        }
        if (command.action === "file_search" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          return `<span class="tool-success">\u{1F50D} Found ${count} file${count !== 1 ? "s" : ""}</span>`;
        }
        if (command.action === "file_list" && data) {
          const count = data.count || (Array.isArray(data.files) ? data.files.length : 0);
          const path3 = data.path || command.parameters.path;
          return `<span class="tool-success">\u{1F4CB} Listed ${count} file${count !== 1 ? "s" : ""} in <strong>${path3}</strong></span>`;
        }
        if (command.action === "file_move" && data) {
          const from = command.parameters.sourcePath;
          const to = command.parameters.destinationPath;
          return `<span class="tool-success">\u{1F4C1} Moved <strong>${from}</strong> \u2192 <strong>${to}</strong></span>`;
        }
        if (command.action === "file_rename" && data) {
          const oldName = command.parameters.path;
          const newName = command.parameters.newName;
          return `<span class="tool-success">\u{1F3F7}\uFE0F Renamed <strong>${oldName}</strong> \u2192 <strong>${newName}</strong></span>`;
        }
        if (command.action === "thought" && data) {
          const thought = data.thought || data.reasoning || "";
          return `<span class="tool-success">\u{1F9E0} ${thought}</span>`;
        }
        if (command.action === "get_user_feedback" && data) {
          if (data.status === "completed") {
            const answer = data.answer || "";
            const responseTime = data.responseTimeMs ? ` (responded in ${Math.round(data.responseTimeMs / 1e3)}s)` : "";
            return `<span class="tool-success">\u2753 User responded: <strong>${answer}</strong>${responseTime}</span>`;
          } else if (data.status === "failed") {
            return `<span class="tool-error">\u2753 Failed to get user response</span>`;
          } else {
            return `<span class="tool-pending">\u2753 Waiting for user response...</span>`;
          }
        }
        if (typeof data === "string") {
          return data;
        }
        if (Array.isArray(data)) {
          return `${data.length} items returned`;
        }
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data);
          return `Object with ${keys.length} properties`;
        }
        return "Success";
      }
      /**
       * Returns a static detailed string (JSON or plain) for a tool result.
       */
      static getStaticDetailedResult(result) {
        if (!result.success) {
          return result.error || "Unknown error occurred";
        }
        if (result.data) {
          return typeof result.data === "string" ? result.data : JSON.stringify(result.data, null, 2);
        }
        return null;
      }
      /**
       * Render a tool execution block (array of toolResults) into a container element.
       * Used by both markdown and code block processors.
       * @param toolData Object containing toolResults array
       * @param container The container element to render into
       * @param onCopy Optional callback for copying a result
       */
      static renderToolExecutionBlock(toolData, container, onCopy) {
        container.innerHTML = "";
        container.className = "ai-tool-execution-container";
        if (toolData.toolResults && Array.isArray(toolData.toolResults)) {
          for (const toolResult of toolData.toolResults) {
            if (toolResult.command && toolResult.result) {
              const toolDisplay = _ToolRichDisplay.createNoteDisplay(
                toolResult.command,
                toolResult.result,
                {
                  onCopy: onCopy ? () => onCopy(toolResult.result) : void 0
                }
              );
              container.appendChild(toolDisplay);
            }
          }
        }
      }
      /**
       * Creates an interactive UI for user feedback tools.
       * This method creates the input elements and buttons for user interaction.
       * @param command The tool command requesting feedback
       * @param result The tool result (should contain request data)
       * @returns HTMLElement with the interactive feedback UI or null if not applicable
       */
      static createUserFeedbackUI(command, result) {
        const params = command.parameters;
        const data = result.data;
        if (!params.question || !data || !data.requestId) {
          return null;
        }
        const feedbackContainer = document.createElement("div");
        feedbackContainer.className = "user-feedback-ui";
        const questionDiv = document.createElement("div");
        questionDiv.className = "feedback-question";
        questionDiv.innerHTML = `<strong>Question:</strong> ${params.question}`;
        feedbackContainer.appendChild(questionDiv);
        const responseContainer = document.createElement("div");
        responseContainer.className = "feedback-response-container";
        const timeout = data.timeout || 3e5;
        Promise.resolve().then(() => (init_GetUserFeedback(), GetUserFeedback_exports)).then(({ GetUserFeedbackTool: GetUserFeedbackTool2 }) => {
          GetUserFeedbackTool2.createPendingRequest(data.requestId, timeout).then((userResponse) => {
            responseContainer.innerHTML = `<div class="feedback-selected">\u2705 Response received: <strong>${userResponse.answer}</strong></div>`;
          }).catch((error) => {
            responseContainer.innerHTML = `<div class="feedback-error">\u274C ${error.message}</div>`;
          });
        });
        if (params.type === "choice" && params.choices && Array.isArray(params.choices)) {
          const choicesDiv = document.createElement("div");
          choicesDiv.className = "feedback-choices";
          params.choices.forEach((choice, index) => {
            const choiceButton = document.createElement("button");
            choiceButton.className = "feedback-choice-btn";
            choiceButton.textContent = choice;
            choiceButton.onclick = () => {
              Promise.resolve().then(() => (init_GetUserFeedback(), GetUserFeedback_exports)).then(({ GetUserFeedbackTool: GetUserFeedbackTool2 }) => {
                GetUserFeedbackTool2.handleUserResponse(data.requestId, choice, index);
                responseContainer.innerHTML = `<div class="feedback-selected">\u2705 Selected: <strong>${choice}</strong></div>`;
              }).catch((error) => {
                console.error("Failed to handle user response:", error);
              });
            };
            choicesDiv.appendChild(choiceButton);
          });
          responseContainer.appendChild(choicesDiv);
          if (params.allowCustomAnswer) {
            const customDiv = document.createElement("div");
            customDiv.className = "feedback-custom";
            customDiv.innerHTML = "<strong>Or provide a custom answer:</strong>";
            const customInput = document.createElement("input");
            customInput.type = "text";
            customInput.className = "feedback-custom-input";
            customInput.placeholder = params.placeholder || "Enter your custom answer...";
            const customButton = document.createElement("button");
            customButton.className = "feedback-submit-btn";
            customButton.textContent = "Submit Custom Answer";
            customButton.onclick = () => {
              const customAnswer = customInput.value.trim();
              if (customAnswer) {
                Promise.resolve().then(() => (init_GetUserFeedback(), GetUserFeedback_exports)).then(({ GetUserFeedbackTool: GetUserFeedbackTool2 }) => {
                  GetUserFeedbackTool2.handleUserResponse(data.requestId, customAnswer, void 0, true);
                  responseContainer.innerHTML = `<div class="feedback-selected">\u2705 Custom answer: <strong>${customAnswer}</strong></div>`;
                }).catch((error) => {
                  console.error("Failed to handle user response:", error);
                });
              }
            };
            customDiv.appendChild(customInput);
            customDiv.appendChild(customButton);
            responseContainer.appendChild(customDiv);
          }
        } else {
          const textDiv = document.createElement("div");
          textDiv.className = "feedback-text";
          const textInput = document.createElement("textarea");
          textInput.className = "feedback-text-input";
          textInput.placeholder = params.placeholder || "Enter your answer...";
          textInput.rows = 3;
          const submitButton = document.createElement("button");
          submitButton.className = "feedback-submit-btn";
          submitButton.textContent = "Submit Answer";
          submitButton.onclick = () => {
            const answer = textInput.value.trim();
            if (answer) {
              Promise.resolve().then(() => (init_GetUserFeedback(), GetUserFeedback_exports)).then(({ GetUserFeedbackTool: GetUserFeedbackTool2 }) => {
                GetUserFeedbackTool2.handleUserResponse(data.requestId, answer);
                responseContainer.innerHTML = `<div class="feedback-selected">\u2705 Answer submitted: <strong>${answer}</strong></div>`;
              }).catch((error) => {
                console.error("Failed to handle user response:", error);
              });
            }
          };
          textInput.onkeydown = (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              submitButton.click();
            }
          };
          textDiv.appendChild(textInput);
          textDiv.appendChild(submitButton);
          responseContainer.appendChild(textDiv);
        }
        feedbackContainer.appendChild(responseContainer);
        if (data.timeout) {
          const timeoutDiv = document.createElement("div");
          timeoutDiv.className = "feedback-timeout";
          const timeoutSeconds = Math.round(data.timeout / 1e3);
          timeoutDiv.innerHTML = `<small>\u23F1\uFE0F Timeout: ${timeoutSeconds} seconds</small>`;
          feedbackContainer.appendChild(timeoutDiv);
        }
        return feedbackContainer;
      }
    };
  }
});

// src/components/agent/MessageRenderer.ts
var import_obsidian10, MessageRenderer;
var init_MessageRenderer = __esm({
  "src/components/agent/MessageRenderer.ts"() {
    import_obsidian10 = require("obsidian");
    init_ToolRichDisplay();
    init_logger();
    MessageRenderer = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * Updates a message container with enhanced reasoning and task status data.
       * Renders reasoning and task status sections above the message content.
       * @param container The message DOM element
       * @param messageData The message data (may include reasoning/taskStatus)
       * @param component Optional parent component for Markdown rendering
       */
      updateMessageWithEnhancedData(container, messageData, component) {
        debugLog(true, "debug", "[MessageRenderer] updateMessageWithEnhancedData called", { messageData });
        const existingReasoning = container.querySelector(".reasoning-container");
        const existingTaskStatus = container.querySelector(".task-status-container");
        if (existingReasoning) existingReasoning.remove();
        if (existingTaskStatus) existingTaskStatus.remove();
        const messageContainer = container.querySelector(".message-container");
        if (!messageContainer) return;
        if (messageData.reasoning) {
          const reasoningEl = this.createReasoningSection(messageData.reasoning);
          messageContainer.insertBefore(reasoningEl, messageContainer.firstChild);
        }
        if (messageData.taskStatus) {
          const taskStatusEl = this.createTaskStatusSection(messageData.taskStatus);
          messageContainer.insertBefore(taskStatusEl, messageContainer.firstChild);
        }
        const contentEl = container.querySelector(".message-content");
        if (contentEl) {
          contentEl.empty();
          import_obsidian10.MarkdownRenderer.render(
            this.app,
            messageData.content,
            contentEl,
            "",
            component || new import_obsidian10.Component()
          ).catch((error) => {
            contentEl.textContent = messageData.content;
          });
        }
      }
      /**
       * Creates a reasoning section element for display above the message.
       * Supports structured and summary reasoning.
       * @param reasoning The reasoning data object
       * @returns HTMLElement for the reasoning section
       */
      createReasoningSection(reasoning) {
        var _a2;
        debugLog(true, "debug", "[MessageRenderer] createReasoningSection called", { reasoning });
        const reasoningContainer = document.createElement("div");
        reasoningContainer.className = "reasoning-container";
        const header = document.createElement("div");
        header.className = "reasoning-summary";
        const toggle = document.createElement("span");
        toggle.className = "reasoning-toggle";
        toggle.textContent = reasoning.isCollapsed ? "\u25B6" : "\u25BC";
        const headerText = document.createElement("span");
        const typeLabel = reasoning.type === "structured" ? "STRUCTURED REASONING" : "REASONING";
        const stepCount = ((_a2 = reasoning.steps) == null ? void 0 : _a2.length) || 0;
        headerText.innerHTML = `<strong>\u{1F9E0} ${typeLabel}</strong>`;
        if (stepCount > 0) {
          headerText.innerHTML += ` (${stepCount} steps)`;
        }
        headerText.innerHTML += ` - <em>Click to ${reasoning.isCollapsed ? "expand" : "collapse"}</em>`;
        header.appendChild(toggle);
        header.appendChild(headerText);
        const details = document.createElement("div");
        details.className = "reasoning-details";
        if (!reasoning.isCollapsed) {
          details.classList.add("expanded");
        }
        if (reasoning.type === "structured" && reasoning.steps) {
          if (reasoning.problem) {
            const problemDiv = document.createElement("div");
            problemDiv.className = "reasoning-problem";
            problemDiv.innerHTML = `<strong>Problem:</strong> ${reasoning.problem}`;
            details.appendChild(problemDiv);
          }
          reasoning.steps.forEach((step) => {
            const stepDiv = document.createElement("div");
            stepDiv.className = `reasoning-step ${step.category}`;
            stepDiv.innerHTML = `
                    <div class="step-header">
                        ${this.getStepEmoji(step.category)} Step ${step.step}: ${step.title.toUpperCase()}
                    </div>
                    <div class="step-confidence">
                        Confidence: ${step.confidence}/10
                    </div>
                    <div class="step-content">
                        ${step.content}
                    </div>
                `;
            details.appendChild(stepDiv);
          });
        } else if (reasoning.summary) {
          const summaryDiv = document.createElement("div");
          summaryDiv.className = "reasoning-completion";
          summaryDiv.textContent = reasoning.summary;
          details.appendChild(summaryDiv);
        }
        header.addEventListener("click", () => {
          const isExpanded = details.classList.contains("expanded");
          if (isExpanded) {
            details.classList.remove("expanded");
            toggle.textContent = "\u25B6";
            reasoning.isCollapsed = true;
          } else {
            details.classList.add("expanded");
            toggle.textContent = "\u25BC";
            reasoning.isCollapsed = false;
          }
        });
        reasoningContainer.appendChild(header);
        reasoningContainer.appendChild(details);
        return reasoningContainer;
      }
      /**
       * Creates a task status section element for display above the message.
       * @param taskStatus The task status object
       * @returns HTMLElement for the task status section
       */
      createTaskStatusSection(taskStatus) {
        const statusContainer = document.createElement("div");
        statusContainer.className = "task-status-container";
        statusContainer.dataset.taskStatus = taskStatus.status;
        const statusText = this.getTaskStatusText(taskStatus);
        const statusIcon = this.getTaskStatusIcon(taskStatus.status);
        statusContainer.innerHTML = `
            <div class="task-status-header">
                ${statusIcon} <strong>${statusText}</strong>
            </div>
        `;
        if (taskStatus.toolExecutionCount > 0) {
          const toolInfo = document.createElement("div");
          toolInfo.className = "task-tool-info";
          toolInfo.textContent = `Tools used: ${taskStatus.toolExecutionCount}/${taskStatus.maxToolExecutions}`;
          statusContainer.appendChild(toolInfo);
        }
        return statusContainer;
      }
      /**
       * Returns an emoji for a reasoning step category.
       */
      getStepEmoji(category) {
        switch (category) {
          case "analysis":
            return "\u{1F50D}";
          case "planning":
            return "\u{1F4CB}";
          case "problem-solving":
            return "\u{1F9E9}";
          case "reflection":
            return "\u{1F914}";
          case "conclusion":
            return "\u2705";
          case "reasoning":
            return "\u{1F9E0}";
          case "information":
            return "\u{1F4CA}";
          case "approach":
            return "\u{1F3AF}";
          case "evaluation":
            return "\u2696\uFE0F";
          case "synthesis":
            return "\u{1F517}";
          case "validation":
            return "\u2705";
          case "refinement":
            return "\u26A1";
          default:
            return "\u{1F4AD}";
        }
      }
      /**
       * Returns a user-friendly status text for a task status.
       */
      getTaskStatusText(taskStatus) {
        switch (taskStatus.status) {
          case "idle":
            return "Task Ready";
          case "running":
            return "Task In Progress";
          case "stopped":
            return "Task Stopped";
          case "completed":
            return "Task Completed";
          case "limit_reached":
            return "Tool Limit Reached";
          case "waiting_for_user":
            return "Waiting for User Input";
          default:
            return "Unknown Status";
        }
      }
      /**
       * Returns an emoji icon for a task status.
       */
      getTaskStatusIcon(status) {
        switch (status) {
          case "idle":
            return "\u23F8\uFE0F";
          case "running":
            return "\u{1F504}";
          case "stopped":
            return "\u23F9\uFE0F";
          case "completed":
            return "\u2705";
          case "limit_reached":
            return "\u26A0\uFE0F";
          case "waiting_for_user":
            return "\u23F3";
          default:
            return "\u2753";
        }
      }
      /**
       * Render a complete message with tool displays if present.
       * @param message The message object (may include toolResults)
       * @param container The message DOM element
       * @param component Optional parent component for Markdown rendering
       */
      async renderMessage(message, container, component) {
        if (message.toolResults && message.toolResults.length > 0) {
          await this.renderMessageWithToolDisplays(message, container, component);
        } else {
          await this.renderRegularMessage(message, container, component);
        }
      }
      /**
       * Render a message with embedded tool displays.
       * @param message The message object (with toolResults)
       * @param container The message DOM element
       * @param component Optional parent component for Markdown rendering
       */
      async renderMessageWithToolDisplays(message, container, component) {
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) {
          console.error("No .message-content element found in container");
          return;
        }
        messageContent.empty();
        container.classList.add("has-rich-tools");
        if (message.toolResults && message.toolResults.length > 0) {
          for (const toolExecutionResult of message.toolResults) {
            const richDisplay = new ToolRichDisplay({
              command: toolExecutionResult.command,
              result: toolExecutionResult.result,
              onRerun: () => {
              },
              onCopy: async () => {
                const displayText = this.formatToolForCopy(toolExecutionResult.command, toolExecutionResult.result);
                try {
                  await navigator.clipboard.writeText(displayText);
                } catch (error) {
                  console.error("Failed to copy tool result:", error);
                }
              }
            });
            const toolWrapper = document.createElement("div");
            toolWrapper.className = "embedded-tool-display";
            toolWrapper.appendChild(richDisplay.getElement());
            messageContent.appendChild(toolWrapper);
          }
        }
        if (message.content && message.content.trim()) {
          const textDiv = document.createElement("div");
          textDiv.className = "message-text-part";
          await import_obsidian10.MarkdownRenderer.render(this.app, message.content, textDiv, "", component || new import_obsidian10.Component());
          messageContent.appendChild(textDiv);
        }
      }
      /**
       * Render a regular message without tool displays.
       * @param message The message object
       * @param container The message DOM element
       * @param component Optional parent component for Markdown rendering
       */
      async renderRegularMessage(message, container, component) {
        const messageContent = container.querySelector(".message-content");
        if (!messageContent) return;
        messageContent.empty();
        await import_obsidian10.MarkdownRenderer.render(this.app, message.content, messageContent, "", component || new import_obsidian10.Component());
      }
      /**
       * Parse message content to extract tool calls and text parts.
       * Returns an array of text/tool parts for further processing.
       * @param content The message content string
       */
      parseMessageWithTools(content) {
        const parts = [];
        const toolCallRegex = /```json\s*\{[^}]*"action":\s*"([^"]+)"[^}]*\}[^`]*```/g;
        let lastIndex = 0;
        let match;
        while ((match = toolCallRegex.exec(content)) !== null) {
          if (match.index > lastIndex) {
            const textContent = content.slice(lastIndex, match.index).trim();
            if (textContent) {
              parts.push({ type: "text", content: textContent });
            }
          }
          try {
            const toolJson = match[0].replace(/```json\s*/, "").replace(/\s*```[\s\S]*?$/, "");
            const command = JSON.parse(toolJson);
            parts.push({ type: "tool", command });
          } catch (e) {
            parts.push({ type: "text", content: match[0] });
          }
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < content.length) {
          const remainingContent = content.slice(lastIndex).trim();
          if (remainingContent) {
            parts.push({ type: "text", content: remainingContent });
          }
        }
        if (parts.length === 0) {
          parts.push({ type: "text", content });
        }
        return parts;
      }
      /**
       * Compare tool parameters for matching (deep equality).
       * @param params1 First parameters object
       * @param params2 Second parameters object
       * @returns True if parameters are deeply equal
       */
      compareToolParams(params1, params2) {
        try {
          return JSON.stringify(params1) === JSON.stringify(params2);
        } catch (e) {
          return false;
        }
      }
      /**
       * Format a tool execution result for clipboard copy.
       * @param command The tool command
       * @param result The tool result
       * @returns Formatted string for copy
       */
      formatToolForCopy(command, result) {
        const status = result.success ? "\u2705" : "\u274C";
        const statusText = result.success ? "SUCCESS" : "ERROR";
        let output = `${status} **${command.action}** ${statusText}`;
        if (command.parameters && Object.keys(command.parameters).length > 0) {
          output += `

**Parameters:**
\`\`\`json
${JSON.stringify(command.parameters, null, 2)}
\`\`\``;
        }
        if (result.success) {
          output += `

**Result:**
\`\`\`json
${JSON.stringify(result.data, null, 2)}
\`\`\``;
        } else {
          output += `

**Error:**
${result.error}`;
        }
        return output;
      }
      /**
       * Get message content formatted for clipboard copy, including tool results.
       * @param messageData The message data (may include toolResults)
       * @returns Formatted string for copy
       */
      getMessageContentForCopy(messageData) {
        let content = messageData.content;
        if (messageData.toolResults && messageData.toolResults.length > 0) {
          content += "\n\n```ai-tool-execution\n";
          content += JSON.stringify({
            toolResults: messageData.toolResults,
            reasoning: messageData.reasoning,
            taskStatus: messageData.taskStatus
          }, null, 2);
          content += "\n```\n";
        }
        return content;
      }
    };
  }
});

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "node_modules/js-yaml/dist/js-yaml.mjs"() {
    isNothing_1 = isNothing;
    isObject_1 = isObject2;
    toArray_1 = toArray;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// providers/base.ts
var ProviderError, BaseProvider;
var init_base2 = __esm({
  "providers/base.ts"() {
    ProviderError = class extends Error {
      constructor(type2, message, statusCode) {
        super(message);
        __publicField(this, "type");
        __publicField(this, "statusCode");
        this.type = type2;
        this.statusCode = statusCode;
        this.name = "ProviderError";
      }
    };
    BaseProvider = class {
      /**
       * Handle common HTTP errors
       */
      async handleHttpError(error) {
        let status;
        let errorBody;
        if (error instanceof Response) {
          status = error.status;
          try {
            errorBody = await error.json();
          } catch (e) {
            errorBody = await error.text();
          }
        } else if (error.response) {
          status = error.response.status;
          errorBody = error.response.data || error.response.text;
        } else {
          throw new ProviderError(
            "network_error" /* NetworkError */,
            "Network error occurred"
          );
        }
        const errorMessage = typeof errorBody === "object" && errorBody !== null && "message" in errorBody ? errorBody.message : String(errorBody);
        switch (status) {
          case 401:
            throw new ProviderError(
              "invalid_api_key" /* InvalidApiKey */,
              `Invalid API key: ${errorMessage}`,
              status
            );
          case 429:
            throw new ProviderError(
              "rate_limit" /* RateLimit */,
              `Rate limit exceeded: ${errorMessage}`,
              status
            );
          case 400:
            throw new ProviderError(
              "invalid_request" /* InvalidRequest */,
              `Invalid request: ${errorMessage}`,
              status
            );
          case 500:
          case 502:
          case 503:
          case 504:
            throw new ProviderError(
              "server_error" /* ServerError */,
              `Server error occurred: ${errorMessage}`,
              status
            );
          default:
            throw new ProviderError(
              "server_error" /* ServerError */,
              `Unknown error occurred (Status: ${status}): ${errorMessage}`,
              status
            );
        }
      }
      /**
       * Format error message for connection test results
       */
      formatErrorMessage(error) {
        if (error instanceof ProviderError) {
          switch (error.type) {
            case "invalid_api_key" /* InvalidApiKey */:
              return "Invalid API key. Please check your credentials.";
            case "rate_limit" /* RateLimit */:
              return "Rate limit exceeded. Please try again later.";
            case "network_error" /* NetworkError */:
              return "Network error. Please check your internet connection.";
            default:
              return error.message;
          }
        }
        return error.message || "An unknown error occurred";
      }
      /**
       * Create a standard error response for connection tests
       */
      createErrorResponse(error) {
        return {
          success: false,
          message: this.formatErrorMessage(error)
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/@anthropic-ai/sdk/version.mjs"() {
    VERSION = "0.36.3";
  }
});

// node_modules/@anthropic-ai/sdk/_shims/registry.mjs
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto, kind, fetch2, Request2, Response2, Headers2, FormData2, Blob2, File2, ReadableStream2, getMultipartRequestOptions, getDefaultAgent, fileFromPath, isFsReadStream;
var init_registry = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/registry.mjs"() {
    auto = false;
    kind = void 0;
    fetch2 = void 0;
    Request2 = void 0;
    Response2 = void 0;
    Headers2 = void 0;
    FormData2 = void 0;
    Blob2 = void 0;
    File2 = void 0;
    ReadableStream2 = void 0;
    getMultipartRequestOptions = void 0;
    getDefaultAgent = void 0;
    fileFromPath = void 0;
    isFsReadStream = void 0;
  }
});

// node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs
var MultipartBody;
var init_MultipartBody = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs"() {
    MultipartBody = class {
      constructor(body) {
        this.body = body;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
var init_web_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs"() {
    init_MultipartBody();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs
var init_runtime = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/auto/runtime.mjs"() {
    init_web_runtime();
  }
});

// node_modules/@anthropic-ai/sdk/_shims/index.mjs
var init_shims = __esm({
  "node_modules/@anthropic-ai/sdk/_shims/index.mjs"() {
    init_registry();
    init_runtime();
    init_registry();
    if (!kind) setShims(getRuntime(), { auto: true });
  }
});

// node_modules/@anthropic-ai/sdk/error.mjs
var AnthropicError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm({
  "node_modules/@anthropic-ai/sdk/error.mjs"() {
    init_core();
    AnthropicError = class extends Error {
    };
    APIError = class _APIError extends AnthropicError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.request_id = headers == null ? void 0 : headers["request-id"];
        this.error = error;
      }
      static makeMessage(status, error, message) {
        const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error = errorResponse;
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message != null ? message : "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
    };
    AuthenticationError = class extends APIError {
    };
    PermissionDeniedError = class extends APIError {
    };
    NotFoundError = class extends APIError {
    };
    ConflictError = class extends APIError {
    };
    UnprocessableEntityError = class extends APIError {
    };
    RateLimitError = class extends APIError {
    };
    InternalServerError = class extends APIError {
    };
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var LineDecoder;
var init_line2 = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs"() {
    init_error();
    LineDecoder = class _LineDecoder {
      constructor() {
        this.buffer = [];
        this.trailingCR = false;
      }
      decode(chunk) {
        let text = this.decodeText(chunk);
        if (this.trailingCR) {
          text = "\r" + text;
          this.trailingCR = false;
        }
        if (text.endsWith("\r")) {
          this.trailingCR = true;
          text = text.slice(0, -1);
        }
        if (!text) {
          return [];
        }
        const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
        let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
        if (trailingNewline) {
          lines.pop();
        }
        if (lines.length === 1 && !trailingNewline) {
          this.buffer.push(lines[0]);
          return [];
        }
        if (this.buffer.length > 0) {
          lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
          this.buffer = [];
        }
        if (!trailingNewline) {
          this.buffer = [lines.pop() || ""];
        }
        return lines;
      }
      decodeText(bytes) {
        var _a2;
        if (bytes == null)
          return "";
        if (typeof bytes === "string")
          return bytes;
        if (typeof Buffer !== "undefined") {
          if (bytes instanceof Buffer) {
            return bytes.toString();
          }
          if (bytes instanceof Uint8Array) {
            return Buffer.from(bytes).toString();
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if (typeof TextDecoder !== "undefined") {
          if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
            (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
            return this.textDecoder.decode(bytes);
          }
          throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
      }
      flush() {
        if (!this.buffer.length && !this.trailingCR) {
          return [];
        }
        const lines = [this.buffer.join("")];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
      }
    };
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  }
});

// node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_stream_utils = __esm({
  "node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
var Stream, SSEDecoder;
var init_streaming = __esm({
  "node_modules/@anthropic-ai/sdk/streaming.mjs"() {
    init_shims();
    init_error();
    init_line2();
    init_stream_utils();
    init_core();
    init_error();
    Stream = class _Stream {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      static fromSSEResponse(response, controller) {
        let consumed = false;
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (sse.event === "completion") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
                try {
                  yield JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
              }
              if (sse.event === "ping") {
                continue;
              }
              if (sse.event === "error") {
                throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
              }
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = ReadableStreamToAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError")
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller),
          new _Stream(() => teeIterator(right), this.controller)
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self = this;
        let iter;
        const encoder = new TextEncoder();
        return new ReadableStream2({
          async start() {
            iter = self[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encoder.encode(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            var _a2;
            await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/uploads.mjs
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type2 = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type2 === "string") {
      options = { ...options, type: type2 };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var isResponseLike, isFileLike, isBlobLike, getStringFromMaybeBuffer, isAsyncIterableIterator, isMultipartBody;
var init_uploads = __esm({
  "node_modules/@anthropic-ai/sdk/uploads.mjs"() {
    init_shims();
    init_shims();
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    getStringFromMaybeBuffer = (x) => {
      if (typeof x === "string")
        return x;
      if (typeof Buffer !== "undefined" && x instanceof Buffer)
        return String(x);
      return void 0;
    };
    isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  }
});

// node_modules/@anthropic-ai/sdk/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return _addRequestID(json2, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    console.log(`Anthropic:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractPage_client, APIPromise, APIClient, AbstractPage, PagePromise, createResponseHeaders, requestOptionsKeys, isRequestOptions, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, safeJSON, startsWithSchemeRegexp, isAbsoluteURL, sleep, validatePositiveInteger, castToError, readEnv, uuid4, isRunningInBrowser, isHeadersProtocol, getHeader;
var init_core = __esm({
  "node_modules/@anthropic-ai/sdk/core.mjs"() {
    init_version();
    init_streaming();
    init_error();
    init_shims();
    init_uploads();
    __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    APIPromise = class _APIPromise extends Promise {
      constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       * 👋 Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import … from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       * 👋 Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import … from '@anthropic-ai/sdk'`:
       * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
       * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get("request-id") };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    APIClient = class {
      constructor({
        baseURL,
        maxRetries = 2,
        timeout = 6e5,
        // 10 minutes
        httpAgent,
        fetch: overriddenFetch
      }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
        this.timeout = validatePositiveInteger("timeout", timeout);
        this.httpAgent = httpAgent;
        this.fetch = overriddenFetch != null ? overriddenFetch : fetch2;
      }
      authHeaders(opts) {
        return {};
      }
      /**
       * Override this to add your own default headers, for example:
       *
       *  {
       *    ...super.defaultHeaders(),
       *    Authorization: 'Bearer 123',
       *  }
       */
      defaultHeaders(opts) {
        return {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": this.getUserAgent(),
          ...getPlatformHeaders(),
          ...this.authHeaders(opts)
        };
      }
      /**
       * Override this to add your own headers validation:
       */
      validateHeaders(headers, customHeaders) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      get(path3, opts) {
        return this.methodRequest("get", path3, opts);
      }
      post(path3, opts) {
        return this.methodRequest("post", path3, opts);
      }
      patch(path3, opts) {
        return this.methodRequest("patch", path3, opts);
      }
      put(path3, opts) {
        return this.methodRequest("put", path3, opts);
      }
      delete(path3, opts) {
        return this.methodRequest("delete", path3, opts);
      }
      methodRequest(method, path3, opts) {
        return this.request(Promise.resolve(opts).then(async (opts2) => {
          const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
          return { method, path: path3, ...opts2, body };
        }));
      }
      getAPIList(path3, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path: path3, ...opts });
      }
      calculateContentLength(body) {
        if (typeof body === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.byteLength(body, "utf8").toString();
          }
          if (typeof TextEncoder !== "undefined") {
            const encoder = new TextEncoder();
            const encoded = encoder.encode(body);
            return encoded.length.toString();
          }
        } else if (ArrayBuffer.isView(body)) {
          return body.byteLength.toString();
        }
        return null;
      }
      buildRequest(options, { retryCount = 0 } = {}) {
        var _a2, _b, _c, _d, _e, _f;
        const { method, path: path3, query, headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path3, query);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
        const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
        const minAgentTimeout = timeout + 1e3;
        if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
          httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
        const req = {
          method,
          ...body && { body },
          headers: reqHeaders,
          ...httpAgent && { agent: httpAgent },
          // @ts-ignore node-fetch uses a custom AbortSignal type that is
          // not compatible with standard web types
          signal: (_f = options.signal) != null ? _f : null
        };
        return { req, url, timeout };
      }
      buildHeaders({ options, headers, contentLength, retryCount }) {
        const reqHeaders = {};
        if (contentLength) {
          reqHeaders["content-length"] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        if (isMultipartBody(options.body) && kind !== "node") {
          delete reqHeaders["content-type"];
        }
        if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
          reqHeaders["x-stainless-retry-count"] = String(retryCount);
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      parseHeaders(headers) {
        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
      }
      async makeRequest(optionsInput, retriesRemaining) {
        var _a2, _b, _c;
        const options = await optionsInput;
        const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
        await this.prepareRequest(req, { url, options });
        debug("request", url, options, req.headers);
        if ((_b = options.signal) == null ? void 0 : _b.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
          if ((_c = options.signal) == null ? void 0 : _c.aborted) {
            throw new APIUserAbortError();
          }
          if (retriesRemaining) {
            return this.retryRequest(options, retriesRemaining);
          }
          if (response.name === "AbortError") {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
          if (retriesRemaining && this.shouldRetry(response)) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
            return this.retryRequest(options, retriesRemaining, responseHeaders);
          }
          const errText = await response.text().catch((e) => castToError(e).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
          debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
          const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
          throw err;
        }
        return { response, options, controller };
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page2);
      }
      buildURL(path3, query) {
        const url = isAbsoluteURL(path3) ? new URL(path3) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path3.startsWith("/") ? path3.slice(1) : path3));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      stringifyQuery(query) {
        return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key)}=`;
          }
          throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const { signal, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const fetchOptions = {
          signal: controller.signal,
          ...options
        };
        if (fetchOptions.method) {
          fetchOptions.method = fetchOptions.method.toUpperCase();
        }
        return (
          // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
          this.fetch.call(void 0, url, fetchOptions).finally(() => {
            clearTimeout(timeout);
          })
        );
      }
      shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, responseHeaders) {
        var _a2;
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
    };
    AbstractPage = class {
      constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageInfo() != null;
      }
      async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
          throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        const nextOptions = { ...this.options };
        if ("params" in nextInfo && typeof nextOptions.query === "object") {
          nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
        } else if ("url" in nextInfo) {
          const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
          for (const [key, value] of params) {
            nextInfo.url.searchParams.set(key, value);
          }
          nextOptions.query = void 0;
          nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client, request, Page2) {
        super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    createResponseHeaders = (headers) => {
      return new Proxy(Object.fromEntries(
        // @ts-ignore
        headers.entries()
      ), {
        get(target, name) {
          const key = name.toString();
          return target[key.toLowerCase()] || target[key];
        }
      });
    };
    requestOptionsKeys = {
      method: true,
      path: true,
      query: true,
      body: true,
      headers: true,
      maxRetries: true,
      stream: true,
      timeout: true,
      httpAgent: true,
      signal: true,
      idempotencyKey: true,
      __binaryRequest: true,
      __binaryResponse: true,
      __streamClass: true
    };
    isRequestOptions = (obj) => {
      return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
    };
    getPlatformProperties = () => {
      var _a2, _b;
      if (typeof Deno !== "undefined" && Deno.build != null) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(process.platform),
          "X-Stainless-Arch": normalizeArch(process.arch),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
    };
    safeJSON = (text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    };
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    validatePositiveInteger = (name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new AnthropicError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new AnthropicError(`${name} must be a positive integer`);
      }
      return n;
    };
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          return new Error(JSON.stringify(err));
        } catch (e) {
        }
      }
      return new Error(String(err));
    };
    readEnv = (env) => {
      var _a2, _b, _c, _d, _e, _f;
      if (typeof process !== "undefined") {
        return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
      }
      if (typeof Deno !== "undefined") {
        return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
      }
      return void 0;
    };
    uuid4 = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
    isHeadersProtocol = (headers) => {
      return typeof (headers == null ? void 0 : headers.get) === "function";
    };
    getHeader = (headers, header) => {
      var _a2;
      const lowerCasedHeader = header.toLowerCase();
      if (isHeadersProtocol(headers)) {
        const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
          const value = headers.get(key);
          if (value) {
            return value;
          }
        }
      }
      for (const [key, value] of Object.entries(headers)) {
        if (key.toLowerCase() === lowerCasedHeader) {
          if (Array.isArray(value)) {
            if (value.length <= 1)
              return value[0];
            console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
            return value[0];
          }
          return value;
        }
      }
      return void 0;
    };
  }
});

// node_modules/@anthropic-ai/sdk/pagination.mjs
var Page;
var init_pagination = __esm({
  "node_modules/@anthropic-ai/sdk/pagination.mjs"() {
    init_core();
    Page = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.first_id = body.first_id || null;
        this.last_id = body.last_id || null;
      }
      getPaginatedItems() {
        var _a2;
        return (_a2 = this.data) != null ? _a2 : [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        var _a2;
        if ((_a2 = this.options.query) == null ? void 0 : _a2["before_id"]) {
          const firstId = this.first_id;
          if (!firstId) {
            return null;
          }
          return {
            params: {
              before_id: firstId
            }
          };
        }
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          params: {
            after_id: cursor
          }
        };
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/shared.mjs
var init_shared = __esm({
  "node_modules/@anthropic-ai/sdk/resources/shared.mjs"() {
  }
});

// node_modules/@anthropic-ai/sdk/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/@anthropic-ai/sdk/resource.mjs"() {
    APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models, BetaModelInfosPage;
var init_models = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}?beta=true`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models?beta=true", BetaModelInfosPage, { query, ...options });
      }
    };
    BetaModelInfosPage = class extends Page {
    };
    Models.BetaModelInfosPage = BetaModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder;
var init_jsonl = __esm({
  "node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs"() {
    init_error();
    init_stream_utils();
    init_line2();
    JSONLDecoder = class _JSONLDecoder {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      async *decoder() {
        const lineDecoder = new LineDecoder();
        for await (const chunk of this.iterator) {
          for (const line of lineDecoder.decode(chunk)) {
            yield JSON.parse(line);
          }
        }
        for (const line of lineDecoder.flush()) {
          yield JSON.parse(line);
        }
      }
      [Symbol.asyncIterator]() {
        return this.decoder();
      }
      static fromResponse(response, controller) {
        if (!response.body) {
          controller.abort();
          throw new AnthropicError(`Attempted to iterate over a response with no body`);
        }
        return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches, BetaMessageBatchesPage;
var init_batches = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/batches?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      retrieve(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.retrieve(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { betas, ...query } = params;
        return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
          query,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      delete(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      cancel(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.cancel(messageBatchId, {}, params);
        }
        const { betas } = params;
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
      async results(messageBatchId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.results(messageBatchId, {}, params);
        }
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        const { betas } = params;
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    BetaMessageBatchesPage = class extends Page {
    };
    Batches.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize2, strip, unstrip, generate, partialParse;
var init_parser = __esm({
  "node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs"() {
    tokenize2 = (input) => {
      let current = 0;
      let tokens = [];
      while (current < input.length) {
        let char = input[current];
        if (char === "\\") {
          current++;
          continue;
        }
        if (char === "{") {
          tokens.push({
            type: "brace",
            value: "{"
          });
          current++;
          continue;
        }
        if (char === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
          current++;
          continue;
        }
        if (char === "[") {
          tokens.push({
            type: "paren",
            value: "["
          });
          current++;
          continue;
        }
        if (char === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
          current++;
          continue;
        }
        if (char === ":") {
          tokens.push({
            type: "separator",
            value: ":"
          });
          current++;
          continue;
        }
        if (char === ",") {
          tokens.push({
            type: "delimiter",
            value: ","
          });
          current++;
          continue;
        }
        if (char === '"') {
          let value = "";
          let danglingQuote = false;
          char = input[++current];
          while (char !== '"') {
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            if (char === "\\") {
              current++;
              if (current === input.length) {
                danglingQuote = true;
                break;
              }
              value += char + input[current];
              char = input[++current];
            } else {
              value += char;
              char = input[++current];
            }
          }
          char = input[++current];
          if (!danglingQuote) {
            tokens.push({
              type: "string",
              value
            });
          }
          continue;
        }
        let WHITESPACE = /\s/;
        if (char && WHITESPACE.test(char)) {
          current++;
          continue;
        }
        let NUMBERS = /[0-9]/;
        if (char && NUMBERS.test(char) || char === "-" || char === ".") {
          let value = "";
          if (char === "-") {
            value += char;
            char = input[++current];
          }
          while (char && NUMBERS.test(char) || char === ".") {
            value += char;
            char = input[++current];
          }
          tokens.push({
            type: "number",
            value
          });
          continue;
        }
        let LETTERS = /[a-z]/i;
        if (char && LETTERS.test(char)) {
          let value = "";
          while (char && LETTERS.test(char)) {
            if (current === input.length) {
              break;
            }
            value += char;
            char = input[++current];
          }
          if (value == "true" || value == "false" || value === "null") {
            tokens.push({
              type: "name",
              value
            });
          } else {
            current++;
            continue;
          }
          continue;
        }
        current++;
      }
      return tokens;
    };
    strip = (tokens) => {
      if (tokens.length === 0) {
        return tokens;
      }
      let lastToken = tokens[tokens.length - 1];
      switch (lastToken.type) {
        case "separator":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
        case "number":
          let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
          if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
        case "string":
          let tokenBeforeTheLastToken = tokens[tokens.length - 2];
          if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
            tokens = tokens.slice(0, tokens.length - 1);
            return strip(tokens);
          }
          break;
        case "delimiter":
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
          break;
      }
      return tokens;
    };
    unstrip = (tokens) => {
      let tail = [];
      tokens.map((token) => {
        if (token.type === "brace") {
          if (token.value === "{") {
            tail.push("}");
          } else {
            tail.splice(tail.lastIndexOf("}"), 1);
          }
        }
        if (token.type === "paren") {
          if (token.value === "[") {
            tail.push("]");
          } else {
            tail.splice(tail.lastIndexOf("]"), 1);
          }
        }
      });
      if (tail.length > 0) {
        tail.reverse().map((item) => {
          if (item === "}") {
            tokens.push({
              type: "brace",
              value: "}"
            });
          } else if (item === "]") {
            tokens.push({
              type: "paren",
              value: "]"
            });
          }
        });
      }
      return tokens;
    };
    generate = (tokens) => {
      let output = "";
      tokens.map((token) => {
        switch (token.type) {
          case "string":
            output += '"' + token.value + '"';
            break;
          default:
            output += token.value;
            break;
        }
      });
      return output;
    };
    partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize2(input)))));
  }
});

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
function checkNever(x) {
}
var __classPrivateFieldSet2, __classPrivateFieldGet2, _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage, JSON_BUF_PROPERTY, BetaMessageStream;
var init_BetaMessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY = "__json_buf";
    BetaMessageStream = class _BetaMessageStream {
      constructor() {
        _BetaMessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _BetaMessageStream_connectedPromise.set(this, void 0);
        _BetaMessageStream_resolveConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_rejectConnectedPromise.set(this, () => {
        });
        _BetaMessageStream_endPromise.set(this, void 0);
        _BetaMessageStream_resolveEndPromise.set(this, () => {
        });
        _BetaMessageStream_rejectEndPromise.set(this, () => {
        });
        _BetaMessageStream_listeners.set(this, {});
        _BetaMessageStream_ended.set(this, false);
        _BetaMessageStream_errored.set(this, false);
        _BetaMessageStream_aborted.set(this, false);
        _BetaMessageStream_catchingPromiseCreated.set(this, false);
        _BetaMessageStream_response.set(this, void 0);
        _BetaMessageStream_request_id.set(this, void 0);
        _BetaMessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet2(this, _BetaMessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet2(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet2(this, _BetaMessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _BetaMessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _BetaMessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_response, response, "f");
        __classPrivateFieldSet2(this, _BetaMessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet2(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet2(this, _BetaMessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet2(this, _BetaMessageStream_ended, true, "f");
          __classPrivateFieldGet2(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
      }
      [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
      }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS, Messages;
var init_messages = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs"() {
    init_resource();
    init_batches();
    init_batches();
    init_BetaMessageStream();
    DEPRECATED_MODELS = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches(this._client);
      }
      create(params, options) {
        var _a2, _b;
        const { betas, ...body } = params;
        if (body.model in DEPRECATED_MODELS) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages?beta=true", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          headers: {
            ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0,
            ...options == null ? void 0 : options.headers
          },
          stream: (_b = params.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return BetaMessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(params, options) {
        const { betas, ...body } = params;
        return this._client.post("/v1/messages/count_tokens?beta=true", {
          body,
          ...options,
          headers: {
            "anthropic-beta": [...betas != null ? betas : [], "token-counting-2024-11-01"].toString(),
            ...options == null ? void 0 : options.headers
          }
        });
      }
    };
    Messages.Batches = Batches;
    Messages.BetaMessageBatchesPage = BetaMessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  "node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs"() {
    init_resource();
    init_models();
    init_models();
    init_messages();
    init_messages();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.models = new Models(this._client);
        this.messages = new Messages(this._client);
      }
    };
    Beta.Models = Models;
    Beta.BetaModelInfosPage = BetaModelInfosPage;
    Beta.Messages = Messages;
  }
});

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions;
var init_completions = __esm({
  "node_modules/@anthropic-ai/sdk/resources/completions.mjs"() {
    init_resource();
    Completions = class extends APIResource {
      create(body, options) {
        var _a2, _b;
        return this._client.post("/v1/complete", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2, MessageBatchesPage;
var init_batches2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    init_jsonl();
    init_error();
    Batches2 = class extends APIResource {
      /**
       * Send a batch of Message creation requests.
       *
       * The Message Batches API can be used to process multiple Messages API requests at
       * once. Once a Message Batch is created, it begins processing immediately. Batches
       * can take up to 24 hours to complete.
       */
      create(body, options) {
        return this._client.post("/v1/messages/batches", { body, ...options });
      }
      /**
       * This endpoint is idempotent and can be used to poll for Message Batch
       * completion. To access the results of a Message Batch, make a request to the
       * `results_url` field in the response.
       */
      retrieve(messageBatchId, options) {
        return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/messages/batches", MessageBatchesPage, { query, ...options });
      }
      /**
       * Delete a Message Batch.
       *
       * Message Batches can only be deleted once they've finished processing. If you'd
       * like to delete an in-progress batch, you must first cancel it.
       */
      delete(messageBatchId, options) {
        return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);
      }
      /**
       * Batches may be canceled any time before processing ends. Once cancellation is
       * initiated, the batch enters a `canceling` state, at which time the system may
       * complete any in-progress, non-interruptible requests before finalizing
       * cancellation.
       *
       * The number of canceled requests is specified in `request_counts`. To determine
       * which requests were canceled, check the individual results within the batch.
       * Note that cancellation may not result in any canceled requests if they were
       * non-interruptible.
       */
      cancel(messageBatchId, options) {
        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);
      }
      /**
       * Streams the results of a Message Batch as a `.jsonl` file.
       *
       * Each line in the file is a JSON object containing the result of a single request
       * in the Message Batch. Results are not guaranteed to be in the same order as
       * requests. Use the `custom_id` field to match results to requests.
       */
      async results(messageBatchId, options) {
        const batch = await this.retrieve(messageBatchId);
        if (!batch.results_url) {
          throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
        }
        return this._client.get(batch.results_url, {
          ...options,
          headers: {
            Accept: "application/binary",
            ...options == null ? void 0 : options.headers
          },
          __binaryResponse: true
        })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
      }
    };
    MessageBatchesPage = class extends Page {
    };
    Batches2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
function checkNever2(x) {
}
var __classPrivateFieldSet3, __classPrivateFieldGet3, _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage, JSON_BUF_PROPERTY2, MessageStream;
var init_MessageStream = __esm({
  "node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs"() {
    init_error();
    init_streaming();
    init_parser();
    __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    JSON_BUF_PROPERTY2 = "__json_buf";
    MessageStream = class _MessageStream {
      constructor() {
        _MessageStream_instances.add(this);
        this.messages = [];
        this.receivedMessages = [];
        _MessageStream_currentMessageSnapshot.set(this, void 0);
        this.controller = new AbortController();
        _MessageStream_connectedPromise.set(this, void 0);
        _MessageStream_resolveConnectedPromise.set(this, () => {
        });
        _MessageStream_rejectConnectedPromise.set(this, () => {
        });
        _MessageStream_endPromise.set(this, void 0);
        _MessageStream_resolveEndPromise.set(this, () => {
        });
        _MessageStream_rejectEndPromise.set(this, () => {
        });
        _MessageStream_listeners.set(this, {});
        _MessageStream_ended.set(this, false);
        _MessageStream_errored.set(this, false);
        _MessageStream_aborted.set(this, false);
        _MessageStream_catchingPromiseCreated.set(this, false);
        _MessageStream_response.set(this, void 0);
        _MessageStream_request_id.set(this, void 0);
        _MessageStream_handleError.set(this, (error) => {
          __classPrivateFieldSet3(this, _MessageStream_errored, true, "f");
          if (error instanceof Error && error.name === "AbortError") {
            error = new APIUserAbortError();
          }
          if (error instanceof APIUserAbortError) {
            __classPrivateFieldSet3(this, _MessageStream_aborted, true, "f");
            return this._emit("abort", error);
          }
          if (error instanceof AnthropicError) {
            return this._emit("error", error);
          }
          if (error instanceof Error) {
            const anthropicError = new AnthropicError(error.message);
            anthropicError.cause = error;
            return this._emit("error", anthropicError);
          }
          return this._emit("error", new AnthropicError(String(error)));
        });
        __classPrivateFieldSet3(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet3(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet3(this, _MessageStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet3(this, _MessageStream_endPromise, "f").catch(() => {
        });
      }
      get response() {
        return __classPrivateFieldGet3(this, _MessageStream_response, "f");
      }
      get request_id() {
        return __classPrivateFieldGet3(this, _MessageStream_request_id, "f");
      }
      /**
       * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
       * returned vie the `request-id` header which is useful for debugging requests and resporting
       * issues to Anthropic.
       *
       * This is the same as the `APIPromise.withResponse()` method.
       *
       * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
       * as no `Response` is available.
       */
      async withResponse() {
        const response = await __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f");
        if (!response) {
          throw new Error("Could not resolve a `Response` object");
        }
        return {
          data: this,
          response,
          request_id: response.headers.get("request-id")
        };
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _MessageStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createMessage(messages, params, options) {
        const runner = new _MessageStream();
        for (const message of params.messages) {
          runner._addMessageParam(message);
        }
        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      _run(executor) {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet3(this, _MessageStream_handleError, "f"));
      }
      _addMessageParam(message) {
        this.messages.push(message);
      }
      _addMessage(message, emit = true) {
        this.receivedMessages.push(message);
        if (emit) {
          this._emit("message", message);
        }
      }
      async _createMessage(messages, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
        this._connected(response);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      _connected(response) {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_response, response, "f");
        __classPrivateFieldSet3(this, _MessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
        __classPrivateFieldGet3(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet3(this, _MessageStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet3(this, _MessageStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet3(this, _MessageStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this MessageStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this MessageStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this MessageStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet3(this, _MessageStream_endPromise, "f");
      }
      get currentMessage() {
        return __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
      }
      /**
       * @returns a promise that resolves with the the final assistant Message response,
       * or rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant Message's text response, concatenated
       * together if there are more than one text blocks.
       * Rejects if an error occurred or the stream ended prematurely without producing a Message.
       */
      async finalText() {
        await this.done();
        return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet3(this, _MessageStream_ended, "f"))
          return;
        if (event === "end") {
          __classPrivateFieldSet3(this, _MessageStream_ended, true, "f");
          __classPrivateFieldGet3(this, _MessageStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
          __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
        const finalMessage = this.receivedMessages.at(-1);
        if (finalMessage) {
          this._emit("finalMessage", __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
        }
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
        this._connected(null);
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new APIUserAbortError();
        }
        __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
      }
      [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        return this.receivedMessages.at(-1);
      }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
        if (this.receivedMessages.length === 0) {
          throw new AnthropicError("stream ended without producing a Message with role=assistant");
        }
        const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
        if (textBlocks.length === 0) {
          throw new AnthropicError("stream ended without producing a content block with type=text");
        }
        return textBlocks.join(" ");
      }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
      }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
        var _a2;
        if (this.ended)
          return;
        const messageSnapshot = __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
        this._emit("streamEvent", event, messageSnapshot);
        switch (event.type) {
          case "content_block_delta": {
            const content = messageSnapshot.content.at(-1);
            switch (event.delta.type) {
              case "text_delta": {
                if (content.type === "text") {
                  this._emit("text", event.delta.text, content.text || "");
                }
                break;
              }
              case "citations_delta": {
                if (content.type === "text") {
                  this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
                }
                break;
              }
              case "input_json_delta": {
                if (content.type === "tool_use" && content.input) {
                  this._emit("inputJson", event.delta.partial_json, content.input);
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            break;
          }
          case "message_stop": {
            this._addMessageParam(messageSnapshot);
            this._addMessage(messageSnapshot, true);
            break;
          }
          case "content_block_stop": {
            this._emit("contentBlock", messageSnapshot.content.at(-1));
            break;
          }
          case "message_start": {
            __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
            break;
          }
          case "content_block_start":
          case "message_delta":
            break;
        }
      }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
        if (this.ended) {
          throw new AnthropicError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (!snapshot) {
          throw new AnthropicError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
        return snapshot;
      }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
        var _a2;
        let snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
        if (event.type === "message_start") {
          if (snapshot) {
            throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
          }
          return event.message;
        }
        if (!snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
        }
        switch (event.type) {
          case "message_stop":
            return snapshot;
          case "message_delta":
            snapshot.stop_reason = event.delta.stop_reason;
            snapshot.stop_sequence = event.delta.stop_sequence;
            snapshot.usage.output_tokens = event.usage.output_tokens;
            return snapshot;
          case "content_block_start":
            snapshot.content.push(event.content_block);
            return snapshot;
          case "content_block_delta": {
            const snapshotContent = snapshot.content.at(event.index);
            switch (event.delta.type) {
              case "text_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  snapshotContent.text += event.delta.text;
                }
                break;
              }
              case "citations_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
                  (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
                  snapshotContent.citations.push(event.delta.citation);
                }
                break;
              }
              case "input_json_delta": {
                if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
                  jsonBuf += event.delta.partial_json;
                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY2, {
                    value: jsonBuf,
                    enumerable: false,
                    writable: true
                  });
                  if (jsonBuf) {
                    snapshotContent.input = partialParse(jsonBuf);
                  }
                }
                break;
              }
              default:
                checkNever2(event.delta);
            }
            return snapshot;
          }
          case "content_block_stop":
            return snapshot;
        }
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("streamEvent", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2, DEPRECATED_MODELS2;
var init_messages2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs"() {
    init_resource();
    init_batches2();
    init_batches2();
    init_MessageStream();
    Messages2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.batches = new Batches2(this._client);
      }
      create(body, options) {
        var _a2, _b;
        if (body.model in DEPRECATED_MODELS2) {
          console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
        }
        return this._client.post("/v1/messages", {
          body,
          timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
          ...options,
          stream: (_b = body.stream) != null ? _b : false
        });
      }
      /**
       * Create a Message stream
       */
      stream(body, options) {
        return MessageStream.createMessage(this, body, options);
      }
      /**
       * Count the number of tokens in a Message.
       *
       * The Token Count API can be used to count the number of tokens in a Message,
       * including tools, images, and documents, without creating it.
       */
      countTokens(body, options) {
        return this._client.post("/v1/messages/count_tokens", { body, ...options });
      }
    };
    DEPRECATED_MODELS2 = {
      "claude-1.3": "November 6th, 2024",
      "claude-1.3-100k": "November 6th, 2024",
      "claude-instant-1.1": "November 6th, 2024",
      "claude-instant-1.1-100k": "November 6th, 2024",
      "claude-instant-1.2": "November 6th, 2024",
      "claude-3-sonnet-20240229": "July 21st, 2025",
      "claude-2.1": "July 21st, 2025",
      "claude-2.0": "July 21st, 2025"
    };
    Messages2.Batches = Batches2;
    Messages2.MessageBatchesPage = MessageBatchesPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2, ModelInfosPage;
var init_models2 = __esm({
  "node_modules/@anthropic-ai/sdk/resources/models.mjs"() {
    init_resource();
    init_core();
    init_pagination();
    Models2 = class extends APIResource {
      /**
       * Get a specific model.
       *
       * The Models API response can be used to determine information about a specific
       * model or resolve a model alias to a model ID.
       */
      retrieve(modelId, options) {
        return this._client.get(`/v1/models/${modelId}`, options);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/v1/models", ModelInfosPage, { query, ...options });
      }
    };
    ModelInfosPage = class extends Page {
    };
    Models2.ModelInfosPage = ModelInfosPage;
  }
});

// node_modules/@anthropic-ai/sdk/resources/index.mjs
var init_resources = __esm({
  "node_modules/@anthropic-ai/sdk/resources/index.mjs"() {
    init_shared();
    init_beta();
    init_completions();
    init_messages2();
    init_models2();
  }
});

// node_modules/@anthropic-ai/sdk/index.mjs
var _a, Anthropic, HUMAN_PROMPT, AI_PROMPT, sdk_default;
var init_sdk = __esm({
  "node_modules/@anthropic-ai/sdk/index.mjs"() {
    init_core();
    init_error();
    init_uploads();
    init_resources();
    init_completions();
    init_models2();
    init_beta();
    init_messages2();
    Anthropic = class extends APIClient {
      /**
       * API Client for interfacing with the Anthropic API.
       *
       * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
       * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
       * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = ((_a2) => (_a2 = readEnv("ANTHROPIC_API_KEY")) != null ? _a2 : null)(), authToken = ((_b) => (_b = readEnv("ANTHROPIC_AUTH_TOKEN")) != null ? _b : null)(), ...opts } = {}) {
        var _a3;
        const options = {
          apiKey,
          authToken,
          ...opts,
          baseURL: baseURL || `https://api.anthropic.com`
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
        }
        super({
          baseURL: options.baseURL,
          timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
          httpAgent: options.httpAgent,
          maxRetries: options.maxRetries,
          fetch: options.fetch
        });
        this.completions = new Completions(this);
        this.messages = new Messages2(this);
        this.models = new Models2(this);
        this.beta = new Beta(this);
        this._options = options;
        this.apiKey = apiKey;
        this.authToken = authToken;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(opts) {
        return {
          ...super.defaultHeaders(opts),
          ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
          "anthropic-version": "2023-06-01",
          ...this._options.defaultHeaders
        };
      }
      validateHeaders(headers, customHeaders) {
        if (this.apiKey && headers["x-api-key"]) {
          return;
        }
        if (customHeaders["x-api-key"] === null) {
          return;
        }
        if (this.authToken && headers["authorization"]) {
          return;
        }
        if (customHeaders["authorization"] === null) {
          return;
        }
        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
      }
      authHeaders(opts) {
        const apiKeyAuth = this.apiKeyAuth(opts);
        const bearerAuth = this.bearerAuth(opts);
        if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
          return apiKeyAuth;
        }
        if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
          return bearerAuth;
        }
        return {};
      }
      apiKeyAuth(opts) {
        if (this.apiKey == null) {
          return {};
        }
        return { "X-Api-Key": this.apiKey };
      }
      bearerAuth(opts) {
        if (this.authToken == null) {
          return {};
        }
        return { Authorization: `Bearer ${this.authToken}` };
      }
    };
    _a = Anthropic;
    Anthropic.Anthropic = _a;
    Anthropic.HUMAN_PROMPT = "\n\nHuman:";
    Anthropic.AI_PROMPT = "\n\nAssistant:";
    Anthropic.DEFAULT_TIMEOUT = 6e5;
    Anthropic.AnthropicError = AnthropicError;
    Anthropic.APIError = APIError;
    Anthropic.APIConnectionError = APIConnectionError;
    Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
    Anthropic.APIUserAbortError = APIUserAbortError;
    Anthropic.NotFoundError = NotFoundError;
    Anthropic.ConflictError = ConflictError;
    Anthropic.RateLimitError = RateLimitError;
    Anthropic.BadRequestError = BadRequestError;
    Anthropic.AuthenticationError = AuthenticationError;
    Anthropic.InternalServerError = InternalServerError;
    Anthropic.PermissionDeniedError = PermissionDeniedError;
    Anthropic.UnprocessableEntityError = UnprocessableEntityError;
    Anthropic.toFile = toFile;
    Anthropic.fileFromPath = fileFromPath;
    Anthropic.Completions = Completions;
    Anthropic.Messages = Messages2;
    Anthropic.Models = Models2;
    Anthropic.ModelInfosPage = ModelInfosPage;
    Anthropic.Beta = Beta;
    ({ HUMAN_PROMPT, AI_PROMPT } = Anthropic);
    sdk_default = Anthropic;
  }
});

// providers/anthropic.ts
function estimateTokenCount(messages) {
  const CHARS_PER_TOKEN = 4;
  const totalChars = messages.reduce((total, msg) => {
    return total + msg.content.length;
  }, 0);
  return Math.ceil(totalChars / CHARS_PER_TOKEN);
}
var MODEL_CONTEXT_WINDOWS, maxTokens, MODEL_OUTPUT_TOKEN_LIMITS, AnthropicProvider;
var init_anthropic = __esm({
  "providers/anthropic.ts"() {
    init_base2();
    init_sdk();
    init_logger();
    MODEL_CONTEXT_WINDOWS = {
      "claude-3-opus-20240229": 2e5,
      "claude-3-sonnet-20240229": 2e5,
      "claude-3-haiku-20240307": 2e5,
      "claude-3-7-sonnet-20250219": 2e5,
      "claude-3-5-sonnet-20241022": 2e5,
      "claude-3-5-sonnet-20240620": 2e5,
      "claude-3-5-haiku-20241022": 2e5
    };
    maxTokens = 4096;
    MODEL_OUTPUT_TOKEN_LIMITS = {
      "claude-3-7-sonnet-20250219": 64e3,
      "claude-3-5-sonnet-20241022": 8192,
      "claude-3-5-sonnet-20240620": 8192,
      "claude-3-5-haiku-20241022": 8192,
      "claude-3-opus-20240229": 4096,
      "claude-3-sonnet-20240229": 8192,
      // fallback for older sonnet
      "claude-3-haiku-20240307": 4096
      // fallback for older haiku
    };
    AnthropicProvider = class extends BaseProvider {
      // Add debugMode property
      constructor(apiKey, model = "claude-3-sonnet-20240229", debugMode = false) {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl", "https://api.anthropic.com/v1");
        __publicField(this, "model");
        __publicField(this, "client");
        __publicField(this, "debugMode");
        this.apiKey = apiKey;
        this.model = model;
        this.client = new sdk_default({
          apiKey: this.apiKey,
          dangerouslyAllowBrowser: true
          // Required for browser environments
        });
        this.debugMode = debugMode;
        debugLog(true, "debug", "[Anthropic Provider] Initializing Anthropic API", { config: { apiKey, model, debugMode } });
      }
      /**
       * Get a completion from Anthropic
       * 
       * Sends the conversation to Anthropic and streams back the response
       * using the official SDK's streaming support.
       * 
       * Automatically adjusts max_tokens if the request would exceed the model's context window.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c;
        try {
          const contextWindow = (_a2 = MODEL_CONTEXT_WINDOWS[this.model]) != null ? _a2 : 2e5;
          const outputTokenLimit = MODEL_OUTPUT_TOKEN_LIMITS[this.model];
          const inputTokens = estimateTokenCount(messages);
          if (inputTokens > contextWindow) {
            const adjustedMaxTokens = contextWindow - inputTokens;
            if (adjustedMaxTokens <= 0) {
              throw new ProviderError(
                "invalid_request" /* InvalidRequest */,
                `Input is too long for ${this.model}'s context window. Estimated input tokens: ${inputTokens}, context window: ${contextWindow}`
              );
            }
            debugLog(
              this.debugMode,
              "info",
              `max_tokens ${adjustedMaxTokens} to fit within ${this.model}'s context window`
            );
            maxTokens = adjustedMaxTokens;
          }
          if (outputTokenLimit && maxTokens > outputTokenLimit) {
            debugLog(
              this.debugMode,
              "info",
              `Capping max_tokens from ${maxTokens} to model output limit ${outputTokenLimit} for ${this.model}`
            );
            maxTokens = outputTokenLimit;
          }
          const { systemPrompt, anthropicMessages } = this.formatMessages(messages);
          const requestParams = {
            model: this.model,
            messages: anthropicMessages,
            temperature: (_b = options.temperature) != null ? _b : 0,
            // Default temperature if not provided
            max_tokens: maxTokens,
            stream: true
          };
          if (systemPrompt) {
            requestParams.system = systemPrompt;
          }
          const stream = await this.client.messages.create(requestParams);
          try {
            if (stream && typeof stream === "object") {
              if (stream.on && typeof stream.on === "function") {
                await new Promise((resolve, reject) => {
                  stream.on("content_block_delta", (chunk) => {
                    var _a3;
                    if (((_a3 = chunk.delta) == null ? void 0 : _a3.type) === "text_delta" && options.streamCallback) {
                      options.streamCallback(chunk.delta.text);
                    }
                  });
                  stream.on("end", resolve);
                  stream.on("error", reject);
                });
              } else if (Symbol.asyncIterator in stream) {
                for await (const chunk of stream) {
                  if (chunk.type === "content_block_delta" && ((_c = chunk.delta) == null ? void 0 : _c.type) === "text_delta" && options.streamCallback) {
                    options.streamCallback(chunk.delta.text);
                  }
                }
              } else if (options.streamCallback) {
                console.warn("Anthropic response is not a stream, handling as regular response");
                if ("content" in stream && typeof stream.content === "string") {
                  options.streamCallback(stream.content);
                }
              }
            }
          } catch (streamError) {
            debugLog(this.debugMode, "error", "Error processing Anthropic stream:", streamError);
            throw streamError;
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            debugLog(this.debugMode, "info", "Anthropic stream was aborted");
          } else {
            debugLog(this.debugMode, "error", "Error calling Anthropic:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Anthropic models
       * 
       * Returns the list of supported Claude models.
       * Note: Anthropic doesn't have a models endpoint, so we return known models.
       * This list is based on the models defined in MODEL_CONTEXT_WINDOWS.
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          return Object.keys(MODEL_CONTEXT_WINDOWS);
        } catch (error) {
          debugLog(this.debugMode, "error", "Error getting Anthropic models:", error);
          throw error;
        }
      }
      /**
       * Format messages for Anthropic API
       * 
       * Converts from the plugin's Message format to Anthropic's expected format.
       * Handles system messages specially as Anthropic has a different format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages and system prompt for Anthropic API
       */
      formatMessages(messages) {
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        const systemPrompt = systemMessages.length > 0 ? systemMessages.map((msg) => msg.content).join("\n\n") : void 0;
        const anthropicMessages = nonSystemMessages.map((msg) => {
          const role = msg.role === "user" || msg.role === "assistant" ? msg.role : "user";
          return { role, content: msg.content };
        });
        return { systemPrompt, anthropicMessages };
      }
      /**
       * Test connection to Anthropic
       * 
       * Verifies the API key works by attempting a simple completion.
       * 
       * @returns Test results including success/failure
       */
      async testConnection() {
        try {
          await this.client.messages.create({
            model: this.model,
            messages: [{ role: "user", content: "Hi" }],
            max_tokens: 1
          });
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: "Successfully connected to Anthropic!",
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/openai.ts
var OpenAIProvider;
var init_openai = __esm({
  "providers/openai.ts"() {
    init_base2();
    init_logger();
    OpenAIProvider = class extends BaseProvider {
      // Add debugMode property
      constructor(apiKey, model = "gpt-4", baseUrl, debugMode = false) {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        __publicField(this, "debugMode");
        this.apiKey = apiKey;
        this.model = model;
        this.baseUrl = baseUrl || "https://api.openai.com/v1";
        this.debugMode = debugMode;
        debugLog(true, "debug", "[OpenAI Provider] Initializing OpenAI API", { config: { apiKey, model, baseUrl, debugMode } });
      }
      /**
       * Get a completion from OpenAI
       * 
       * Sends the conversation to OpenAI and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e;
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: this.model,
              messages,
              temperature: (_a2 = options.temperature) != null ? _a2 : 0,
              stream: true
            }),
            signal: (_b = options.abortController) == null ? void 0 : _b.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const reader = (_c = response.body) == null ? void 0 : _c.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await (reader == null ? void 0 : reader.read()) || { done: true, value: void 0 };
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.startsWith("data: ") && line !== "data: [DONE]") {
                try {
                  const data = JSON.parse(line.slice(6));
                  const content = (_e = (_d = data.choices[0]) == null ? void 0 : _d.delta) == null ? void 0 : _e.content;
                  if (content && options.streamCallback) {
                    options.streamCallback(content);
                  }
                } catch (e) {
                  debugLog(this.debugMode, "warn", "Error parsing OpenAI response chunk:", e);
                }
              }
            }
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            debugLog(this.debugMode, "info", "OpenAI stream was aborted");
          } else {
            debugLog(this.debugMode, "error", "Error calling OpenAI:", error);
            throw error;
          }
        }
      }
      /**
       * Get available OpenAI models
       * 
       * Fetches the list of models from OpenAI's API.
       * Filters to only include chat models (GPT-3.5, GPT-4, etc.)
       * 
       * @returns List of available model names
       */
      async getAvailableModels() {
        try {
          const response = await fetch(`${this.baseUrl}/models`, {
            method: "GET",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            }
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          return data.data.map((model) => model.id).filter((id) => id.startsWith("gpt-"));
        } catch (error) {
          debugLog(this.debugMode, "error", "Error fetching OpenAI models:", error);
          throw error;
        }
      }
      /**
       * Test connection to OpenAI
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to OpenAI! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
    };
  }
});

// providers/gemini.ts
var GeminiProvider;
var init_gemini = __esm({
  "providers/gemini.ts"() {
    init_base2();
    init_logger();
    GeminiProvider = class extends BaseProvider {
      // Add debugMode property
      constructor(apiKey, model = "gemini-2.0-flash", apiVersion = "v1", debugMode = false) {
        super();
        __publicField(this, "apiKey");
        __publicField(this, "apiVersion");
        __publicField(this, "baseUrl");
        __publicField(this, "model");
        __publicField(this, "debugMode");
        this.apiKey = apiKey;
        this.model = model;
        this.apiVersion = apiVersion;
        this.baseUrl = `https://generativelanguage.googleapis.com/${this.apiVersion}`;
        this.debugMode = debugMode;
        debugLog(true, "debug", "[Gemini Provider] Initializing Gemini API", { config: { apiKey, model, apiVersion, debugMode } });
      }
      /**
       * Determines the correct API version for a given model name.
       * Uses v1beta for preview/experimental/beta models, otherwise v1.
       */
      getBaseUrlForModel(model) {
        if (/preview|exp|experimental|beta/i.test(model)) {
          return "https://generativelanguage.googleapis.com/v1beta";
        }
        return "https://generativelanguage.googleapis.com/v1";
      }
      /**
       * Get a completion from Google Gemini
       * 
       * Sends the conversation to Gemini and streams back the response.
       * 
       * @param messages - The conversation history
       * @param options - Settings for this completion
       */
      async getCompletion(messages, options) {
        var _a2, _b, _c, _d, _e, _f, _g;
        try {
          const formattedMessages = this.formatMessages(messages);
          const baseUrl = this.getBaseUrlForModel(this.model);
          const url = `${baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              contents: formattedMessages,
              generationConfig: {
                temperature: (_a2 = options.temperature) != null ? _a2 : 0
              }
            }),
            signal: (_b = options.abortController) == null ? void 0 : _b.signal
          });
          if (!response.ok) {
            throw this.handleHttpError(response);
          }
          const data = await response.json();
          debugLog(this.debugMode, "debug", "Gemini response:", JSON.stringify(data));
          const text = (_g = (_f = (_e = (_d = (_c = data.candidates) == null ? void 0 : _c[0]) == null ? void 0 : _d.content) == null ? void 0 : _e.parts) == null ? void 0 : _f[0]) == null ? void 0 : _g.text;
          if (text && options.streamCallback) {
            options.streamCallback(text);
          } else {
            debugLog(this.debugMode, "warn", "No text found in Gemini response:", JSON.stringify(data));
          }
        } catch (error) {
          if (error instanceof ProviderError) {
            throw error;
          }
          if (error.name === "AbortError") {
            debugLog(this.debugMode, "info", "Gemini request was aborted");
          } else {
            debugLog(this.debugMode, "error", "Error calling Gemini:", error);
            throw error;
          }
        }
      }
      /**
       * Get available Gemini models from both v1 and v1beta endpoints by default
       *
       * @returns List of available model names (deduplicated)
       */
      async getAvailableModels() {
        const fetchModels = async (version) => {
          var _a2;
          const url = `https://generativelanguage.googleapis.com/${version}/models?key=${this.apiKey}`;
          const response = await fetch(url, {
            method: "GET",
            headers: { "Content-Type": "application/json" }
          });
          if (!response.ok) throw this.handleHttpError(response);
          const data = await response.json();
          return ((_a2 = data.models) == null ? void 0 : _a2.map((model) => model.name.split("/").pop())) || [];
        };
        try {
          const [v1Models, v1betaModels] = await Promise.all([
            fetchModels("v1"),
            fetchModels("v1beta")
          ]);
          return Array.from(/* @__PURE__ */ new Set([...v1Models, ...v1betaModels]));
        } catch (error) {
          debugLog(this.debugMode, "error", "Error fetching Gemini models:", error);
          throw error;
        }
      }
      /**
       * Test connection to Gemini
       * 
       * Verifies the API key works by attempting to list models.
       * 
       * @returns Test results including success/failure and available models
       */
      async testConnection() {
        try {
          const models = await this.getAvailableModels();
          return {
            success: true,
            message: `Successfully connected to Google Gemini! Found ${models.length} available models.`,
            models
          };
        } catch (error) {
          return this.createErrorResponse(error);
        }
      }
      /**
       * Format messages for Gemini API
       * 
       * Converts from the plugin's Message format to Gemini's expected format.
       * 
       * @param messages - Array of messages to format
       * @returns Formatted messages for Gemini API
       */
      formatMessages(messages) {
        const geminiMessages = [];
        const systemMessages = messages.filter((msg) => msg.role === "system");
        const nonSystemMessages = messages.filter((msg) => msg.role !== "system");
        for (const message of systemMessages) {
          geminiMessages.push({
            role: "user",
            parts: [{ text: message.content }]
          });
        }
        for (const message of nonSystemMessages) {
          const role = message.role === "assistant" ? "model" : "user";
          geminiMessages.push({
            role,
            parts: [{ text: message.content }]
          });
        }
        return geminiMessages;
      }
    };
  }
});

// providers/index.ts
function createProvider(settings) {
  var _a2, _b, _c;
  switch (settings.provider) {
    case "openai":
      return new OpenAIProvider(
        settings.openaiSettings.apiKey,
        settings.openaiSettings.model,
        settings.openaiSettings.baseUrl,
        (_a2 = settings.debugMode) != null ? _a2 : false
        // Pass debugMode
      );
    case "anthropic":
      return new AnthropicProvider(
        settings.anthropicSettings.apiKey,
        settings.anthropicSettings.model,
        (_b = settings.debugMode) != null ? _b : false
        // Pass debugMode
      );
    case "gemini":
      return new GeminiProvider(
        settings.geminiSettings.apiKey,
        settings.geminiSettings.model,
        void 0,
        // apiVersion is optional, so pass undefined if not explicitly set
        (_c = settings.debugMode) != null ? _c : false
        // Pass debugMode
      );
    default:
      throw new Error(`Invalid provider type: ${settings.provider}`);
  }
}
function createProviderFromUnifiedModel(settings, unifiedModelId) {
  var _a2, _b, _c;
  const [providerType, modelId] = unifiedModelId.split(":", 2);
  switch (providerType) {
    case "openai":
      return new OpenAIProvider(settings.openaiSettings.apiKey, modelId, settings.openaiSettings.baseUrl, (_a2 = settings.debugMode) != null ? _a2 : false);
    // Pass debugMode
    case "anthropic":
      return new AnthropicProvider(settings.anthropicSettings.apiKey, modelId, (_b = settings.debugMode) != null ? _b : false);
    // Pass debugMode
    case "gemini":
      return new GeminiProvider(settings.geminiSettings.apiKey, modelId, void 0, (_c = settings.debugMode) != null ? _c : false);
    // Pass debugMode
    default:
      throw new Error(`Invalid provider type: ${providerType}`);
  }
}
async function getAllAvailableModels(settings) {
  const allModels = [];
  const getProviderDisplayName = (provider) => {
    switch (provider) {
      case "openai":
        return "OpenAI";
      case "anthropic":
        return "Anthropic";
      case "gemini":
        return "Google";
      default:
        return provider;
    }
  };
  if (settings.openaiSettings.apiKey && settings.openaiSettings.availableModels.length > 0) {
    settings.openaiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `openai:${model}`,
        name: `${model} (${getProviderDisplayName("openai")})`,
        provider: "openai",
        modelId: model
      });
    });
  }
  if (settings.anthropicSettings.apiKey && settings.anthropicSettings.availableModels.length > 0) {
    settings.anthropicSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `anthropic:${model}`,
        name: `${model} (${getProviderDisplayName("anthropic")})`,
        provider: "anthropic",
        modelId: model
      });
    });
  }
  if (settings.geminiSettings.apiKey && settings.geminiSettings.availableModels.length > 0) {
    settings.geminiSettings.availableModels.forEach((model) => {
      allModels.push({
        id: `gemini:${model}`,
        name: `${model} (${getProviderDisplayName("gemini")})`,
        provider: "gemini",
        modelId: model
      });
    });
  }
  return allModels;
}
function getProviderFromUnifiedModel(unifiedModelId) {
  const [providerType] = unifiedModelId.split(":", 2);
  return providerType;
}
function getModelIdFromUnifiedModel(unifiedModelId) {
  const [, modelId] = unifiedModelId.split(":", 2);
  return modelId;
}
var init_providers = __esm({
  "providers/index.ts"() {
    init_base2();
    init_anthropic();
    init_openai();
    init_gemini();
  }
});

// src/components/chat/chatPersistence.ts
function buildChatYaml(settings, provider, model) {
  var _a2, _b, _c, _d, _e;
  debugLog((_a2 = settings.debugMode) != null ? _a2 : false, "info", "[buildChatYaml] Entered function", { settings, provider, model });
  if (settings.selectedModel) {
    const providerType = getProviderFromUnifiedModel(settings.selectedModel);
    const modelId = getModelIdFromUnifiedModel(settings.selectedModel);
    const yamlObj = {
      provider: providerType,
      model: modelId,
      unified_model: settings.selectedModel,
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    debugLog((_b = settings.debugMode) != null ? _b : false, "debug", "[buildChatYaml] Using unified model format", yamlObj);
    debugLog((_c = settings.debugMode) != null ? _c : false, "info", "[buildChatYaml] Returning YAML for unified model", { yaml: `---
${dump(yamlObj)}---
` });
    return `---
${dump(yamlObj)}---
`;
  } else {
    const yamlObj = {
      provider: provider || settings.provider,
      model: model || getCurrentModelForProvider(settings),
      system_message: settings.systemMessage,
      temperature: settings.temperature
    };
    debugLog((_d = settings.debugMode) != null ? _d : false, "debug", "[buildChatYaml] Using legacy model format", yamlObj);
    debugLog((_e = settings.debugMode) != null ? _e : false, "info", "[buildChatYaml] Returning YAML for legacy model", { yaml: `---
${dump(yamlObj)}---
` });
    return `---
${dump(yamlObj)}---
`;
  }
}
function getCurrentModelForProvider(settings) {
  var _a2;
  debugLog((_a2 = settings.debugMode) != null ? _a2 : false, "debug", "[getCurrentModelForProvider] Called", { provider: settings.provider });
  switch (settings.provider) {
    case "openai":
      return settings.openaiSettings.model;
    case "anthropic":
      return settings.anthropicSettings.model;
    case "gemini":
      return settings.geminiSettings.model;
    case "ollama":
      return settings.ollamaSettings.model;
    default:
      return "";
  }
}
async function saveChatAsNote({
  app,
  messages,
  chatContent,
  settings,
  provider,
  model,
  chatSeparator,
  chatNoteFolder,
  agentResponseHandler
}) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  debugLog((_a2 = settings.debugMode) != null ? _a2 : false, "info", "[saveChatAsNote] Entered function", { hasMessages: !!messages, hasChatContent: typeof chatContent === "string" });
  let content = "";
  if (typeof chatContent === "string") {
    debugLog((_b = settings.debugMode) != null ? _b : false, "info", "[saveChatAsNote] Using provided chatContent string directly.");
    content = chatContent;
  } else if (messages) {
    debugLog((_c = settings.debugMode) != null ? _c : false, "info", "[saveChatAsNote] Building chat content from message DOM nodes.");
    const messageRenderer = new MessageRenderer(app);
    messages.forEach((el, index) => {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      const htmlElement = el;
      if (htmlElement.classList.contains("tool-display-message")) {
        debugLog((_a3 = settings.debugMode) != null ? _a3 : false, "debug", `[saveChatAsNote] Skipping tool-display-message at index ${index}`);
        return;
      }
      const messageDataStr = htmlElement.dataset.messageData;
      let messageData = null;
      if (messageDataStr) {
        try {
          messageData = JSON.parse(messageDataStr);
          debugLog((_b2 = settings.debugMode) != null ? _b2 : false, "debug", `[saveChatAsNote] Parsed messageData at index ${index}`, messageData);
        } catch (e) {
          debugLog((_c2 = settings.debugMode) != null ? _c2 : false, "warn", `[saveChatAsNote] Failed to parse messageData at index ${index}`, e);
        }
      }
      if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
        debugLog((_d2 = settings.debugMode) != null ? _d2 : false, "info", `[saveChatAsNote] Formatting message with toolResults at index ${index}`);
        content += messageRenderer.getMessageContentForCopy(messageData);
      } else {
        const rawContent = htmlElement.dataset.rawContent;
        const msg = rawContent !== void 0 ? rawContent : ((_e2 = el.querySelector(".message-content")) == null ? void 0 : _e2.textContent) || "";
        debugLog((_f2 = settings.debugMode) != null ? _f2 : false, "debug", `[saveChatAsNote] Appending regular message at index ${index}`, { msg });
        content += msg;
      }
      if (index < messages.length - 1) {
        content += "\n\n" + chatSeparator + "\n\n";
      }
    });
    debugLog((_d = settings.debugMode) != null ? _d : false, "debug", "[saveChatAsNote] messages NodeList length:", { length: messages.length });
  } else {
    debugLog((_e = settings.debugMode) != null ? _e : false, "error", "[saveChatAsNote] Neither messages nor chatContent provided. Aborting.");
    throw new Error("Either messages or chatContent must be provided");
  }
  const yaml = buildChatYaml(settings, provider || "", model || "");
  debugLog((_f = settings.debugMode) != null ? _f : false, "info", "[saveChatAsNote] YAML frontmatter built. Stripping any existing YAML from chat content.");
  content = content.replace(/^---\s*[\s\S]*?---\n?/, "");
  content = content.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  content = content.replace(/\n{3,}/g, "\n\n");
  content = content.replace(/\n+$/, "");
  const noteContent = yaml + "\n" + content + "\n";
  const now = /* @__PURE__ */ new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const fileName = `Chat Export ${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}-${pad(now.getMinutes())}.md`;
  let filePath = fileName;
  const folder = chatNoteFolder == null ? void 0 : chatNoteFolder.trim();
  if (folder) {
    debugLog((_g = settings.debugMode) != null ? _g : false, "info", `[saveChatAsNote] Ensuring chat note folder exists: ${folder}`);
    const folderExists = app.vault.getAbstractFileByPath(folder);
    if (!folderExists) {
      try {
        await app.vault.createFolder(folder);
        debugLog((_h = settings.debugMode) != null ? _h : false, "info", `[saveChatAsNote] Created chat note folder: ${folder}`);
      } catch (e) {
        if (!app.vault.getAbstractFileByPath(folder)) {
          debugLog((_i = settings.debugMode) != null ? _i : false, "error", `[saveChatAsNote] Failed to create folder for chat note: ${folder}`, e);
          new import_obsidian11.Notice("Failed to create folder for chat note.");
          return;
        } else {
          debugLog((_j = settings.debugMode) != null ? _j : false, "warn", `[saveChatAsNote] Folder already exists after race: ${folder}`);
        }
      }
    } else {
      debugLog((_k = settings.debugMode) != null ? _k : false, "debug", `[saveChatAsNote] Folder already exists: ${folder}`);
    }
    filePath = folder.replace(/[\/\\]+$/, "") + "/" + fileName;
  }
  let finalFilePath = filePath;
  let attempt = 1;
  while (app.vault.getAbstractFileByPath(finalFilePath)) {
    const extIndex = fileName.lastIndexOf(".");
    const base = extIndex !== -1 ? fileName.substring(0, extIndex) : fileName;
    const ext = extIndex !== -1 ? fileName.substring(extIndex) : "";
    finalFilePath = (folder ? folder.replace(/[\/\\]+$/, "") + "/" : "") + `${base} (${attempt})${ext}`;
    debugLog((_l = settings.debugMode) != null ? _l : false, "warn", "[saveChatAsNote] File already exists, trying new filename", { finalFilePath });
    attempt++;
  }
  try {
    await app.vault.create(finalFilePath, noteContent);
    debugLog((_m = settings.debugMode) != null ? _m : false, "info", "[saveChatAsNote] Chat successfully saved as note", { finalFilePath });
    new import_obsidian11.Notice(`Chat saved as note: ${finalFilePath}`);
  } catch (e) {
    debugLog((_n = settings.debugMode) != null ? _n : false, "error", "[saveChatAsNote] Failed to save chat as note", { finalFilePath, error: e });
    new import_obsidian11.Notice("Failed to save chat as note.");
  }
  debugLog((_o = settings.debugMode) != null ? _o : false, "info", "[saveChatAsNote] Exiting function. Save process complete.");
  return;
}
async function loadChatYamlAndApplySettings({
  app,
  plugin,
  settings,
  file
}) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  debugLog((_a2 = settings.debugMode) != null ? _a2 : false, "info", "[loadChatYamlAndApplySettings] Entered function", { file: (file == null ? void 0 : file.path) || (file == null ? void 0 : file.name) || file });
  debugLog((_b = settings.debugMode) != null ? _b : false, "debug", "[loadChatYamlAndApplySettings] File content loaded. Extracting YAML frontmatter.");
  let content = await app.vault.read(file);
  const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
  let yamlObj = {};
  if (yamlMatch) {
    try {
      yamlObj = load(yamlMatch[1]) || {};
      debugLog((_c = settings.debugMode) != null ? _c : false, "info", "[loadChatYamlAndApplySettings] YAML frontmatter parsed", yamlObj);
    } catch (e) {
      debugLog((_d = settings.debugMode) != null ? _d : false, "warn", "[loadChatYamlAndApplySettings] Failed to parse YAML frontmatter", e);
      yamlObj = {};
    }
  } else {
    debugLog((_e = settings.debugMode) != null ? _e : false, "warn", "[loadChatYamlAndApplySettings] No YAML frontmatter found in file.");
  }
  if (yamlObj.unified_model) {
    settings.selectedModel = yamlObj.unified_model;
    debugLog((_f = settings.debugMode) != null ? _f : false, "info", "[loadChatYamlAndApplySettings] Loaded unified_model from YAML", yamlObj.unified_model);
    debugLog((_g = settings.debugMode) != null ? _g : false, "info", "[loadChatYamlAndApplySettings] Set selectedModel from unified_model", { selectedModel: settings.selectedModel });
  } else if (yamlObj.provider && yamlObj.model) {
    const unifiedModelId = `${yamlObj.provider}:${yamlObj.model}`;
    settings.selectedModel = unifiedModelId;
    debugLog((_h = settings.debugMode) != null ? _h : false, "info", "[loadChatYamlAndApplySettings] Loaded legacy provider/model from YAML", { provider: yamlObj.provider, model: yamlObj.model });
    debugLog((_i = settings.debugMode) != null ? _i : false, "info", "[loadChatYamlAndApplySettings] Set selectedModel from provider/model", { selectedModel: settings.selectedModel });
    settings.provider = yamlObj.provider;
    switch (yamlObj.provider) {
      case "openai":
        settings.openaiSettings.model = yamlObj.model;
        break;
      case "anthropic":
        settings.anthropicSettings.model = yamlObj.model;
        break;
      case "gemini":
        settings.geminiSettings.model = yamlObj.model;
        break;
      case "ollama":
        settings.ollamaSettings.model = yamlObj.model;
        break;
    }
  } else {
    debugLog((_j = settings.debugMode) != null ? _j : false, "warn", "[loadChatYamlAndApplySettings] No model/provider found in YAML. Using existing settings.");
  }
  let newSystemMessage = yamlObj.system_message || settings.systemMessage;
  let newTemperature = settings.temperature;
  if (yamlObj.temperature !== void 0) {
    const tempNum = parseFloat(yamlObj.temperature);
    if (!isNaN(tempNum)) {
      newTemperature = tempNum;
      debugLog((_k = settings.debugMode) != null ? _k : false, "info", "[loadChatYamlAndApplySettings] Loaded temperature from YAML", newTemperature);
    } else {
      debugLog((_l = settings.debugMode) != null ? _l : false, "warn", "[loadChatYamlAndApplySettings] Invalid temperature in YAML, using existing value.", yamlObj.temperature);
    }
  }
  settings.systemMessage = newSystemMessage;
  settings.temperature = newTemperature;
  debugLog((_m = settings.debugMode) != null ? _m : false, "info", "[loadChatYamlAndApplySettings] Applied settings from YAML", { selectedModel: settings.selectedModel, systemMessage: newSystemMessage, temperature: newTemperature });
  if (plugin.onSettingsLoadedFromNote) {
    debugLog((_n = settings.debugMode) != null ? _n : false, "debug", "[loadChatYamlAndApplySettings] Calling plugin.onSettingsLoadedFromNote");
    plugin.onSettingsLoadedFromNote(settings);
  }
  debugLog((_o = settings.debugMode) != null ? _o : false, "info", "[loadChatYamlAndApplySettings] Exiting function. YAML load/apply process complete.");
  return {
    provider: yamlObj.provider,
    model: yamlObj.model,
    unifiedModel: settings.selectedModel,
    systemMessage: newSystemMessage,
    temperature: newTemperature
  };
}
var import_obsidian11;
var init_chatPersistence = __esm({
  "src/components/chat/chatPersistence.ts"() {
    init_js_yaml();
    init_logger();
    init_providers();
    init_MessageRenderer();
    import_obsidian11 = require("obsidian");
  }
});

// src/components/chat/ChatHelpModal.ts
var import_obsidian12, ChatHelpModal;
var init_ChatHelpModal = __esm({
  "src/components/chat/ChatHelpModal.ts"() {
    import_obsidian12 = require("obsidian");
    ChatHelpModal = class extends import_obsidian12.Modal {
      constructor(app) {
        super(app);
      }
      /**
       * Creates a collapsible section with a title and content.
       * @param title The section title
       * @param contentCallback Function to populate the section content
       * @param expanded Whether the section is expanded by default
       * @returns The section container element
       */
      createCollapsibleSection(title, contentCallback, expanded = true) {
        const sectionContainer = createDiv();
        sectionContainer.addClass("ai-collapsible-section");
        const header = createDiv();
        header.addClass("ai-collapsible-header");
        const arrow = createSpan();
        arrow.addClass("ai-collapsible-arrow");
        arrow.textContent = expanded ? "\u25BC" : "\u25B6";
        const titleSpan = createSpan();
        titleSpan.textContent = title;
        header.appendChild(arrow);
        header.appendChild(titleSpan);
        const content = createDiv();
        content.addClass("ai-collapsible-content");
        content.style.display = expanded ? "block" : "none";
        header.addEventListener("click", () => {
          const isExpanded = content.style.display !== "none";
          content.style.display = isExpanded ? "none" : "block";
          arrow.textContent = isExpanded ? "\u25B6" : "\u25BC";
        });
        sectionContainer.appendChild(header);
        sectionContainer.appendChild(content);
        const originalContent = this.contentEl;
        this.contentEl = content;
        contentCallback();
        this.contentEl = originalContent;
        return sectionContainer;
      }
      /**
       * Called when the modal is opened.
       * Populates the modal with collapsible help sections.
       */
      onOpen() {
        this.titleEl.setText("AI Chat Help");
        this.contentEl.empty();
        this.contentEl.appendChild(this.createCollapsibleSection("Slash Commands", () => {
          this.contentEl.innerHTML = `
                <code>/clear</code> \u2013 Clear the chat<br>
                <code>/copy</code> \u2013 Copy all chat<br>
                <code>/save</code> \u2013 Save chat as note<br>
                <code>/settings</code> \u2013 Open settings<br>
                <code>/help</code> \u2013 Show this help<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Keyboard Shortcuts (when chat window or input is focused)", () => {
          this.contentEl.innerHTML = `
                <code>Ctrl+Shift+X</code> \u2013 Clear chat<br>
                <code>Ctrl+Shift+C</code> \u2013 Copy all chat<br>
                <code>Ctrl+Shift+S</code> \u2013 Save as note<br>
                <code>Ctrl+Shift+O</code> \u2013 Open settings<br>
                <code>Ctrl+Shift+H</code> \u2013 Show this help<br>
                <code>Ctrl+Shift+R</code> \u2013 Toggle referencing current note<br>
                <br>
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Other", () => {
          this.contentEl.innerHTML = `
                <code>Enter</code> \u2013 Send message<br>
                <code>Shift+Enter</code> \u2013 Newline<br>
                <br>
                You can also use the buttons at the top of the chat window.
            `;
        }));
        this.contentEl.appendChild(this.createCollapsibleSection("Reference Current Note", () => {
          this.contentEl.innerHTML = `
                <strong>What is it?</strong><br>
                When enabled, the AI can see the content of your currently active note during chat. This helps the AI give more relevant, context-aware responses.<br><br>

                <strong>How to use:</strong><br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>Click the <code>\u{1F4DD}</code> button at the top of the chat window to toggle referencing the current note.</li>
                  <li>Or use the slash command <code>/ref</code> or keyboard shortcut <code>Ctrl+Shift+R</code>.</li>
                  <li>The name of the referenced note will appear in faded small text below the buttons when enabled.</li>
                </ul>

                <strong>Notes:</strong><br>
                - When referencing is enabled, the AI receives:<br>
                <ul style="margin-top:0;margin-bottom:0.5em;">
                  <li>The system prompt (always)</li>
                  <li>Context notes (if enabled in settings)</li>
                  <li>The content of the currently active note</li>
                  <li>The chat history (all previous user/assistant messages)</li>
                </ul>
                - Only the currently active note is shared in addition to the above context.<br>
                - You can turn this on or off at any time.<br>
                - No other notes or personal data are accessed.<br>
                - The <code>\u{1F4DD}</code> button will show "On" or "Off" to indicate the current state.
            `;
        }));
      }
    };
  }
});

// src/components/chat/ConfirmationModal.ts
var import_obsidian13, ConfirmationModal;
var init_ConfirmationModal = __esm({
  "src/components/chat/ConfirmationModal.ts"() {
    import_obsidian13 = require("obsidian");
    ConfirmationModal = class extends import_obsidian13.Modal {
      /**
       * Constructs a ConfirmationModal.
       * @param app Obsidian App instance
       * @param title Modal title text
       * @param message Message to display in the modal
       * @param onConfirm Callback invoked with true (confirmed) or false (cancelled)
       */
      constructor(app, title, message, onConfirm) {
        super(app);
        __publicField(this, "onConfirm");
        __publicField(this, "message");
        this.titleEl.setText(title);
        this.message = message;
        this.onConfirm = onConfirm;
      }
      /**
       * Called when the modal is opened.
       * Renders the message and Cancel/Delete buttons.
       */
      onOpen() {
        const { contentEl } = this;
        contentEl.addClass("ai-assistant-modal");
        contentEl.createEl("p", { text: this.message });
        const buttonContainer = contentEl.createDiv("modal-button-container");
        buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
          this.onConfirm(false);
          this.close();
        });
        const confirmButton = buttonContainer.createEl("button", {
          text: "Delete",
          cls: "mod-warning"
        });
        confirmButton.addEventListener("click", () => {
          this.onConfirm(true);
          this.close();
        });
      }
      /**
       * Called when the modal is closed.
       * Cleans up the modal content.
       */
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/utils/saveAICalls.ts
async function saveAICallToFolder(request, response, plugin, folder = "ai-calls") {
  var _a2, _b;
  const debugMode = (_a2 = plugin.settings.debugMode) != null ? _a2 : false;
  const vaultBase = plugin.app.vault.adapter.basePath;
  const pluginId = ((_b = plugin.manifest) == null ? void 0 : _b.id) || "ai-assistant-for-obsidian";
  const pluginFolder = path.join(vaultBase, ".obsidian", "plugins", pluginId);
  debugLog(debugMode, "info", "[saveAICalls.ts] pluginFolder:", pluginFolder);
  const targetFolder = path.join(pluginFolder, folder);
  debugLog(debugMode, "info", "[saveAICalls.ts] targetFolder:", targetFolder);
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  let fileName = `ai-call-${timestamp2}.txt`;
  let finalFilePath = path.join(targetFolder, fileName);
  debugLog(debugMode, "info", "[saveAICalls.ts] finalFilePath:", finalFilePath);
  const fileContent = `# AI Call

## Request
\`\`\`json
${JSON.stringify(request, null, 2)}
\`\`\`

## Response
\`\`\`json
${JSON.stringify(response, null, 2)}
\`\`\``;
  try {
    if (!fs.existsSync(targetFolder)) {
      debugLog(debugMode, "info", "[saveAICalls.ts] Plugin folder does not exist, creating:", targetFolder);
      fs.mkdirSync(targetFolder, { recursive: true });
      debugLog(debugMode, "info", "[saveAICalls.ts] Plugin folder created:", targetFolder);
    } else {
      debugLog(debugMode, "debug", "[saveAICalls.ts] Plugin folder already exists:", targetFolder);
    }
  } catch (e) {
    debugLog(debugMode, "warn", "[saveAICalls.ts] Error creating plugin folder (may already exist):", e);
  }
  let attempts = 0;
  while (fs.existsSync(finalFilePath)) {
    attempts++;
    fileName = `ai-call-${timestamp2}-${Math.floor(Math.random() * 1e4)}.txt`;
    finalFilePath = path.join(targetFolder, fileName);
    debugLog(debugMode, "warn", `[saveAICalls.ts] File already exists, trying new filename (attempt ${attempts}):`, finalFilePath);
    if (attempts > 5) {
      debugLog(debugMode, "error", "[saveAICalls.ts] Too many attempts to find unique filename, aborting.");
      throw new Error("Could not create a unique filename for AI call log.");
    }
  }
  try {
    fs.writeFileSync(finalFilePath, fileContent, "utf8");
    debugLog(debugMode, "info", "[saveAICalls.ts] AI call saved successfully in plugin folder:", finalFilePath);
  } catch (e) {
    debugLog(debugMode, "error", "[saveAICalls.ts] Failed to save AI call in plugin folder:", e);
    throw e;
  }
}
var fs, path;
var init_saveAICalls = __esm({
  "src/utils/saveAICalls.ts"() {
    init_logger();
    fs = __toESM(require("fs"));
    path = __toESM(require("path"));
  }
});

// src/utils/objectPool.ts
var ObjectPool, _MessageContextPool, MessageContextPool, WeakCache, _PreAllocatedArrays, PreAllocatedArrays;
var init_objectPool = __esm({
  "src/utils/objectPool.ts"() {
    ObjectPool = class {
      constructor(createFn, resetFn, maxSize = 50) {
        __publicField(this, "pool", []);
        __publicField(this, "createFn");
        __publicField(this, "resetFn");
        __publicField(this, "maxSize");
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.maxSize = maxSize;
      }
      /**
       * Get an object from the pool or create a new one
       */
      acquire() {
        if (this.pool.length > 0) {
          return this.pool.pop();
        }
        return this.createFn();
      }
      /**
       * Return an object to the pool for reuse
       */
      release(obj) {
        if (this.pool.length < this.maxSize) {
          if (this.resetFn) {
            this.resetFn(obj);
          }
          this.pool.push(obj);
        }
      }
      /**
       * Clear the pool
       */
      clear() {
        this.pool.length = 0;
      }
      /**
       * Get current pool size
       */
      size() {
        return this.pool.length;
      }
    };
    _MessageContextPool = class _MessageContextPool {
      constructor() {
        __publicField(this, "messagePool");
        __publicField(this, "arrayPool");
        __publicField(this, "acquiredMessages", 0);
        __publicField(this, "releasedMessages", 0);
        __publicField(this, "acquiredArrays", 0);
        __publicField(this, "releasedArrays", 0);
        this.messagePool = new ObjectPool(
          () => ({ role: "", content: "" }),
          (obj) => {
            obj.role = "";
            obj.content = "";
          }
        );
        this.arrayPool = new ObjectPool(
          () => [],
          (arr) => {
            arr.length = 0;
          }
        );
      }
      static getInstance() {
        if (!_MessageContextPool.instance) {
          _MessageContextPool.instance = new _MessageContextPool();
        }
        return _MessageContextPool.instance;
      }
      acquireMessage() {
        this.acquiredMessages++;
        return this.messagePool.acquire();
      }
      releaseMessage(msg) {
        this.releasedMessages++;
        this.messagePool.release(msg);
      }
      acquireArray() {
        this.acquiredArrays++;
        return this.arrayPool.acquire();
      }
      releaseArray(arr) {
        this.releasedArrays++;
        this.arrayPool.release(arr);
      }
      clear() {
        this.messagePool.clear();
        this.arrayPool.clear();
        this.acquiredMessages = 0;
        this.releasedMessages = 0;
        this.acquiredArrays = 0;
        this.releasedArrays = 0;
      }
      getStats() {
        const messageSizeEstimate = 50;
        const arraySizeEstimate = 24;
        const messageSaved = (this.releasedMessages - this.messagePool.size()) * messageSizeEstimate;
        const arraySaved = (this.releasedArrays - this.arrayPool.size()) * arraySizeEstimate;
        return {
          acquiredMessages: this.acquiredMessages,
          releasedMessages: this.releasedMessages,
          estimatedMessageMemorySaved: `${(messageSaved / 1024).toFixed(2)} KB`,
          acquiredArrays: this.acquiredArrays,
          releasedArrays: this.releasedArrays,
          estimatedArrayMemorySaved: `${(arraySaved / 1024).toFixed(2)} KB`
        };
      }
    };
    __publicField(_MessageContextPool, "instance");
    MessageContextPool = _MessageContextPool;
    WeakCache = class {
      constructor() {
        __publicField(this, "cache", /* @__PURE__ */ new WeakMap());
      }
      set(key, value) {
        this.cache.set(key, value);
      }
      get(key) {
        return this.cache.get(key);
      }
      has(key) {
        return this.cache.has(key);
      }
      delete(key) {
        return this.cache.delete(key);
      }
    };
    _PreAllocatedArrays = class _PreAllocatedArrays {
      constructor() {
        __publicField(this, "arrays", /* @__PURE__ */ new Map());
        __publicField(this, "acquiredArraysCount", /* @__PURE__ */ new Map());
        __publicField(this, "releasedArraysCount", /* @__PURE__ */ new Map());
      }
      static getInstance() {
        if (!_PreAllocatedArrays.instance) {
          _PreAllocatedArrays.instance = new _PreAllocatedArrays();
        }
        return _PreAllocatedArrays.instance;
      }
      /**
       * Get a pre-allocated array of specified size
       */
      getArray(size) {
        this.acquiredArraysCount.set(size, (this.acquiredArraysCount.get(size) || 0) + 1);
        if (!this.arrays.has(size)) {
          this.arrays.set(size, []);
        }
        const pool = this.arrays.get(size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.length = 0;
          return arr;
        }
        return new Array(size);
      }
      /**
       * Return array to pool for reuse
       */
      returnArray(arr) {
        const size = arr.length;
        this.releasedArraysCount.set(size, (this.releasedArraysCount.get(size) || 0) + 1);
        if (!this.arrays.has(size)) {
          this.arrays.set(size, []);
        }
        const pool = this.arrays.get(size);
        if (pool.length < 10) {
          arr.length = 0;
          pool.push(arr);
        }
      }
      /**
       * Clear all pools
       */
      clear() {
        this.arrays.clear();
        this.acquiredArraysCount.clear();
        this.releasedArraysCount.clear();
      }
      getStats() {
        let totalAcquired = 0;
        let totalReleased = 0;
        let estimatedSavedBytes = 0;
        const arraysBySize = [];
        for (const [size, pool] of this.arrays.entries()) {
          const acquired = this.acquiredArraysCount.get(size) || 0;
          const released = this.releasedArraysCount.get(size) || 0;
          const inPool = pool.length;
          totalAcquired += acquired;
          totalReleased += released;
          const arrayOverhead = 24;
          const elementSize = 8;
          const savedForSize = (released - inPool) * (arrayOverhead + size * elementSize);
          estimatedSavedBytes += savedForSize;
          arraysBySize.push({ size, acquired, released, inPool });
        }
        return {
          totalAcquired,
          totalReleased,
          estimatedMemorySaved: `${(estimatedSavedBytes / 1024).toFixed(2)} KB`,
          arraysBySize: arraysBySize.sort((a, b) => a.size - b.size)
        };
      }
    };
    __publicField(_PreAllocatedArrays, "instance");
    PreAllocatedArrays = _PreAllocatedArrays;
  }
});

// src/utils/lruCache.ts
var LRUCache, LRUCacheFactory;
var init_lruCache = __esm({
  "src/utils/lruCache.ts"() {
    LRUCache = class {
      constructor(options) {
        __publicField(this, "maxSize");
        __publicField(this, "defaultTTL");
        __publicField(this, "onEvict");
        __publicField(this, "cache", /* @__PURE__ */ new Map());
        __publicField(this, "head", null);
        __publicField(this, "tail", null);
        __publicField(this, "cleanupInterval", null);
        this.maxSize = options.maxSize;
        this.defaultTTL = options.defaultTTL;
        this.onEvict = options.onEvict;
        if (this.defaultTTL) {
          this.startCleanupInterval();
        }
      }
      /**
       * Get a value from the cache
       */
      get(key) {
        const node = this.cache.get(key);
        if (!node) {
          return void 0;
        }
        if (this.isExpired(node)) {
          this.delete(key);
          return void 0;
        }
        this.moveToHead(node);
        return node.value;
      }
      /**
       * Set a value in the cache
       */
      set(key, value, ttl) {
        const existingNode = this.cache.get(key);
        if (existingNode) {
          existingNode.value = value;
          existingNode.timestamp = Date.now();
          existingNode.ttl = ttl != null ? ttl : this.defaultTTL;
          this.moveToHead(existingNode);
          return;
        }
        const newNode = {
          key,
          value,
          timestamp: Date.now(),
          ttl: ttl != null ? ttl : this.defaultTTL,
          prev: null,
          next: null
        };
        this.cache.set(key, newNode);
        this.addToHead(newNode);
        if (this.cache.size > this.maxSize) {
          this.evictLRU();
        }
      }
      /**
       * Check if a key exists in the cache
       */
      has(key) {
        const node = this.cache.get(key);
        if (!node) {
          return false;
        }
        if (this.isExpired(node)) {
          this.delete(key);
          return false;
        }
        return true;
      }
      /**
       * Delete a key from the cache
       */
      delete(key) {
        const node = this.cache.get(key);
        if (!node) {
          return false;
        }
        this.removeNode(node);
        this.cache.delete(key);
        if (this.onEvict) {
          this.onEvict(key, node.value);
        }
        return true;
      }
      /**
       * Clear all items from the cache
       */
      clear() {
        if (this.onEvict) {
          for (const [key, node] of this.cache) {
            this.onEvict(key, node.value);
          }
        }
        this.cache.clear();
        this.head = null;
        this.tail = null;
      }
      /**
       * Get current cache size
       */
      size() {
        return this.cache.size;
      }
      /**
       * Get maximum cache size
       */
      maxCacheSize() {
        return this.maxSize;
      }
      /**
       * Get all keys in the cache (ordered from most to least recently used)
       */
      keys() {
        const keys = [];
        let current = this.head;
        while (current) {
          keys.push(current.key);
          current = current.next;
        }
        return keys;
      }
      /**
       * Get all values in the cache (ordered from most to least recently used)
       */
      values() {
        const values = [];
        let current = this.head;
        while (current) {
          if (!this.isExpired(current)) {
            values.push(current.value);
          }
          current = current.next;
        }
        return values;
      }
      /**
       * Get cache statistics
       */
      getStats() {
        let oldestTimestamp;
        let newestTimestamp;
        if (this.tail) {
          oldestTimestamp = this.tail.timestamp;
        }
        if (this.head) {
          newestTimestamp = this.head.timestamp;
        }
        return {
          size: this.cache.size,
          maxSize: this.maxSize,
          oldestTimestamp,
          newestTimestamp
        };
      }
      /**
       * Manually trigger cleanup of expired items
       */
      cleanup() {
        let removedCount = 0;
        const now = Date.now();
        const keysToRemove = [];
        for (const [key, node] of this.cache) {
          if (this.isExpired(node, now)) {
            keysToRemove.push(key);
          }
        }
        for (const key of keysToRemove) {
          this.delete(key);
          removedCount++;
        }
        return removedCount;
      }
      /**
       * Update the max size of the cache
       */
      setMaxSize(newMaxSize) {
        this.maxSize = newMaxSize;
        while (this.cache.size > this.maxSize) {
          this.evictLRU();
        }
      }
      /**
       * Destroy the cache and cleanup resources
       */
      destroy() {
        if (this.cleanupInterval) {
          clearInterval(this.cleanupInterval);
          this.cleanupInterval = null;
        }
        this.clear();
      }
      isExpired(node, now = Date.now()) {
        if (!node.ttl) {
          return false;
        }
        return now > node.timestamp + node.ttl;
      }
      moveToHead(node) {
        this.removeNode(node);
        this.addToHead(node);
      }
      addToHead(node) {
        node.prev = null;
        node.next = this.head;
        if (this.head) {
          this.head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
      }
      removeNode(node) {
        if (node.prev) {
          node.prev.next = node.next;
        } else {
          this.head = node.next;
        }
        if (node.next) {
          node.next.prev = node.prev;
        } else {
          this.tail = node.prev;
        }
      }
      evictLRU() {
        if (!this.tail) {
          return;
        }
        const lruNode = this.tail;
        this.removeNode(lruNode);
        this.cache.delete(lruNode.key);
        if (this.onEvict) {
          this.onEvict(lruNode.key, lruNode.value);
        }
      }
      startCleanupInterval() {
        this.cleanupInterval = setInterval(() => {
          this.cleanup();
        }, 5 * 60 * 1e3);
      }
    };
    LRUCacheFactory = class {
      /**
       * Create a cache for AI responses
       */
      static createResponseCache(maxSize = 100) {
        return new LRUCache({
          maxSize,
          defaultTTL: 5 * 60 * 1e3,
          // 5 minutes
          onEvict: (key, value) => {
          }
        });
      }
      /**
       * Create a cache for DOM elements
       */
      static createDOMCache(maxSize = 50) {
        return new LRUCache({
          maxSize,
          defaultTTL: 10 * 60 * 1e3,
          // 10 minutes
          onEvict: (key, element) => {
            if (element.parentNode) {
              element.parentNode.removeChild(element);
            }
          }
        });
      }
      /**
       * Create a cache for API data
       */
      static createAPICache(maxSize = 200) {
        return new LRUCache({
          maxSize,
          defaultTTL: 15 * 60 * 1e3
          // 15 minutes
        });
      }
      /**
       * Create a cache for computed values
       */
      static createComputedCache(maxSize = 500) {
        return new LRUCache({
          maxSize,
          defaultTTL: 30 * 60 * 1e3
          // 30 minutes
        });
      }
    };
  }
});

// src/utils/performanceMonitor.ts
var PerformanceMonitor, performanceMonitor;
var init_performanceMonitor = __esm({
  "src/utils/performanceMonitor.ts"() {
    PerformanceMonitor = class {
      constructor() {
        __publicField(this, "metrics", []);
        __publicField(this, "aggregatedMetrics", /* @__PURE__ */ new Map());
        __publicField(this, "debugMode", false);
        __publicField(this, "MAX_METRICS_HISTORY", 1e3);
        __publicField(this, "CLEANUP_INTERVAL", 5 * 60 * 1e3);
        // 5 minutes
        __publicField(this, "cleanupTimer");
        this.startCleanupTimer();
      }
      /**
       * Set debug mode for detailed logging
       */
      setDebugMode(enabled) {
        this.debugMode = enabled;
      }
      /**
       * Record a performance metric
       */
      recordMetric(name, value, type2, tags) {
        const metric = {
          name,
          value,
          type: type2,
          timestamp: Date.now(),
          tags
        };
        this.metrics.push(metric);
        if (!this.aggregatedMetrics.has(name)) {
          this.aggregatedMetrics.set(name, []);
        }
        this.aggregatedMetrics.get(name).push(metric);
        if (this.metrics.length > this.MAX_METRICS_HISTORY) {
          this.cleanupOldMetrics();
        }
        if (this.debugMode) {
          console.log(`[PerformanceMonitor] ${name}: ${value} ${type2}`, tags);
        }
      }
      /**
       * Get current performance metrics summary
       */
      getMetrics() {
        const now = Date.now();
        const oneMinuteAgo = now - 60 * 1e3;
        const fiveMinutesAgo = now - 5 * 60 * 1e3;
        const cacheHits = this.getMetricSum("cache_hits", fiveMinutesAgo);
        const cacheMisses = this.getMetricSum("cache_misses", fiveMinutesAgo);
        const cacheHitRate = cacheHits + cacheMisses > 0 ? cacheHits / (cacheHits + cacheMisses) * 100 : 0;
        const responseTimes = this.getMetricValues("api_response_time", fiveMinutesAgo);
        const averageResponseTime = responseTimes.length > 0 ? responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : 0;
        const memoryMetrics = this.getMetricValues("memory_usage", fiveMinutesAgo);
        const memoryUsage = memoryMetrics.length > 0 ? memoryMetrics[memoryMetrics.length - 1] : 0;
        const totalRequests = this.getMetricSum("api_requests", fiveMinutesAgo);
        const errors = this.getMetricSum("api_errors", fiveMinutesAgo);
        const errorRate = totalRequests > 0 ? errors / totalRequests * 100 : 0;
        const recentRequests = this.getMetricSum("api_requests", oneMinuteAgo);
        const apiCallsPerMinute = recentRequests;
        const streamingLatencies = this.getMetricValues("streaming_latency", fiveMinutesAgo);
        const streamingLatency = streamingLatencies.length > 0 ? streamingLatencies.reduce((sum, latency) => sum + latency, 0) / streamingLatencies.length : 0;
        const poolHits = this.getMetricSum("object_pool_hits", fiveMinutesAgo);
        const poolMisses = this.getMetricSum("object_pool_misses", fiveMinutesAgo);
        const objectPoolEfficiency = poolHits + poolMisses > 0 ? poolHits / (poolHits + poolMisses) * 100 : 0;
        return {
          cacheHitRate,
          averageResponseTime,
          memoryUsage,
          totalRequests,
          errorRate,
          apiCallsPerMinute,
          streamingLatency,
          objectPoolEfficiency
        };
      }
      /**
       * Get metric values for a specific metric name since a timestamp
       */
      getMetricValues(name, since) {
        const metrics = this.aggregatedMetrics.get(name) || [];
        return metrics.filter((metric) => metric.timestamp >= since).map((metric) => metric.value);
      }
      /**
       * Get sum of metric values for a specific metric name since a timestamp
       */
      getMetricSum(name, since) {
        const values = this.getMetricValues(name, since);
        return values.reduce((sum, value) => sum + value, 0);
      }
      /**
       * Log current performance metrics to console
       */
      logMetrics() {
        const metrics = this.getMetrics();
        console.group("\u{1F680} Performance Metrics");
        console.log(`Cache Hit Rate: ${metrics.cacheHitRate.toFixed(2)}%`);
        console.log(`Average Response Time: ${metrics.averageResponseTime.toFixed(2)}ms`);
        console.log(`Memory Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`);
        console.log(`Total Requests (5min): ${metrics.totalRequests}`);
        console.log(`Error Rate: ${metrics.errorRate.toFixed(2)}%`);
        console.log(`API Calls/min: ${metrics.apiCallsPerMinute}`);
        console.log(`Streaming Latency: ${metrics.streamingLatency.toFixed(2)}ms`);
        console.log(`Object Pool Efficiency: ${metrics.objectPoolEfficiency.toFixed(2)}%`);
        console.groupEnd();
      }
      /**
       * Clear all metrics
       */
      clearMetrics() {
        this.metrics = [];
        this.aggregatedMetrics.clear();
        if (this.debugMode) {
          console.log("[PerformanceMonitor] All metrics cleared");
        }
      }
      /**
       * Start a performance timer
       */
      startTimer(name) {
        const startTime = performance.now();
        return () => {
          const duration = performance.now() - startTime;
          this.recordMetric(name, duration, "time");
        };
      }
      /**
       * Measure memory usage
       */
      measureMemory() {
        if (typeof performance !== "undefined" && "memory" in performance) {
          const memory = performance.memory;
          this.recordMetric("memory_usage", memory.usedJSHeapSize, "size");
          this.recordMetric("memory_total", memory.totalJSHeapSize, "size");
          this.recordMetric("memory_limit", memory.jsHeapSizeLimit, "size");
        }
      }
      /**
       * Record API request metrics
       */
      recordAPIRequest(success, responseTime, provider) {
        this.recordMetric("api_requests", 1, "count", { provider });
        this.recordMetric("api_response_time", responseTime, "time", { provider });
        if (success) {
          this.recordMetric("api_success", 1, "count", { provider });
        } else {
          this.recordMetric("api_errors", 1, "count", { provider });
        }
      }
      /**
       * Record cache metrics
       */
      recordCacheMetrics(hits, misses) {
        this.recordMetric("cache_hits", hits, "count");
        this.recordMetric("cache_misses", misses, "count");
      }
      /**
       * Record object pool metrics
       */
      recordObjectPoolMetrics(hits, misses) {
        this.recordMetric("object_pool_hits", hits, "count");
        this.recordMetric("object_pool_misses", misses, "count");
      }
      /**
       * Record streaming metrics
       */
      recordStreamingMetrics(latency, chunkSize) {
        this.recordMetric("streaming_latency", latency, "time");
        this.recordMetric("streaming_chunk_size", chunkSize, "size");
      }
      /**
       * Get performance report as string
       */
      getPerformanceReport() {
        const metrics = this.getMetrics();
        return `
Performance Report:
==================
Cache Hit Rate: ${metrics.cacheHitRate.toFixed(2)}%
Average Response Time: ${metrics.averageResponseTime.toFixed(2)}ms
Memory Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB
Total Requests (5min): ${metrics.totalRequests}
Error Rate: ${metrics.errorRate.toFixed(2)}%
API Calls/min: ${metrics.apiCallsPerMinute}
Streaming Latency: ${metrics.streamingLatency.toFixed(2)}ms
Object Pool Efficiency: ${metrics.objectPoolEfficiency.toFixed(2)}%
        `.trim();
      }
      /**
       * Start cleanup timer for old metrics
       */
      startCleanupTimer() {
        this.cleanupTimer = setInterval(() => {
          this.cleanupOldMetrics();
        }, this.CLEANUP_INTERVAL);
      }
      /**
       * Clean up old metrics to prevent memory leaks
       */
      cleanupOldMetrics() {
        const cutoffTime = Date.now() - 10 * 60 * 1e3;
        this.metrics = this.metrics.filter((metric) => metric.timestamp >= cutoffTime);
        for (const [name, metrics] of this.aggregatedMetrics.entries()) {
          const filteredMetrics = metrics.filter((metric) => metric.timestamp >= cutoffTime);
          if (filteredMetrics.length === 0) {
            this.aggregatedMetrics.delete(name);
          } else {
            this.aggregatedMetrics.set(name, filteredMetrics);
          }
        }
        if (this.debugMode) {
          console.log(`[PerformanceMonitor] Cleaned up old metrics. Current count: ${this.metrics.length}`);
        }
      }
      /**
       * Dispose of the performance monitor
       */
      dispose() {
        if (this.cleanupTimer) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = void 0;
        }
        this.clearMetrics();
      }
    };
    performanceMonitor = new PerformanceMonitor();
  }
});

// src/utils/errorHandler.ts
function handleChatError(error, operation, metadata) {
  errorHandler.handleError(error, {
    component: "ChatView",
    operation,
    metadata
  });
}
function handleAIDispatcherError(error, operation, metadata) {
  errorHandler.handleError(error, {
    component: "AIDispatcher",
    operation,
    metadata
  });
}
async function withErrorHandling(operation, component, operationName, options) {
  return errorHandler.handleAsync(operation, {
    component,
    operation: operationName
  }, options);
}
var import_obsidian14, _ErrorHandler, ErrorHandler, errorHandler;
var init_errorHandler = __esm({
  "src/utils/errorHandler.ts"() {
    import_obsidian14 = require("obsidian");
    init_logger();
    init_performanceMonitor();
    init_typeGuards();
    _ErrorHandler = class _ErrorHandler {
      constructor() {
        __publicField(this, "errorCounts", /* @__PURE__ */ new Map());
        __publicField(this, "lastErrors", /* @__PURE__ */ new Map());
        // Changed to array of timestamps
        __publicField(this, "MAX_ERROR_COUNT", 5);
        __publicField(this, "ERROR_RESET_TIME", 5 * 60 * 1e3);
      }
      // 5 minutes
      static getInstance() {
        if (!_ErrorHandler.instance) {
          _ErrorHandler.instance = new _ErrorHandler();
        }
        return _ErrorHandler.instance;
      }
      /**
       * Handle an error with consistent logging and user notification
       */
      handleError(error, context, options = {}) {
        const {
          showNotice: showNotice2 = true,
          logLevel = "error",
          fallbackMessage = "An unexpected error occurred",
          retryable = false
        } = options;
        const errorKey = `${context.component}:${context.operation}`;
        const errorMessage = this.extractErrorMessage(error);
        const enhancedError = this.enhanceError(error, context);
        this.trackError(errorKey, enhancedError);
        debugLog(true, logLevel, `[${context.component}] ${context.operation} failed:`, {
          error: errorMessage,
          context: context.metadata,
          retryable,
          errorCount: this.errorCounts.get(errorKey) || 0
        });
        if (showNotice2 && this.shouldShowNotice(errorKey)) {
          const userMessage = this.formatUserMessage(errorMessage, context, fallbackMessage);
          new import_obsidian14.Notice(userMessage, retryable ? 5e3 : 3e3);
        }
      }
      /**
       * Handle async operations with automatic error handling
       */
      async handleAsync(operation, context, options = {}) {
        try {
          return await operation();
        } catch (error) {
          this.handleError(error, context, options);
          return null;
        }
      }
      /**
       * Handle sync operations with automatic error handling
       */
      handleSync(operation, context, options = {}) {
        try {
          return operation();
        } catch (error) {
          this.handleError(error, context, options);
          return null;
        }
      }
      /**
       * Create a wrapped version of an async function with error handling
       */
      wrapAsync(fn, context, options = {}) {
        return async (...args) => {
          return this.handleAsync(() => fn(...args), context, options);
        };
      }
      /**
       * Create a wrapped version of a sync function with error handling
       */
      wrapSync(fn, context, options = {}) {
        return (...args) => {
          return this.handleSync(() => fn(...args), context, options);
        };
      }
      /**
       * Handle errors with automatic fallback provider selection
       */
      async handleWithFallback(error, context, currentProvider, availableProviders, retryFunction, options = {}) {
        const errorMessage = this.extractErrorMessage(error);
        performanceMonitor.recordMetric("provider_error", 1, "count", {
          provider: currentProvider,
          context: context.component
        });
        debugLog(true, "error", `[${context.component}] Provider ${currentProvider} failed: ${errorMessage}`);
        if (retryFunction && availableProviders.length > 0) {
          for (const fallbackProvider of availableProviders) {
            if (fallbackProvider !== currentProvider && isValidProviderName(fallbackProvider)) {
              try {
                debugLog(true, "info", `[${context.component}] Attempting fallback to provider: ${fallbackProvider}`);
                const result = await retryFunction(fallbackProvider);
                performanceMonitor.recordMetric("fallback_success", 1, "count", {
                  originalProvider: currentProvider,
                  fallbackProvider
                });
                new import_obsidian14.Notice(`Switched to ${fallbackProvider} due to ${currentProvider} error`, 3e3);
                return { success: true, result, fallbackProvider };
              } catch (fallbackError) {
                debugLog(true, "warn", `[${context.component}] Fallback provider ${fallbackProvider} also failed:`, fallbackError);
                performanceMonitor.recordMetric("fallback_failed", 1, "count", {
                  provider: fallbackProvider
                });
              }
            }
          }
        }
        const displayMessage = `All AI providers failed. Please check your configuration.`;
        if (options.showNotice !== false) {
          new import_obsidian14.Notice(displayMessage, 5e3);
        }
        return {
          success: false,
          message: errorMessage,
          userMessage: displayMessage
        };
      }
      /**
       * Handle errors with exponential backoff retry
       */
      async handleWithRetry(operation, context, maxRetries = 3, baseDelay = 1e3, options = {}) {
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            if (attempt > 0) {
              const delay = baseDelay * Math.pow(2, attempt - 1);
              debugLog(true, "info", `[${context.component}] Retry attempt ${attempt}/${maxRetries} after ${delay}ms`);
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
            const result = await operation();
            if (attempt > 0) {
              performanceMonitor.recordMetric("retry_success", 1, "count", {
                context: context.component,
                attempt: attempt.toString()
              });
              if (options.showNotice !== false) {
                new import_obsidian14.Notice(`Operation succeeded after ${attempt} retries`, 2e3);
              }
            }
            return result;
          } catch (error) {
            lastError = this.enhanceError(error, context);
            performanceMonitor.recordMetric("retry_attempt", 1, "count", {
              context: context.component,
              attempt: attempt.toString()
            });
            debugLog(true, "warn", `[${context.component}] Attempt ${attempt + 1}/${maxRetries + 1} failed:`, error);
            if (this.isNonRetryableError(lastError)) {
              debugLog(true, "info", `[${context.component}] Non-retryable error, stopping retries`);
              break;
            }
          }
        }
        performanceMonitor.recordMetric("retry_exhausted", 1, "count", { context: context.component });
        this.handleError(lastError, context, options);
        throw lastError;
      }
      /**
       * Check if an error should not be retried
       */
      isNonRetryableError(error) {
        const nonRetryablePatterns = [
          "invalid api key",
          "unauthorized",
          "forbidden",
          "not found",
          "bad request",
          "invalid request",
          "quota exceeded",
          "billing"
        ];
        const errorMessage = error.message.toLowerCase();
        return nonRetryablePatterns.some((pattern) => errorMessage.includes(pattern));
      }
      /**
       * Check if an error is retryable based on its type
       */
      isRetryableError(error) {
        const errorMessage = this.extractErrorMessage(error);
        const retryablePatterns = [
          /network/i,
          /timed out|timeout/i,
          /rate.?limit/i,
          /temporary/i,
          /unavailable/i,
          /ECONNRESET/,
          /ETIMEDOUT/,
          /ENOTFOUND/,
          /502/,
          /503/,
          /504/
        ];
        return retryablePatterns.some((pattern) => pattern.test(errorMessage));
      }
      /**
       * Get error statistics for monitoring
       */
      getErrorStats() {
        const stats = {};
        for (const [key, count] of this.errorCounts.entries()) {
          const errorInfo = this.lastErrors.get(key);
          stats[key] = {
            count,
            lastError: (errorInfo == null ? void 0 : errorInfo.error.message) || "Unknown",
            lastTimestamp: (errorInfo == null ? void 0 : errorInfo.timestamps[errorInfo.timestamps.length - 1]) || 0
            // Get the latest timestamp
          };
        }
        return stats;
      }
      /**
       * Reset error counts (useful for testing or manual reset)
       */
      resetErrorCounts() {
        this.errorCounts.clear();
        this.lastErrors.clear();
      }
      extractErrorMessage(error) {
        if (error instanceof Error) {
          return error.message;
        }
        if (typeof error === "string") {
          return error;
        }
        if (error && typeof error === "object" && "message" in error) {
          return String(error.message);
        }
        return "Unknown error";
      }
      enhanceError(error, context) {
        if (error instanceof Error) {
          error.context = context;
          return error;
        }
        const newError = new Error(this.extractErrorMessage(error));
        newError.context = context;
        newError.originalError = error;
        return newError;
      }
      trackError(errorKey, error) {
        const currentTimestamp = Date.now();
        const existingEntry = this.lastErrors.get(errorKey);
        if (existingEntry) {
          existingEntry.timestamps.push(currentTimestamp);
          existingEntry.error = error;
        } else {
          this.lastErrors.set(errorKey, {
            error,
            timestamps: [currentTimestamp]
          });
        }
        this.cleanupOldErrors();
      }
      shouldShowNotice(errorKey) {
        const count = this.errorCounts.get(errorKey) || 0;
        if (count > this.MAX_ERROR_COUNT) {
          return false;
        }
        return count <= this.MAX_ERROR_COUNT;
      }
      formatUserMessage(errorMessage, context, fallbackMessage) {
        let sanitizedMessage = this.sanitizeErrorMessage(errorMessage);
        sanitizedMessage = sanitizedMessage.replace(/\s+/g, " ").trim();
        if (sanitizedMessage.length > 100) {
          return `${context.component}: ${fallbackMessage}`;
        }
        return `${context.component}: ${sanitizedMessage}`;
      }
      sanitizeErrorMessage(message) {
        let normalized = message.replace(/([\w-]*token[\w-]*)/gi, "TOKEN").replace(/(api[_-]?key[s]?|apikey|api-key|key)/gi, "API_KEY").replace(/(password[s]?|pass)/gi, "PASSWORD");
        let sanitized = normalized.replace(/TOKEN\s*[:=]\s*[^\s,;]+/gi, "TOKEN_HIDDEN").replace(/API_KEY\s*[:=]\s*[^\s,;]+/gi, "API_KEY_HIDDEN").replace(/PASSWORD\s*[:=]\s*[^\s,;]+/gi, "PASSWORD_HIDDEN").replace(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, "IP_HIDDEN").replace(/https?:\/\/[^\s,;]+/g, "URL_HIDDEN");
        sanitized = sanitized.replace(/(?:[a-zA-Z]:)?(?:[\/\\](?:[\w\-. ]+))+[\/\\][\w\-. ]+\.\w+/g, "FILE_PATH_HIDDEN");
        sanitized = sanitized.replace(/at\s+[\w\-. ]+\s+\([^)]+\)/g, "STACK_TRACE_HIDDEN");
        sanitized = sanitized.replace(/at\s+[\w\-. ]+\s+<anonymous>/g, "STACK_TRACE_HIDDEN");
        sanitized = sanitized.replace(/\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, "UUID_HIDDEN");
        sanitized = sanitized.replace(/\b\d{10,}\b/g, "LARGE_NUMBER_HIDDEN");
        return sanitized;
      }
      cleanupOldErrors() {
        const now = Date.now();
        for (const [key, errorInfo] of this.lastErrors.entries()) {
          errorInfo.timestamps = errorInfo.timestamps.filter(
            (timestamp2) => now - timestamp2 <= this.ERROR_RESET_TIME
          );
          if (errorInfo.timestamps.length === 0) {
            this.errorCounts.delete(key);
            this.lastErrors.delete(key);
          } else {
            this.errorCounts.set(key, errorInfo.timestamps.length);
          }
        }
      }
    };
    __publicField(_ErrorHandler, "instance");
    ErrorHandler = _ErrorHandler;
    errorHandler = ErrorHandler.getInstance();
  }
});

// src/utils/asyncOptimizer.ts
var AsyncBatcher, ParallelExecutor, AsyncDebouncer, AsyncThrottler, AsyncOptimizerFactory;
var init_asyncOptimizer = __esm({
  "src/utils/asyncOptimizer.ts"() {
    AsyncBatcher = class {
      constructor(processor, options) {
        this.processor = processor;
        this.options = options;
        __publicField(this, "pendingItems", []);
        __publicField(this, "batchTimer", null);
        __publicField(this, "isProcessing", false);
      }
      /**
       * Add an item to the batch for processing
       */
      async add(input) {
        return new Promise((resolve, reject) => {
          this.pendingItems.push({
            input,
            resolve,
            reject,
            timestamp: Date.now()
          });
          this.scheduleBatch();
        });
      }
      /**
       * Force process the current batch immediately
       */
      async flush() {
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = null;
        }
        await this.processBatch();
      }
      /**
       * Get current batch size
       */
      getPendingCount() {
        return this.pendingItems.length;
      }
      scheduleBatch() {
        if (this.pendingItems.length >= this.options.batchSize) {
          this.processBatch();
          return;
        }
        if (!this.batchTimer && this.options.delayMs) {
          this.batchTimer = setTimeout(() => {
            this.batchTimer = null;
            this.processBatch();
          }, this.options.delayMs);
        }
        if (this.options.maxWaitMs) {
          const oldestItem = this.pendingItems[0];
          if (oldestItem && Date.now() - oldestItem.timestamp > this.options.maxWaitMs) {
            this.processBatch();
          }
        }
      }
      async processBatch() {
        if (this.isProcessing || this.pendingItems.length === 0) {
          return;
        }
        this.isProcessing = true;
        const currentBatch = this.pendingItems.splice(0, this.options.batchSize);
        try {
          const inputs = currentBatch.map((item) => item.input);
          const outputs = await this.processor(inputs);
          currentBatch.forEach((item, index) => {
            if (index < outputs.length) {
              item.resolve(outputs[index]);
            } else {
              item.reject(new Error("Batch processing failed: insufficient outputs"));
            }
          });
        } catch (error) {
          currentBatch.forEach((item) => {
            item.reject(error instanceof Error ? error : new Error(String(error)));
          });
        } finally {
          this.isProcessing = false;
          if (this.pendingItems.length > 0) {
            this.scheduleBatch();
          }
        }
      }
    };
    ParallelExecutor = class {
      constructor() {
        __publicField(this, "activePromises", /* @__PURE__ */ new Set());
      }
      /**
       * Execute tasks in parallel with concurrency limit
       */
      async executeParallel(tasks, options) {
        const results = new Array(tasks.length);
        const errors = [];
        let completedCount = 0;
        return new Promise((resolve, reject) => {
          const executeTask = async (taskIndex, retryCount = 0) => {
            if (taskIndex >= tasks.length) return;
            const task = tasks[taskIndex];
            const promise = this.executeWithRetry(task, options, retryCount);
            this.activePromises.add(promise);
            try {
              const result = await promise;
              results[taskIndex] = result;
              completedCount++;
              if (completedCount === tasks.length) {
                if (errors.length > 0) {
                  reject(new AggregateError(errors, "Some tasks failed"));
                } else {
                  resolve(results);
                }
              }
            } catch (error) {
              errors.push(error instanceof Error ? error : new Error(String(error)));
              completedCount++;
              if (completedCount === tasks.length) {
                reject(new AggregateError(errors, "Some tasks failed"));
              }
            } finally {
              this.activePromises.delete(promise);
              const nextTaskIndex = taskIndex + options.concurrency;
              if (nextTaskIndex < tasks.length) {
                executeTask(nextTaskIndex);
              }
            }
          };
          const initialTasks = Math.min(options.concurrency, tasks.length);
          for (let i = 0; i < initialTasks; i++) {
            executeTask(i);
          }
        });
      }
      /**
       * Execute tasks in batches
       */
      async executeBatched(tasks, batchSize, delayBetweenBatches = 0) {
        const results = [];
        for (let i = 0; i < tasks.length; i += batchSize) {
          const batch = tasks.slice(i, i + batchSize);
          const batchResults = await Promise.allSettled(
            batch.map((task) => task())
          );
          for (const result of batchResults) {
            if (result.status === "fulfilled") {
              results.push(result.value);
            } else {
              throw result.reason;
            }
          }
          if (delayBetweenBatches > 0 && i + batchSize < tasks.length) {
            await new Promise((resolve) => setTimeout(resolve, delayBetweenBatches));
          }
        }
        return results;
      }
      /**
       * Get count of currently active promises
       */
      getActiveCount() {
        return this.activePromises.size;
      }
      /**
       * Cancel all active promises (if they support cancellation)
       */
      cancelAll() {
        this.activePromises.clear();
      }
      async executeWithRetry(task, options, retryCount) {
        try {
          return await task();
        } catch (error) {
          const maxRetries = options.retryAttempts || 0;
          if (retryCount < maxRetries) {
            const delay = options.retryDelayMs || 1e3;
            await new Promise((resolve) => setTimeout(resolve, delay * Math.pow(2, retryCount)));
            return this.executeWithRetry(task, options, retryCount + 1);
          }
          throw error;
        }
      }
    };
    AsyncDebouncer = class {
      constructor(delayMs) {
        this.delayMs = delayMs;
        __publicField(this, "timeoutId", null);
        __publicField(this, "lastPromise", null);
      }
      /**
       * Debounce an async operation
       */
      async debounce(operation) {
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
        }
        return new Promise((resolve, reject) => {
          this.timeoutId = setTimeout(async () => {
            try {
              this.lastPromise = operation();
              const result = await this.lastPromise;
              resolve(result);
            } catch (error) {
              reject(error);
            } finally {
              this.timeoutId = null;
              this.lastPromise = null;
            }
          }, this.delayMs);
        });
      }
      /**
       * Cancel pending debounced operation
       */
      cancel() {
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
        }
      }
      /**
       * Check if operation is pending
       */
      isPending() {
        return this.timeoutId !== null;
      }
    };
    AsyncThrottler = class {
      constructor(intervalMs) {
        this.intervalMs = intervalMs;
        __publicField(this, "lastExecution", 0);
        __publicField(this, "pendingPromise", null);
      }
      /**
       * Throttle an async operation
       */
      async throttle(operation) {
        const now = Date.now();
        const timeSinceLastExecution = now - this.lastExecution;
        if (timeSinceLastExecution >= this.intervalMs) {
          this.lastExecution = now;
          this.pendingPromise = operation();
          return this.pendingPromise;
        }
        if (this.pendingPromise) {
          return this.pendingPromise;
        }
        const delay = this.intervalMs - timeSinceLastExecution;
        return new Promise((resolve, reject) => {
          setTimeout(async () => {
            try {
              this.lastExecution = Date.now();
              this.pendingPromise = operation();
              const result = await this.pendingPromise;
              resolve(result);
            } catch (error) {
              reject(error);
            } finally {
              this.pendingPromise = null;
            }
          }, delay);
        });
      }
    };
    AsyncOptimizerFactory = class {
      /**
       * Create a batcher for DOM operations
       */
      static createDOMBatcher(processor) {
        return new AsyncBatcher(processor, {
          batchSize: 10,
          delayMs: 16,
          // ~60fps
          maxWaitMs: 100
        });
      }
      /**
       * Create a batcher for API requests
       */
      static createAPIBatcher(processor) {
        return new AsyncBatcher(processor, {
          batchSize: 5,
          delayMs: 50,
          maxWaitMs: 500
        });
      }
      /**
       * Create a parallel executor for I/O operations
       */
      static createIOExecutor() {
        return new ParallelExecutor();
      }
      /**
       * Create a debouncer for user input
       */
      static createInputDebouncer() {
        return new AsyncDebouncer(300);
      }
      /**
       * Create a throttler for API calls
       */
      static createAPIThrottler() {
        return new AsyncThrottler(1e3);
      }
    };
  }
});

// src/utils/APICircuitBreaker.ts
var _APICircuitBreaker, APICircuitBreaker, apiCircuitBreaker;
var init_APICircuitBreaker = __esm({
  "src/utils/APICircuitBreaker.ts"() {
    init_logger();
    init_performanceMonitor();
    _APICircuitBreaker = class _APICircuitBreaker {
      constructor() {
        __publicField(this, "breakers", /* @__PURE__ */ new Map());
        __publicField(this, "configs", /* @__PURE__ */ new Map());
        __publicField(this, "debugMode", false);
        __publicField(this, "DEFAULT_CONFIG", {
          failureThreshold: 5,
          timeout: 3e4,
          // 30 seconds
          halfOpenMaxCalls: 3,
          monitoringWindowMs: 5 * 60 * 1e3,
          // 5 minutes
          exponentialBackoff: true,
          baseDelayMs: 1e3,
          maxDelayMs: 6e4,
          jitterFactor: 0.1
        });
        setInterval(() => this.cleanupOldFailures(), 6e4);
      }
      static getInstance() {
        if (!_APICircuitBreaker.instance) {
          _APICircuitBreaker.instance = new _APICircuitBreaker();
        }
        return _APICircuitBreaker.instance;
      }
      /**
       * Set debug mode for detailed logging
       */
      setDebugMode(enabled) {
        this.debugMode = enabled;
      }
      /**
       * Configure circuit breaker for specific provider
       */
      configure(provider, config) {
        this.configs.set(provider, { ...this.DEFAULT_CONFIG, ...config });
        this.log(`Configured circuit breaker for ${provider}`, config);
      }
      /**
       * Execute operation with circuit breaker protection
       */
      async execute(provider, operation) {
        const state = this.getOrCreateState(provider);
        const config = this.getConfig(provider);
        if (this.isOpen(provider)) {
          const waitTime = state.nextRetryTime - Date.now();
          if (waitTime > 0) {
            performanceMonitor.recordMetric("circuit_breaker_blocked", 1, "count", { provider });
            throw new Error(`Circuit breaker is open for ${provider}. Retry in ${Math.ceil(waitTime / 1e3)}s`);
          } else {
            this.transitionToHalfOpen(provider);
          }
        }
        const startTime = Date.now();
        try {
          const result = await operation();
          this.onSuccess(provider, Date.now() - startTime);
          return result;
        } catch (error) {
          this.onFailure(provider, error, Date.now() - startTime);
          throw error;
        }
      }
      /**
       * Check if circuit breaker is open for provider
       */
      isOpen(provider) {
        const state = this.getOrCreateState(provider);
        return state.state === "OPEN" || state.state === "HALF_OPEN" && state.halfOpenCalls >= this.getConfig(provider).halfOpenMaxCalls;
      }
      /**
       * Force reset circuit breaker
       */
      reset(provider) {
        const state = this.getOrCreateState(provider);
        state.state = "CLOSED";
        state.failureCount = 0;
        state.successCount = 0;
        state.halfOpenCalls = 0;
        state.recentFailures = [];
        state.nextRetryTime = 0;
        this.log(`Circuit breaker reset for ${provider}`);
        performanceMonitor.recordMetric("circuit_breaker_reset", 1, "count", { provider });
      }
      /**
       * Get metrics for provider
       */
      getMetrics(provider) {
        const state = this.getOrCreateState(provider);
        const config = this.getConfig(provider);
        const now = Date.now();
        const windowStart = now - config.monitoringWindowMs;
        const recentFailures = state.recentFailures.filter((time) => time > windowStart);
        const totalCalls = state.successCount + state.failureCount;
        const failureRate = totalCalls > 0 ? recentFailures.length / totalCalls : 0;
        return {
          state: state.state,
          failureCount: state.failureCount,
          successCount: state.successCount,
          totalCalls,
          failureRate,
          uptime: state.lastFailureTime > 0 ? now - state.lastFailureTime : now,
          lastFailureTime: state.lastFailureTime,
          nextRetryTime: state.nextRetryTime
        };
      }
      /**
       * Get all provider metrics
       */
      getAllMetrics() {
        const metrics = {};
        for (const provider of this.breakers.keys()) {
          metrics[provider] = this.getMetrics(provider);
        }
        return metrics;
      }
      /**
       * Handle successful operation
       */
      onSuccess(provider, duration) {
        const state = this.getOrCreateState(provider);
        const config = this.getConfig(provider);
        state.successCount++;
        if (state.state === "HALF_OPEN") {
          state.halfOpenCalls++;
          if (state.halfOpenCalls >= config.halfOpenMaxCalls) {
            this.transitionToClosed(provider);
          }
        } else if (state.state === "CLOSED") {
          state.failureCount = Math.max(0, state.failureCount - 1);
        }
        performanceMonitor.recordMetric("circuit_breaker_success", 1, "count", { provider });
        performanceMonitor.recordMetric("api_call_duration", duration, "time", { provider });
        this.log(`Success for ${provider} (${duration}ms) - State: ${state.state}`);
      }
      /**
       * Handle failed operation
       */
      onFailure(provider, error, duration) {
        const state = this.getOrCreateState(provider);
        const config = this.getConfig(provider);
        const now = Date.now();
        state.failureCount++;
        state.lastFailureTime = now;
        state.recentFailures.push(now);
        const windowStart = now - config.monitoringWindowMs;
        state.recentFailures = state.recentFailures.filter((time) => time > windowStart);
        performanceMonitor.recordMetric("circuit_breaker_failure", 1, "count", { provider });
        performanceMonitor.recordMetric("api_call_duration", duration, "time", { provider, status: "failed" });
        if (state.state === "CLOSED" && state.recentFailures.length >= config.failureThreshold) {
          this.transitionToOpen(provider);
        } else if (state.state === "HALF_OPEN") {
          this.transitionToOpen(provider);
        }
        this.log(`Failure for ${provider} (${duration}ms) - State: ${state.state}, Recent failures: ${state.recentFailures.length}`);
      }
      /**
       * Transition to OPEN state
       */
      transitionToOpen(provider) {
        const state = this.getOrCreateState(provider);
        const config = this.getConfig(provider);
        state.state = "OPEN";
        state.halfOpenCalls = 0;
        let timeout = config.timeout;
        if (config.exponentialBackoff) {
          const exponentialDelay = Math.min(
            config.baseDelayMs * Math.pow(2, Math.min(state.failureCount - 1, 10)),
            config.maxDelayMs
          );
          timeout = Math.max(timeout, exponentialDelay);
        }
        const jitter = timeout * config.jitterFactor * Math.random();
        state.nextRetryTime = Date.now() + timeout + jitter;
        performanceMonitor.recordMetric("circuit_breaker_opened", 1, "count", { provider });
        this.log(`Circuit breaker OPENED for ${provider}. Next retry: ${new Date(state.nextRetryTime).toISOString()}`);
      }
      /**
       * Transition to HALF_OPEN state
       */
      transitionToHalfOpen(provider) {
        const state = this.getOrCreateState(provider);
        state.state = "HALF_OPEN";
        state.halfOpenCalls = 0;
        performanceMonitor.recordMetric("circuit_breaker_half_opened", 1, "count", { provider });
        this.log(`Circuit breaker HALF_OPEN for ${provider}`);
      }
      /**
       * Transition to CLOSED state
       */
      transitionToClosed(provider) {
        const state = this.getOrCreateState(provider);
        state.state = "CLOSED";
        state.failureCount = 0;
        state.halfOpenCalls = 0;
        state.nextRetryTime = 0;
        performanceMonitor.recordMetric("circuit_breaker_closed", 1, "count", { provider });
        this.log(`Circuit breaker CLOSED for ${provider}`);
      }
      /**
       * Get or create state for provider
       */
      getOrCreateState(provider) {
        if (!this.breakers.has(provider)) {
          this.breakers.set(provider, {
            state: "CLOSED",
            failureCount: 0,
            successCount: 0,
            lastFailureTime: 0,
            nextRetryTime: 0,
            halfOpenCalls: 0,
            recentFailures: []
          });
        }
        return this.breakers.get(provider);
      }
      /**
       * Get configuration for provider
       */
      getConfig(provider) {
        return this.configs.get(provider) || this.DEFAULT_CONFIG;
      }
      /**
       * Clean up old failure records
       */
      cleanupOldFailures() {
        const now = Date.now();
        for (const [provider, state] of this.breakers.entries()) {
          const config = this.getConfig(provider);
          const windowStart = now - config.monitoringWindowMs;
          const oldLength = state.recentFailures.length;
          state.recentFailures = state.recentFailures.filter((time) => time > windowStart);
          if (oldLength !== state.recentFailures.length) {
            this.log(`Cleaned up ${oldLength - state.recentFailures.length} old failures for ${provider}`);
          }
        }
      }
      /**
       * Log debug messages
       */
      log(message, data) {
        if (this.debugMode) {
          debugLog(true, "info", `[APICircuitBreaker] ${message}`, data);
        }
      }
    };
    __publicField(_APICircuitBreaker, "instance");
    APICircuitBreaker = _APICircuitBreaker;
    apiCircuitBreaker = APICircuitBreaker.getInstance();
  }
});

// src/utils/validationUtils.ts
function isValidOpenAIApiKey(key) {
  if (typeof key !== "string") return false;
  if (key.length < MIN_API_KEY_LENGTH || key.length > MAX_API_KEY_LENGTH) return false;
  return key.startsWith("sk-") && key.length >= 40;
}
function isValidAnthropicApiKey(key) {
  if (typeof key !== "string") return false;
  if (key.length < MIN_API_KEY_LENGTH || key.length > MAX_API_KEY_LENGTH) return false;
  return key.startsWith("sk-ant-") && key.length >= 40;
}
function isValidGoogleApiKey(key) {
  if (typeof key !== "string") return false;
  if (key.length < MIN_API_KEY_LENGTH || key.length > MAX_API_KEY_LENGTH) return false;
  return key.length >= 30 && /^[a-zA-Z0-9_-]+$/.test(key);
}
function isValidUrl(url) {
  if (typeof url !== "string") return false;
  if (url.length > 2048) return false;
  try {
    const parsedUrl = new URL(url);
    return ["http:", "https:"].includes(parsedUrl.protocol);
  } catch (e) {
    return false;
  }
}
function sanitizeInput(input) {
  if (typeof input !== "string") return "";
  return input.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/\x00/g, "").trim();
}
var MAX_API_KEY_LENGTH, MIN_API_KEY_LENGTH;
var init_validationUtils = __esm({
  "src/utils/validationUtils.ts"() {
    MAX_API_KEY_LENGTH = 200;
    MIN_API_KEY_LENGTH = 20;
  }
});

// src/utils/aiDispatcher.ts
var aiDispatcher_exports = {};
__export(aiDispatcher_exports, {
  AIDispatcher: () => AIDispatcher
});
var AIDispatcher;
var init_aiDispatcher = __esm({
  "src/utils/aiDispatcher.ts"() {
    init_providers();
    init_saveAICalls();
    init_logger();
    init_objectPool();
    init_lruCache();
    init_errorHandler();
    init_asyncOptimizer();
    init_performanceMonitor();
    init_APICircuitBreaker();
    init_typeGuards();
    init_validationUtils();
    AIDispatcher = class {
      // Maximum cache entries
      constructor(vault, plugin) {
        this.vault = vault;
        this.plugin = plugin;
        // Priority 2 Optimization: LRU Cache with size limits
        __publicField(this, "cache");
        __publicField(this, "modelCache");
        __publicField(this, "providerCache");
        __publicField(this, "metrics", {
          totalRequests: 0,
          successfulRequests: 0,
          failedRequests: 0,
          totalTokens: 0,
          totalCost: 0,
          averageResponseTime: 0,
          requestsByProvider: {},
          errorsByProvider: {},
          cacheHits: 0,
          cacheMisses: 0,
          deduplicatedRequests: 0
        });
        __publicField(this, "circuitBreakers", /* @__PURE__ */ new Map());
        __publicField(this, "requestQueue", []);
        __publicField(this, "activeStreams", /* @__PURE__ */ new Map());
        __publicField(this, "rateLimits", /* @__PURE__ */ new Map());
        __publicField(this, "isProcessingQueue", false);
        // Priority 1 Optimization: Request deduplication with LRU
        __publicField(this, "pendingRequests");
        __publicField(this, "DEDUP_TTL", 30 * 1e3);
        // 30 seconds
        // Memory optimization: Object pools
        __publicField(this, "messagePool");
        __publicField(this, "arrayManager");
        // Priority 2 Optimization: Async optimization
        __publicField(this, "requestBatcher");
        __publicField(this, "parallelExecutor");
        // Configuration
        __publicField(this, "CACHE_TTL", 5 * 60 * 1e3);
        // 5 minutes
        __publicField(this, "CIRCUIT_BREAKER_THRESHOLD", 5);
        __publicField(this, "CIRCUIT_BREAKER_TIMEOUT", 30 * 1e3);
        // 30 seconds
        __publicField(this, "RATE_LIMIT_WINDOW", 60 * 1e3);
        // 1 minute
        __publicField(this, "MAX_QUEUE_SIZE", 100);
        __publicField(this, "CACHE_MAX_SIZE", 200);
        var _a2, _b;
        performanceMonitor.setDebugMode((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false);
        apiCircuitBreaker.setDebugMode((_b = this.plugin.settings.debugMode) != null ? _b : false);
        apiCircuitBreaker.configure("openai", {
          failureThreshold: 5,
          timeout: 3e4,
          halfOpenMaxCalls: 3,
          exponentialBackoff: true,
          baseDelayMs: 2e3,
          maxDelayMs: 12e4,
          jitterFactor: 0.15
        });
        apiCircuitBreaker.configure("anthropic", {
          failureThreshold: 3,
          timeout: 45e3,
          halfOpenMaxCalls: 2,
          exponentialBackoff: true,
          baseDelayMs: 3e3,
          maxDelayMs: 18e4,
          jitterFactor: 0.2
        });
        apiCircuitBreaker.configure("gemini", {
          failureThreshold: 4,
          timeout: 25e3,
          halfOpenMaxCalls: 3,
          exponentialBackoff: true,
          baseDelayMs: 1500,
          maxDelayMs: 9e4,
          jitterFactor: 0.1
        });
        apiCircuitBreaker.configure("ollama", {
          failureThreshold: 2,
          timeout: 15e3,
          halfOpenMaxCalls: 1,
          exponentialBackoff: false,
          // Local provider, faster recovery
          baseDelayMs: 1e3,
          maxDelayMs: 3e4,
          jitterFactor: 0.05
        });
        ["openai", "anthropic", "gemini", "ollama"].forEach((provider) => {
          this.circuitBreakers.set(provider, {
            isOpen: false,
            failureCount: 0,
            lastFailureTime: 0,
            nextRetryTime: 0
          });
        });
        this.cache = LRUCacheFactory.createResponseCache(this.CACHE_MAX_SIZE);
        this.modelCache = new LRUCache({
          maxSize: 10,
          defaultTTL: 30 * 60 * 1e3
          // 30 minutes
        });
        this.providerCache = new LRUCache({
          maxSize: 20,
          defaultTTL: 15 * 60 * 1e3
          // 15 minutes
        });
        this.pendingRequests = new LRUCache({
          maxSize: 100,
          defaultTTL: this.DEDUP_TTL
        });
        this.messagePool = MessageContextPool.getInstance();
        this.arrayManager = PreAllocatedArrays.getInstance();
        this.requestBatcher = AsyncOptimizerFactory.createAPIBatcher(
          async (requests) => {
            const results = [];
            for (const request of requests) {
              try {
                await this.executeWithRetry(
                  request.messages,
                  request.options,
                  this.determineProvider(request.providerOverride),
                  this.generateCacheKey(request.messages, request.options, request.providerOverride)
                );
                results.push();
              } catch (error) {
                handleAIDispatcherError(error, "batchedRequest", { requestCount: requests.length });
                results.push();
              }
            }
            return results;
          }
        );
        this.parallelExecutor = AsyncOptimizerFactory.createIOExecutor();
        this.startQueueProcessor();
        this.startPendingRequestCleanup();
      }
      /**
       * Priority 1 Optimization: Clean up expired pending requests
       */
      startPendingRequestCleanup() {
        setInterval(() => {
          this.pendingRequests.cleanup();
        }, this.DEDUP_TTL);
      }
      /**
       * Makes an AI completion request through the appropriate provider.
       * Automatically saves the request and response to the vault.
       * Includes caching, rate limiting, retry logic, and validation.
       * 
       * @param messages - The conversation messages to send
       * @param options - Completion options (temperature, etc.)
       * @param providerOverride - Optional specific provider to use instead of default
       * @param priority - Request priority (higher = processed first)
       * @returns Promise that resolves when the completion is finished
       */
      getCompletion(messages, options, providerOverride, priority = 0) {
        return (async () => {
          var _a2, _b, _c;
          this.validateRequest(messages, options);
          const cacheKey = this.generateCacheKey(messages, options, providerOverride);
          const existingRequest = this.pendingRequests.get(cacheKey);
          if (existingRequest) {
            this.metrics.deduplicatedRequests++;
            performanceMonitor.recordMetric("deduplicated_requests", 1, "count");
            debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Deduplicating request", { key: cacheKey });
            return existingRequest;
          }
          const cachedResponse = this.cache.get(cacheKey);
          if (cachedResponse && options.streamCallback) {
            this.metrics.cacheHits++;
            performanceMonitor.recordMetric("cache_hits", 1, "count");
            debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "info", "[AIDispatcher] Cache hit", { key: cacheKey });
            options.streamCallback(cachedResponse);
            return Promise.resolve();
          } else {
            this.metrics.cacheMisses++;
            performanceMonitor.recordMetric("cache_misses", 1, "count");
            debugLog((_c = this.plugin.settings.debugMode) != null ? _c : false, "info", "[AIDispatcher] Cache miss", { key: cacheKey });
          }
          const providerName = this.determineProvider(providerOverride);
          if (this.isCircuitBreakerOpen(providerName)) {
            throw new Error(`Provider ${providerName} is temporarily unavailable (circuit breaker open)`);
          }
          if (this.isRateLimited(providerName)) {
            return this.queueRequest(messages, options, providerOverride, priority);
          }
          const requestPromise = this.executeWithRetry(messages, options, providerName, cacheKey);
          this.pendingRequests.set(cacheKey, requestPromise);
          requestPromise.finally(() => {
            this.pendingRequests.delete(cacheKey);
          });
          return requestPromise;
        })();
      }
      /**
       * Validates request format and content with enhanced security using comprehensive type guards.
       */
      validateRequest(messages, options) {
        var _a2;
        if (!Array.isArray(messages) || messages.length === 0) {
          throw new Error("Messages array is required and cannot be empty");
        }
        for (let i = 0; i < messages.length; i++) {
          const message = messages[i];
          if (!message || typeof message !== "object") {
            throw new Error(`Invalid message at index ${i}: Message must be an object`);
          }
          if (!message.role || typeof message.role !== "string") {
            throw new Error(`Invalid message at index ${i}: Message role is required and must be a string`);
          }
          if (!message.content || typeof message.content !== "string") {
            throw new Error(`Invalid message at index ${i}: Message content is required and must be a string`);
          }
          if (!["system", "user", "assistant"].includes(message.role)) {
            throw new Error(`Invalid message role at index ${i}: ${message.role}. Must be 'system', 'user', or 'assistant'`);
          }
        }
        if (options.temperature !== void 0) {
          if (typeof options.temperature !== "number" || isNaN(options.temperature)) {
            throw new Error("Temperature must be a valid number");
          }
          if (options.temperature < 0 || options.temperature > 2) {
            throw new Error("Temperature must be between 0 and 2");
          }
        }
        if (options.streamCallback !== void 0 && typeof options.streamCallback !== "function") {
          throw new Error("Stream callback must be a function");
        }
        this.sanitizeMessages(messages);
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "debug", "[AIDispatcher] Request validation completed successfully", {
          messageCount: messages.length
        });
      }
      /**
       * Sanitizes message content for safety using enhanced validation.
       */
      sanitizeMessages(messages) {
        var _a2, _b;
        for (const message of messages) {
          try {
            message.content = sanitizeInput(message.content);
            debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "debug", "[AIDispatcher] Message content sanitized successfully");
          } catch (error) {
            debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "warn", "[AIDispatcher] Message content sanitization failed:", error);
            message.content = message.content.trim();
            message.content = message.content.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
          }
        }
      }
      /**
       * Generates a cache key for the request.
       * Uses base64 encoding that supports Unicode (so it won't throw on non-Latin1 chars).
       * Optimized to use object pooling for reduced memory allocations.
       */
      generateCacheKey(messages, options, providerOverride) {
        const messageArray = this.arrayManager.getArray(messages.length);
        try {
          let btoaUnicode = function(str2) {
            return btoa(encodeURIComponent(str2).replace(/%([0-9A-F]{2})/g, function(match, p1) {
              return String.fromCharCode(parseInt(p1, 16));
            }));
          };
          for (let i = 0; i < messages.length; i++) {
            const pooledMsg = this.messagePool.acquireMessage();
            pooledMsg.role = messages[i].role;
            pooledMsg.content = messages[i].content;
            messageArray[i] = pooledMsg;
          }
          const key = JSON.stringify({
            messages: messageArray,
            temperature: options.temperature,
            provider: providerOverride || this.plugin.settings.selectedModel || this.plugin.settings.provider
          });
          return btoaUnicode(key).substring(0, 32);
        } finally {
          for (let i = 0; i < messageArray.length; i++) {
            if (messageArray[i]) {
              this.messagePool.releaseMessage(messageArray[i]);
            }
          }
          this.arrayManager.returnArray(messageArray);
        }
      }
      /**
       * Gets response from cache if available and not expired.
       */
      getFromCache(cacheKey) {
        var _a2;
        const response = this.cache.get(cacheKey);
        if (response) {
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Cache hit", { key: cacheKey });
        }
        return response || null;
      }
      /**
       * Stores response in cache.
       */
      setCache(cacheKey, response, ttl = this.CACHE_TTL) {
        var _a2;
        this.cache.set(cacheKey, response, ttl);
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Response cached", { key: cacheKey });
      }
      /**
       * Determines which provider to use.
       */
      determineProvider(providerOverride) {
        if (providerOverride) return providerOverride;
        if (this.plugin.settings.selectedModel) {
          return this.plugin.settings.selectedModel.split(":")[0];
        }
        return this.plugin.settings.provider;
      }
      /**
       * Checks if circuit breaker is open for provider.
       */
      isCircuitBreakerOpen(providerName) {
        var _a2;
        const breaker = this.circuitBreakers.get(providerName);
        if (!breaker) return false;
        if (breaker.isOpen) {
          if (Date.now() > breaker.nextRetryTime) {
            breaker.isOpen = false;
            breaker.failureCount = 0;
            debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Circuit breaker reset", { provider: providerName });
          }
        }
        return breaker.isOpen;
      }
      /**
       * Records failure for circuit breaker.
       */
      recordFailure(providerName) {
        var _a2;
        const breaker = this.circuitBreakers.get(providerName);
        if (!breaker) return;
        breaker.failureCount++;
        breaker.lastFailureTime = Date.now();
        if (breaker.failureCount >= this.CIRCUIT_BREAKER_THRESHOLD) {
          breaker.isOpen = true;
          breaker.nextRetryTime = Date.now() + this.CIRCUIT_BREAKER_TIMEOUT;
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "warn", "[AIDispatcher] Circuit breaker opened", {
            provider: providerName,
            failures: breaker.failureCount
          });
        }
      }
      /**
       * Records success for circuit breaker.
       */
      recordSuccess(providerName) {
        const breaker = this.circuitBreakers.get(providerName);
        if (!breaker) return;
        if (breaker.isOpen && Date.now() > breaker.nextRetryTime) {
          breaker.isOpen = false;
          breaker.failureCount = 0;
        } else {
          breaker.failureCount = Math.max(0, breaker.failureCount - 1);
        }
      }
      /**
       * Checks if provider is rate limited.
       */
      isRateLimited(providerName) {
        const limit = this.rateLimits.get(providerName);
        if (!limit) return false;
        if (Date.now() > limit.resetTime) {
          this.rateLimits.delete(providerName);
          return false;
        }
        const maxRequests = this.getProviderRateLimit(providerName);
        return limit.requests >= maxRequests;
      }
      /**
       * Gets rate limit for provider.
       */
      getProviderRateLimit(providerName) {
        switch (providerName) {
          case "openai":
            return 60;
          // 60 requests per minute
          case "anthropic":
            return 50;
          case "gemini":
            return 60;
          case "ollama":
            return 100;
          // Local, more generous
          default:
            return 60;
        }
      }
      /**
       * Records request for rate limiting.
       */
      recordRequest(providerName) {
        const limit = this.rateLimits.get(providerName) || { requests: 0, resetTime: Date.now() + this.RATE_LIMIT_WINDOW };
        limit.requests++;
        this.rateLimits.set(providerName, limit);
      }
      /**
       * Queues request for later processing.
       */
      async queueRequest(messages, options, providerOverride, priority = 0) {
        if (this.requestQueue.length >= this.MAX_QUEUE_SIZE) {
          throw new Error("Request queue is full. Please try again later.");
        }
        return new Promise((resolve, reject) => {
          var _a2;
          const request = {
            id: Math.random().toString(36).substr(2, 9),
            messages,
            options,
            providerType: providerOverride,
            resolve,
            reject,
            priority,
            timestamp: Date.now()
          };
          this.requestQueue.push(request);
          this.requestQueue.sort((a, b) => b.priority - a.priority);
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Request queued", {
            id: request.id,
            queueSize: this.requestQueue.length
          });
        });
      }
      /**
       * Starts the queue processor.
       */
      startQueueProcessor() {
        setInterval(() => {
          if (!this.isProcessingQueue && this.requestQueue.length > 0) {
            this.processQueue();
          }
        }, 1e3);
      }
      /**
       * Processes queued requests.
       */
      async processQueue() {
        if (this.isProcessingQueue) return;
        this.isProcessingQueue = true;
        try {
          while (this.requestQueue.length > 0) {
            const request = this.requestQueue.shift();
            const providerName = this.determineProvider(request.providerType);
            if (!this.isRateLimited(providerName) && !this.isCircuitBreakerOpen(providerName)) {
              try {
                await this.executeRequest(request);
              } catch (error) {
                request.reject(error);
              }
            } else {
              this.requestQueue.unshift(request);
              break;
            }
          }
        } finally {
          this.isProcessingQueue = false;
        }
      }
      /**
       * Executes a queued request.
       */
      async executeRequest(request) {
        const providerName = this.determineProvider(request.providerType);
        const cacheKey = this.generateCacheKey(request.messages, request.options, request.providerType);
        try {
          await this.executeWithRetry(request.messages, request.options, providerName, cacheKey);
          request.resolve();
        } catch (error) {
          request.reject(error);
        }
      }
      async executeWithRetry(messages, options, providerName, cacheKey, retryCount = 0) {
        var _a2, _b, _c;
        const startTime = Date.now();
        let provider;
        let fullResponse = "";
        let abortController;
        try {
          await apiCircuitBreaker.execute(providerName, async () => {
            var _a3, _b2, _c2;
            if (this.plugin.settings.selectedModel) {
              provider = createProviderFromUnifiedModel(this.plugin.settings, this.plugin.settings.selectedModel);
            } else {
              if (!isValidProviderName(providerName)) {
                throw new Error(`Invalid provider name: ${providerName}`);
              }
              const tempSettings = { ...this.plugin.settings, provider: providerName };
              provider = createProvider(tempSettings);
            }
            this.recordRequest(providerName);
            const streamId = Math.random().toString(36).substr(2, 9);
            abortController = new AbortController();
            this.activeStreams.set(streamId, abortController);
            const requestData = {
              provider: providerName,
              model: this.plugin.settings.selectedModel || "default",
              messages,
              options,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            };
            const originalStreamCallback = options.streamCallback;
            const wrappedOptions = {
              ...options,
              streamCallback: (chunk) => {
                fullResponse += chunk;
                if (originalStreamCallback) {
                  originalStreamCallback(chunk);
                }
              },
              abortController
            };
            await provider.getCompletion(messages, wrappedOptions);
            this.activeStreams.delete(streamId);
            this.recordSuccess(providerName);
            this.updateMetrics(providerName, true, Date.now() - startTime, fullResponse.length);
            performanceMonitor.recordMetric("api_response_time", Date.now() - startTime, "time");
            performanceMonitor.recordMetric("api_response_size", fullResponse.length, "size");
            this.setCache(cacheKey, fullResponse);
            const responseData = {
              content: fullResponse,
              provider: providerName,
              model: this.plugin.settings.selectedModel || "default",
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              duration: Date.now() - startTime
            };
            debugLog((_a3 = this.plugin.settings.debugMode) != null ? _a3 : false, "info", "[AIDispatcher] AI request completed", {
              provider: providerName,
              responseLength: fullResponse.length,
              duration: responseData.duration
            });
            try {
              const pluginApp = getPluginApp(this.plugin);
              if (pluginApp) {
                await saveAICallToFolder(requestData, responseData, { settings: this.plugin.settings, app: pluginApp });
              } else {
                debugLog((_b2 = this.plugin.settings.debugMode) != null ? _b2 : false, "warn", "[AIDispatcher] Plugin app not available for saving AI call");
              }
            } catch (saveError) {
              debugLog((_c2 = this.plugin.settings.debugMode) != null ? _c2 : false, "error", "[AIDispatcher] Failed to save AI call:", saveError);
            }
          });
        } catch (error) {
          this.activeStreams.forEach((controller, id) => {
            if (controller === abortController) {
              this.activeStreams.delete(id);
            }
          });
          this.recordFailure(providerName);
          this.updateMetrics(providerName, false, Date.now() - startTime, 0);
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "error", "[AIDispatcher] AI request failed:", error);
          const maxRetries = 3;
          if (retryCount < maxRetries && this.shouldRetry(error)) {
            const backoffDelay = Math.pow(2, retryCount) * 1e3;
            debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "info", "[AIDispatcher] Retrying request", {
              attempt: retryCount + 1,
              delay: backoffDelay
            });
            await new Promise((resolve) => setTimeout(resolve, backoffDelay));
            return this.executeWithRetry(messages, options, providerName, cacheKey, retryCount + 1);
          }
          try {
            const errorResponseData = {
              error: error.message || "Unknown error",
              provider: providerName,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              duration: Date.now() - startTime
            };
            const requestData = {
              provider: providerName,
              model: this.plugin.settings.selectedModel || "default",
              messages,
              options,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            };
            const pluginApp = getPluginApp(this.plugin);
            if (pluginApp) {
              await saveAICallToFolder(requestData, errorResponseData, { settings: this.plugin.settings, app: pluginApp });
            }
          } catch (saveError) {
            debugLog((_c = this.plugin.settings.debugMode) != null ? _c : false, "error", "[AIDispatcher] Failed to save error log:", saveError);
          }
          throw error;
        }
      }
      /**
       * Determines if error is retryable.
       */
      shouldRetry(error) {
        const retryableErrors = ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "rate_limit_exceeded"];
        return retryableErrors.some(
          (code) => {
            var _a2;
            return ((_a2 = error.message) == null ? void 0 : _a2.includes(code)) || error.code === code;
          }
        );
      }
      /**
       * Updates metrics tracking.
       */
      updateMetrics(providerName, success, duration, tokenCount) {
        this.metrics.totalRequests++;
        if (success) {
          this.metrics.successfulRequests++;
          this.metrics.totalTokens += tokenCount;
          this.metrics.averageResponseTime = (this.metrics.averageResponseTime * (this.metrics.successfulRequests - 1) + duration) / this.metrics.successfulRequests;
        } else {
          this.metrics.failedRequests++;
          this.metrics.errorsByProvider[providerName] = (this.metrics.errorsByProvider[providerName] || 0) + 1;
        }
        this.metrics.requestsByProvider[providerName] = (this.metrics.requestsByProvider[providerName] || 0) + 1;
      }
      /**
       * Gets current metrics.
       */
      getMetrics() {
        return { ...this.metrics };
      }
      /**
       * Resets metrics.
       */
      resetMetrics() {
        this.metrics = {
          totalRequests: 0,
          successfulRequests: 0,
          failedRequests: 0,
          totalTokens: 0,
          totalCost: 0,
          averageResponseTime: 0,
          requestsByProvider: {},
          errorsByProvider: {},
          cacheHits: 0,
          cacheMisses: 0,
          deduplicatedRequests: 0
        };
      }
      /**
       * Clears cache.
       */
      clearCache() {
        var _a2;
        this.cache.clear();
        this.modelCache.clear();
        this.providerCache.clear();
        performanceMonitor.clearMetrics();
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] All caches cleared");
      }
      /**
       * Logs current performance metrics.
       */
      logPerformanceMetrics() {
        performanceMonitor.logMetrics();
      }
      /**
       * Aborts all active streams.
       */
      abortAllStreams() {
        var _a2;
        for (const [id, controller] of this.activeStreams) {
          controller.abort();
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Stream aborted", { id });
        }
        this.activeStreams.clear();
      }
      /**
       * Aborts specific stream by ID.
       */
      abortStream(streamId) {
        var _a2;
        const controller = this.activeStreams.get(streamId);
        if (controller) {
          controller.abort();
          this.activeStreams.delete(streamId);
          debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Stream aborted", { id: streamId });
        }
      }
      /**
       * Check if there are any active streams.
       */
      hasActiveStreams() {
        return this.activeStreams.size > 0;
      }
      /**
       * Get the current number of active streams.
       */
      getActiveStreamCount() {
        return this.activeStreams.size;
      }
      /**
       * Test connection to a specific provider.
       * 
       * @param providerType - The type of provider to test
       * @returns Promise resolving to connection test result
       */
      async testConnection(providerType) {
        var _a2;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Testing connection", { provider: providerType });
        const tempSettings = { ...this.plugin.settings, provider: providerType };
        const provider = createProvider(tempSettings);
        return await provider.testConnection();
      }
      /**
       * Get available models from a specific provider.
       *
       * @param providerType - The type of provider to query
       * @returns Promise resolving to list of available models
       */
      async getAvailableModels(providerType) {
        var _a2, _b;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Fetching available models", { provider: providerType });
        const cachedModels = this.providerCache.get(providerType);
        if (cachedModels) {
          debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "info", "[AIDispatcher] Using cached models", { provider: providerType });
          return cachedModels;
        }
        return await withErrorHandling(
          async () => {
            const tempSettings = { ...this.plugin.settings, provider: providerType };
            const provider = createProvider(tempSettings);
            const models = await provider.getAvailableModels();
            this.providerCache.set(providerType, models);
            return models;
          },
          "AIDispatcher",
          "getAvailableModels",
          { fallbackMessage: `Failed to fetch models for ${providerType}` }
        ) || [];
      }
      /**
       * Get all available unified models from all configured providers.
       *
       * @returns Promise resolving to unified model list
       */
      async getAllUnifiedModels() {
        var _a2, _b;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Fetching all unified models");
        const cacheKey = "all-unified-models";
        const cachedModels = this.modelCache.get(cacheKey);
        if (cachedModels) {
          debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "info", "[AIDispatcher] Using cached unified models");
          return cachedModels;
        }
        return await withErrorHandling(
          async () => {
            const models = await getAllAvailableModels(this.plugin.settings);
            this.modelCache.set(cacheKey, models);
            return models;
          },
          "AIDispatcher",
          "getAllUnifiedModels",
          { fallbackMessage: "Failed to fetch unified models" }
        ) || [];
      }
      /**
       * Refresh available models for a specific provider and update settings.
       * 
       * @param providerType - The provider to refresh models for
       * @returns Promise resolving to the updated models list
       */
      async refreshProviderModels(providerType) {
        var _a2, _b, _c;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Refreshing models for provider", { provider: providerType });
        try {
          const models = await this.getAvailableModels(providerType);
          const providerSettings = getProviderSettings(this.plugin.settings, providerType);
          if (providerSettings) {
            providerSettings.availableModels = models;
            providerSettings.lastTestResult = {
              timestamp: Date.now(),
              success: true,
              message: `Successfully refreshed ${models.length} models`
            };
            await this.plugin.saveSettings();
            debugLog(
              (_b = this.plugin.settings.debugMode) != null ? _b : false,
              "info",
              "[AIDispatcher] Successfully refreshed models",
              {
                provider: providerType,
                count: models.length
              }
            );
          }
          return models;
        } catch (error) {
          debugLog(
            (_c = this.plugin.settings.debugMode) != null ? _c : false,
            "error",
            "[AIDispatcher] Failed to refresh models",
            { provider: providerType, error }
          );
          const providerSettings = getProviderSettings(this.plugin.settings, providerType);
          if (providerSettings) {
            providerSettings.lastTestResult = {
              timestamp: Date.now(),
              success: false,
              message: error.message || "Failed to refresh models"
            };
            await this.plugin.saveSettings();
          }
          throw error;
        }
      }
      /**
       * Refresh models for all configured providers.
       * 
       * @returns Promise resolving to a map of provider -> models
       */
      async refreshAllProviderModels() {
        var _a2, _b;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Refreshing models for all providers");
        const providers = ["openai", "anthropic", "gemini", "ollama"];
        const results = {};
        for (const provider of providers) {
          try {
            results[provider] = await this.refreshProviderModels(provider);
          } catch (error) {
            debugLog(
              (_b = this.plugin.settings.debugMode) != null ? _b : false,
              "warn",
              "[AIDispatcher] Failed to refresh models for provider",
              { provider, error }
            );
            results[provider] = [];
          }
        }
        this.plugin.settings.availableModels = await this.getAllUnifiedModels();
        await this.plugin.saveSettings();
        return results;
      }
      /**
       * Set the current model selection.
       * 
       * @param unifiedModelId - The unified model ID (e.g., "openai:gpt-4")
       */
      async setSelectedModel(unifiedModelId) {
        var _a2, _b;
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[AIDispatcher] Setting selected model", { model: unifiedModelId });
        this.plugin.settings.selectedModel = unifiedModelId;
        const [providerType] = unifiedModelId.split(":", 2);
        if (isValidProviderName(providerType)) {
          this.plugin.settings.provider = providerType;
        } else {
          debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "warn", "[AIDispatcher] Invalid provider type from model ID", { providerType, unifiedModelId });
        }
        await this.plugin.saveSettings();
      }
      /**
       * Get the currently selected model.
       * 
       * @returns The current unified model ID or undefined
       */
      getCurrentModel() {
        return this.plugin.settings.selectedModel;
      }
      /**
       * Get model information for a specific unified model ID.
       * 
       * @param unifiedModelId - The unified model ID
       * @returns The model information or undefined if not found
       */
      getModelInfo(unifiedModelId) {
        var _a2;
        const model = (_a2 = this.plugin.settings.availableModels) == null ? void 0 : _a2.find((model2) => model2.id === unifiedModelId);
        if (!model) return void 0;
        return {
          id: model.id,
          name: model.name,
          provider: model.provider
        };
      }
      /**
       * Check if a specific provider is configured (has API key).
       * 
       * @param providerType - The provider to check
       * @returns True if the provider is configured
       */
      isProviderConfigured(providerType) {
        switch (providerType) {
          case "openai":
            return !!this.plugin.settings.openaiSettings.apiKey;
          case "anthropic":
            return !!this.plugin.settings.anthropicSettings.apiKey;
          case "gemini":
            return !!this.plugin.settings.geminiSettings.apiKey;
          case "ollama":
            return !!this.plugin.settings.ollamaSettings.serverUrl;
          default:
            return false;
        }
      }
      /**
       * Get configured providers (those with API keys).
       * 
       * @returns Array of configured provider names
       */
      getConfiguredProviders() {
        const providers = [];
        if (this.isProviderConfigured("openai")) providers.push("openai");
        if (this.isProviderConfigured("anthropic")) providers.push("anthropic");
        if (this.isProviderConfigured("gemini")) providers.push("gemini");
        if (this.isProviderConfigured("ollama")) providers.push("ollama");
        return providers;
      }
    };
  }
});

// src/components/chat/SettingsSections.ts
var SettingsSections_exports = {};
__export(SettingsSections_exports, {
  SettingsSections: () => SettingsSections
});
var import_obsidian15, SettingsSections;
var init_SettingsSections = __esm({
  "src/components/chat/SettingsSections.ts"() {
    import_obsidian15 = require("obsidian");
    init_aiDispatcher();
    SettingsSections = class {
      /**
       * @param plugin The plugin instance (for accessing/saving settings).
       */
      constructor(plugin) {
        __publicField(this, "plugin");
        this.plugin = plugin;
      }
      /**
       * Renders the AI Model Settings section.
       * Includes system message, streaming, temperature, model selection, and model refresh.
       * @param containerEl The HTML element to render the section into.
       * @param onRefresh Optional callback to refresh the entire settings view after certain actions.
       */
      async renderAIModelSettings(containerEl, onRefresh) {
        while (containerEl.firstChild) containerEl.removeChild(containerEl.firstChild);
        if (this.plugin.settings.modelSettingPresets && this.plugin.settings.modelSettingPresets.length > 0) {
          const presetContainer = containerEl.createDiv();
          presetContainer.addClass("model-preset-buttons");
          presetContainer.createEl("div", { text: "Presets:", cls: "setting-item-name" });
          this.plugin.settings.modelSettingPresets.forEach((preset, idx) => {
            const btn = presetContainer.createEl("button", { text: preset.name });
            btn.style.marginRight = "0.5em";
            btn.onclick = async () => {
              if (preset.selectedModel !== void 0) this.plugin.settings.selectedModel = preset.selectedModel;
              if (preset.systemMessage !== void 0) this.plugin.settings.systemMessage = preset.systemMessage;
              if (preset.temperature !== void 0) this.plugin.settings.temperature = preset.temperature;
              if (preset.enableStreaming !== void 0) this.plugin.settings.enableStreaming = preset.enableStreaming;
              await this.plugin.saveSettings();
              if (onRefresh) {
                if (window._aiModelSettingsRefreshTimeout) {
                  clearTimeout(window._aiModelSettingsRefreshTimeout);
                }
                window._aiModelSettingsRefreshTimeout = setTimeout(() => {
                  onRefresh();
                  window._aiModelSettingsRefreshTimeout = null;
                }, 50);
              }
              new import_obsidian15.Notice(`Applied preset: ${preset.name}`);
            };
          });
        }
        new import_obsidian15.Setting(containerEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => {
          text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange((value) => {
            this.plugin.settings.systemMessage = value;
          });
          text.inputEl.addEventListener("blur", async () => {
            await this.plugin.saveSettings();
          });
          return text;
        });
        new import_obsidian15.Setting(containerEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
          this.plugin.settings.enableStreaming = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian15.Setting(containerEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.temperature = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian15.Setting(containerEl).setName("Refresh Available Models").setDesc("Test connections to all configured providers and refresh available models").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
          button.setButtonText("Refreshing...");
          button.setDisabled(true);
          try {
            await this.refreshAllAvailableModels();
            new import_obsidian15.Notice("Successfully refreshed available models");
            if (onRefresh) onRefresh();
          } catch (error) {
            new import_obsidian15.Notice(`Error refreshing models: ${error.message}`);
          } finally {
            button.setButtonText("Refresh Models");
            button.setDisabled(false);
          }
        }));
        await this.renderUnifiedModelDropdown(containerEl);
      }
      /**
       * Date Settings Section.
       * Includes options for including date and time in the system message.
       * @param containerEl The HTML element to render the section into.
       */
      renderDateSettings(containerEl) {
        new import_obsidian15.Setting(containerEl).setName("Include Time with System Message").setDesc("Add the current time along with the date to the system message").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimeWithSystemMessage).onChange(async (value) => {
          this.plugin.settings.includeTimeWithSystemMessage = value;
          await this.plugin.saveSettings();
        }));
      }
      /**
       * Note Reference Settings Section.
       * Includes options for Obsidian links, context notes, and recursive link expansion.
       * @param containerEl The HTML element to render the section into.
       */
      renderNoteReferenceSettings(containerEl) {
        new import_obsidian15.Setting(containerEl).setName("Enable Obsidian Links").setDesc("Read Obsidian links in messages using [[filename]] syntax").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianLinks).onChange(async (value) => {
          this.plugin.settings.enableObsidianLinks = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian15.Setting(containerEl).setName("Enable Context Notes").setDesc("Attach specified note content to chat messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableContextNotes).onChange(async (value) => {
          this.plugin.settings.enableContextNotes = value;
          await this.plugin.saveSettings();
        }));
        const contextNotesContainer = containerEl.createDiv("context-notes-container");
        contextNotesContainer.style.marginBottom = "24px";
        new import_obsidian15.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[filename#header]] syntax)").addTextArea((text) => {
          text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange((value) => {
            this.plugin.settings.contextNotes = value;
          });
          text.inputEl.addEventListener("blur", async () => {
            await this.plugin.saveSettings();
          });
          text.inputEl.rows = 4;
          text.inputEl.style.width = "100%";
          return text;
        });
        new import_obsidian15.Setting(containerEl).setName("Expand Linked Notes Recursively").setDesc("If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).").addToggle((toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false).onChange(async (value) => {
            this.plugin.settings.expandLinkedNotesRecursively = value;
            await this.plugin.saveSettings();
          });
        });
      }
      /**
       * Provider Configuration Section.
       * Renders collapsible sections for each provider's specific settings and test buttons.
       * @param containerEl The HTML element to render the section into.
       */
      renderProviderConfiguration(containerEl) {
        containerEl.createEl("p", {
          text: "API keys are configured in the main plugin settings. Use the test buttons below to verify connections and refresh available models.",
          cls: "setting-item-description"
        });
        this.renderOpenAIConfig(containerEl);
        this.renderAnthropicConfig(containerEl);
        this.renderGeminiConfig(containerEl);
        this.renderOllamaConfig(containerEl);
      }
      /**
       * Renders the unified model selection dropdown.
       * Populates the dropdown with available models fetched from providers.
       * @param containerEl The HTML element to render the dropdown into.
       */
      async renderUnifiedModelDropdown(containerEl) {
        if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
          const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
          this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
          await this.plugin.saveSettings();
        }
        new import_obsidian15.Setting(containerEl).setName("Selected Model").setDesc("Choose from all available models across all configured providers").addDropdown((dropdown) => {
          if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
            dropdown.addOption("", "No models available - configure providers below");
          } else {
            dropdown.addOption("", "Select a model...");
            const modelsByProvider = {};
            const enabledModels = this.plugin.settings.enabledModels || {};
            const filteredModels = this.plugin.settings.availableModels.filter((model) => enabledModels[model.id] !== false);
            filteredModels.forEach((model) => {
              if (!modelsByProvider[model.provider]) {
                modelsByProvider[model.provider] = [];
              }
              modelsByProvider[model.provider].push(model);
            });
            Object.entries(modelsByProvider).forEach(([provider, models]) => {
              models.forEach((model) => {
                dropdown.addOption(model.id, model.name);
              });
            });
          }
          dropdown.setValue(this.plugin.settings.selectedModel || "").onChange(async (value) => {
            this.plugin.settings.selectedModel = value;
            if (value) {
              const [provider] = value.split(":", 2);
              this.plugin.settings.provider = provider;
            }
            await this.plugin.saveSettings();
          });
        });
        if (this.plugin.settings.selectedModel && this.plugin.settings.availableModels) {
          const selectedModel = this.plugin.settings.availableModels.find(
            (model) => model.id === this.plugin.settings.selectedModel
          );
          if (selectedModel) {
            const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
            infoEl.setText(`Currently using: ${selectedModel.name}`);
          }
        }
      }
      /**
       * Refreshes available models from all configured providers using the dispatcher.
       * Uses the AIDispatcher to test connections and update available models.
       */
      async refreshAllAvailableModels() {
        const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
        try {
          await aiDispatcher.refreshAllProviderModels();
          this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
          await this.plugin.saveSettings();
        } catch (error) {
          console.error("Error refreshing all available models:", error);
        }
      }
      /**
       * Renders a collapsible section for provider configuration.
       * This is a helper method used by specific provider rendering methods.
       * @param containerEl The HTML element to render the section into.
       * @param providerType The type of the provider (e.g., 'openai', 'anthropic').
       * @param displayName The display name of the provider (e.g., 'OpenAI', 'Anthropic').
       * @param renderSpecificSettings A callback function to render provider-specific settings within the collapsible section.
       */
      _renderCollapsibleProviderConfig(containerEl, providerType, displayName, renderSpecificSettings) {
        const collapsibleContainer = containerEl.createDiv({ cls: "provider-collapsible" });
        const headerEl = collapsibleContainer.createEl("div", {
          cls: "provider-header",
          text: `\u25B6 ${displayName} Configuration`
        });
        Object.assign(headerEl.style, {
          cursor: "pointer",
          userSelect: "none",
          padding: "8px 0",
          fontWeight: "bold"
        });
        const contentEl = collapsibleContainer.createDiv({ cls: "provider-content" });
        contentEl.style.display = "none";
        contentEl.style.paddingLeft = "16px";
        let isExpanded = false;
        headerEl.addEventListener("click", () => {
          isExpanded = !isExpanded;
          contentEl.style.display = isExpanded ? "block" : "none";
          headerEl.textContent = `${isExpanded ? "\u25BC" : "\u25B6"} ${displayName} Configuration`;
        });
        const settings = this.plugin.settings[`${providerType}Settings`];
        const apiKeyStatus = settings.apiKey ? `API Key: ${settings.apiKey.substring(0, 8)}...` : "No API Key configured";
        const serverUrlStatus = settings.serverUrl ? `Server URL: ${settings.serverUrl}` : "No Server URL configured";
        contentEl.createEl("div", {
          cls: "setting-item-description",
          text: `${settings.apiKey ? apiKeyStatus : serverUrlStatus} (Configure in main plugin settings)`
        });
        if (renderSpecificSettings) {
          renderSpecificSettings(contentEl);
        }
        this.renderProviderTestSection(contentEl, providerType, displayName);
      }
      /**
       * Renders the OpenAI configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOpenAIConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "openai", "OpenAI", (contentEl) => {
          new import_obsidian15.Setting(contentEl).setName("OpenAI Base URL").setDesc("Custom base URL for OpenAI API (optional)").addText((text) => {
            text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openaiSettings.baseUrl || "").onChange((value) => {
              this.plugin.settings.openaiSettings.baseUrl = value;
            });
            text.inputEl.addEventListener("blur", async () => {
              await this.plugin.saveSettings();
            });
            return text;
          });
        });
      }
      /**
       * Renders the Anthropic configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderAnthropicConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "anthropic", "Anthropic");
      }
      /**
       * Renders the Gemini configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderGeminiConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "gemini", "Gemini");
      }
      /**
       * Renders the Ollama configuration section.
       * @param containerEl The HTML element to render the section into.
       */
      renderOllamaConfig(containerEl) {
        this._renderCollapsibleProviderConfig(containerEl, "ollama", "Ollama", (contentEl) => {
          contentEl.createEl("div", {
            cls: "setting-item-description",
            text: "To use Ollama:"
          });
          const steps = contentEl.createEl("ol");
          steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
          steps.createEl("li", { text: "Start the Ollama server" });
          steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
          steps.createEl("li", { text: "Test connection to see available models" });
        });
      }
      /**
       * Renders the provider connection test section.
       * Includes a test button and displays the last test result and available models.
       * @param containerEl The HTML element to render the section into.
       * @param provider The internal identifier for the provider (e.g., 'openai').
       * @param displayName The user-friendly name of the provider (e.g., 'OpenAI').
       */
      renderProviderTestSection(containerEl, provider, displayName) {
        const settings = this.plugin.settings[`${provider}Settings`];
        new import_obsidian15.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${displayName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
          button.setButtonText("Testing...");
          button.setDisabled(true);
          try {
            const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
            const result = await aiDispatcher.testConnection(provider);
            if (result.success && result.models) {
              settings.availableModels = result.models;
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: true,
                message: result.message
              };
              await this.plugin.saveSettings();
              this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
              await this.plugin.saveSettings();
              new import_obsidian15.Notice(result.message);
            } else {
              settings.lastTestResult = {
                timestamp: Date.now(),
                success: false,
                message: result.message
              };
              new import_obsidian15.Notice(result.message);
            }
          } catch (error) {
            new import_obsidian15.Notice(`Error: ${error.message}`);
            settings.lastTestResult = {
              timestamp: Date.now(),
              success: false,
              message: `Test failed: ${error.message}`
            };
          } finally {
            button.setButtonText("Test");
            button.setDisabled(false);
          }
        }));
        if (settings.lastTestResult) {
          const date = new Date(settings.lastTestResult.timestamp);
          containerEl.createEl("div", {
            text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
            cls: settings.lastTestResult.success ? "success" : "error"
          });
        }
        if (settings.availableModels && settings.availableModels.length > 0) {
          containerEl.createEl("div", {
            text: `Available models: ${settings.availableModels.map((m) => m.name || m.id).join(", ")}`,
            cls: "setting-item-description"
          });
        }
      }
      /**
       * Debug Mode Section.
       * Includes a toggle for enabling/disabling debug mode.
       * @param containerEl The HTML element to render the section into.
       */
      renderDebugModeSettings(containerEl) {
        new import_obsidian15.Setting(containerEl).setName("Debug Mode").setDesc("Enable verbose logging and debug UI features").addToggle((toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false).onChange(async (value) => {
            this.plugin.settings.debugMode = value;
            await this.plugin.saveSettings();
          });
        });
      }
      /**
       * Renders all settings sections in order for a modal or view.
       * This method orchestrates the rendering of all distinct setting categories.
       * @param containerEl The HTML element to render the sections into.
       * @param options Optional settings, e.g., onRefresh callback.
       */
      async renderAllSettings(containerEl, options) {
        await this.renderAIModelSettings(containerEl, options == null ? void 0 : options.onRefresh);
        this.renderDateSettings(containerEl);
        this.renderNoteReferenceSettings(containerEl);
        this.renderProviderConfiguration(containerEl);
        this.renderDebugModeSettings(containerEl);
      }
    };
  }
});

// src/components/chat/SettingsModal.ts
var SettingsModal_exports = {};
__export(SettingsModal_exports, {
  SettingsModal: () => SettingsModal
});
var import_obsidian16, SettingsModal;
var init_SettingsModal = __esm({
  "src/components/chat/SettingsModal.ts"() {
    import_obsidian16 = require("obsidian");
    init_SettingsSections();
    SettingsModal = class extends import_obsidian16.Modal {
      /**
       * Constructs a SettingsModal instance.
       * @param app The Obsidian App instance.
       * @param plugin The plugin instance (for accessing/saving settings and event handling).
       */
      constructor(app, plugin) {
        super(app);
        __publicField(this, "plugin");
        __publicField(this, "settingsSections");
        /**
         * Handler for settings change events. Refreshes the modal content.
         */
        __publicField(this, "_onSettingsChange", () => {
          this.onOpen();
        });
        this.plugin = plugin;
        this.settingsSections = new SettingsSections(plugin);
        this.titleEl.setText("AI Model Settings");
        this.plugin.onSettingsChange(this._onSettingsChange);
      }
      /**
       * Called when the modal is opened.
       * Clears existing content and renders all settings sections.
       */
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("ai-settings-modal");
        await this.settingsSections.renderAllSettings(contentEl, { onRefresh: () => this.onOpen() });
      }
      /**
       * Called when the modal is closed.
       * Cleans up the modal content and unsubscribes from settings changes.
       */
      onClose() {
        this.plugin.offSettingsChange(this._onSettingsChange);
        this.contentEl.empty();
      }
    };
  }
});

// src/components/chat/eventHandlers.ts
function getFormattedChatContent(messagesContainer, plugin, chatSeparator) {
  const messages = messagesContainer.querySelectorAll(".ai-chat-message");
  let chatContent = "";
  const renderer = new MessageRenderer(plugin.app);
  messages.forEach((el, index) => {
    var _a2;
    const htmlElement = el;
    if (htmlElement.classList.contains("tool-display-message")) {
      return;
    }
    let messageData = null;
    const messageDataStr = htmlElement.dataset.messageData;
    if (messageDataStr) {
      try {
        messageData = JSON.parse(messageDataStr);
      } catch (e) {
      }
    }
    if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
      chatContent += renderer.getMessageContentForCopy(messageData);
    } else {
      const rawContent = htmlElement.dataset.rawContent;
      const content = rawContent !== void 0 ? rawContent : ((_a2 = el.querySelector(".message-content")) == null ? void 0 : _a2.textContent) || "";
      chatContent += content;
    }
    if (index < messages.length - 1) {
      chatContent += "\n\n" + chatSeparator + "\n\n";
    }
  });
  return chatContent;
}
function handleCopyAll(messagesContainer, plugin) {
  return async () => {
    const chatContent = getFormattedChatContent(messagesContainer, plugin, plugin.settings.chatSeparator);
    await copyToClipboard(chatContent);
  };
}
function handleSaveNote(messagesContainer, plugin, app, agentResponseHandler) {
  return async () => {
    const chatContent = getFormattedChatContent(messagesContainer, plugin, plugin.settings.chatSeparator);
    await saveChatAsNote({
      app,
      messages: void 0,
      settings: plugin.settings,
      chatSeparator: plugin.settings.chatSeparator,
      chatNoteFolder: plugin.settings.chatNoteFolder,
      agentResponseHandler,
      chatContent
    });
  };
}
function handleClearChat(messagesContainer, chatHistoryManager) {
  return async () => {
    messagesContainer.empty();
    try {
      await chatHistoryManager.clearHistory();
    } catch (e) {
      new import_obsidian17.Notice("Failed to clear chat history.");
    }
  };
}
function handleSettings(app, plugin) {
  return () => {
    const { SettingsModal: SettingsModal2 } = (init_SettingsModal(), __toCommonJS(SettingsModal_exports));
    const settingsModal = new SettingsModal2(app, plugin);
    settingsModal.open();
  };
}
function handleHelp(app) {
  return () => {
    new ChatHelpModal(app).open();
  };
}
function handleCopyMessage(messageEl, plugin) {
  return async () => {
    let contentToCopy = "";
    const messageData = messageEl.dataset.messageData;
    if (messageData) {
      try {
        const parsedData = JSON.parse(messageData);
        const renderer = new MessageRenderer(plugin.app);
        contentToCopy = renderer.getMessageContentForCopy(parsedData);
      } catch (e) {
        contentToCopy = messageEl.dataset.rawContent || "";
      }
    } else {
      contentToCopy = messageEl.dataset.rawContent || "";
    }
    if (contentToCopy.trim() === "") {
      new import_obsidian17.Notice("No content to copy");
      return;
    }
    await copyToClipboard(contentToCopy);
    new import_obsidian17.Notice("Message copied to clipboard");
  };
}
function handleEditMessage(messageEl, chatHistoryManager, plugin) {
  return async () => {
    const contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) return;
    if (!contentEl.hasClass("editing")) {
      const textarea = document.createElement("textarea");
      textarea.value = messageEl.dataset.rawContent || "";
      textarea.className = "message-content editing";
      contentEl.empty();
      contentEl.appendChild(textarea);
      textarea.focus();
      contentEl.addClass("editing");
      textarea.addEventListener("keydown", async (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          textarea.blur();
        }
      });
      textarea.addEventListener("blur", async () => {
        const oldContent = messageEl.dataset.rawContent;
        const newContent = textarea.value;
        let enhancedData = void 0;
        if (messageEl.dataset.messageData) {
          try {
            enhancedData = JSON.parse(messageEl.dataset.messageData);
          } catch (e) {
          }
        }
        try {
          await chatHistoryManager.updateMessage(
            messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            messageEl.classList.contains("user") ? "user" : "assistant",
            oldContent || "",
            newContent,
            enhancedData
          );
          messageEl.dataset.rawContent = newContent;
          contentEl.empty();
          if (enhancedData && enhancedData.toolResults) {
            const renderer = new MessageRenderer(plugin.app);
            await renderer.renderMessage({
              role: messageEl.classList.contains("user") ? "user" : "assistant",
              content: newContent,
              toolResults: enhancedData.toolResults
            }, messageEl, void 0);
          } else {
            await import_obsidian17.MarkdownRenderer.render(plugin.app, newContent, contentEl, "", void 0);
          }
          contentEl.removeClass("editing");
        } catch (e) {
          new import_obsidian17.Notice("Failed to save edited message.");
          messageEl.dataset.rawContent = oldContent || "";
          contentEl.empty();
          await import_obsidian17.MarkdownRenderer.render(plugin.app, oldContent || "", contentEl, "", void 0);
          contentEl.removeClass("editing");
        }
      });
    }
  };
}
function handleDeleteMessage(messageEl, chatHistoryManager, app) {
  return () => {
    const modal = new ConfirmationModal(app, "Delete message", "Are you sure you want to delete this message?", (confirmed) => {
      if (confirmed) {
        chatHistoryManager.deleteMessage(
          messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          messageEl.classList.contains("user") ? "user" : "assistant",
          messageEl.dataset.rawContent || ""
        ).then(() => {
          messageEl.remove();
        }).catch(() => {
          new import_obsidian17.Notice("Failed to delete message from history.");
        });
      }
    });
    modal.open();
  };
}
function handleRegenerateMessage(messageEl, regenerateCallback) {
  return () => {
    regenerateCallback(messageEl);
  };
}
var import_obsidian17;
var init_eventHandlers = __esm({
  "src/components/chat/eventHandlers.ts"() {
    init_Buttons();
    init_chatPersistence();
    init_ChatHelpModal();
    import_obsidian17 = require("obsidian");
    init_MessageRenderer();
    init_ConfirmationModal();
  }
});

// src/components/chat/BotMessage.ts
var BotMessage_exports = {};
__export(BotMessage_exports, {
  BotMessage: () => BotMessage
});
var import_obsidian22, BotMessage;
var init_BotMessage = __esm({
  "src/components/chat/BotMessage.ts"() {
    import_obsidian22 = require("obsidian");
    init_Buttons();
    BotMessage = class extends import_obsidian22.Component {
      /**
       * Constructs a BotMessage instance.
       * @param app Obsidian App instance
       * @param plugin Plugin instance (for settings, logging, etc.)
       * @param content The message content (markdown)
       */
      constructor(app, plugin, content) {
        super();
        __publicField(this, "app");
        __publicField(this, "plugin");
        __publicField(this, "content");
        __publicField(this, "element");
        __publicField(this, "contentEl");
        this.app = app;
        this.plugin = plugin;
        this.content = content;
        this.element = this.createMessageElement();
      }
      /**
       * Returns the root element for this message.
       */
      getElement() {
        return this.element;
      }
      /**
       * Returns the current message content.
       */
      getContent() {
        return this.content;
      }
      /**
       * Updates the message content and re-renders the markdown.
       * @param content The new message content
       */
      async setContent(content) {
        this.content = content;
        this.element.dataset.rawContent = content;
        this.contentEl.empty();
        await import_obsidian22.MarkdownRenderer.render(
          this.app,
          content,
          this.contentEl,
          "",
          this
        );
      }
      /**
       * Creates the message DOM element, including content and action buttons.
       * @returns The root message element
       */
      createMessageElement() {
        const messageEl = document.createElement("div");
        messageEl.addClass("ai-chat-message", "assistant");
        messageEl.dataset.rawContent = this.content;
        const messageContainer = messageEl.createDiv("message-container");
        this.contentEl = messageContainer.createDiv("message-content");
        import_obsidian22.MarkdownRenderer.render(
          this.app,
          this.content,
          this.contentEl,
          "",
          this
        );
        const buttons = new Buttons();
        const actions = buttons.createMessageActions([
          {
            label: "Copy",
            tooltip: "Copy message",
            onClick: async () => {
              const content = messageEl.dataset.rawContent || "";
              if (content.trim() === "") return;
              await navigator.clipboard.writeText(content);
            }
          },
          {
            label: "Edit",
            tooltip: "Edit message",
            onClick: () => {
              const wasEditing = this.contentEl.hasClass("editing");
              if (!wasEditing) {
                const textarea = document.createElement("textarea");
                textarea.value = messageEl.dataset.rawContent || "";
                this.contentEl.empty();
                this.contentEl.appendChild(textarea);
                textarea.focus();
                this.contentEl.addClass("editing");
              } else {
                const textarea = this.contentEl.querySelector("textarea");
                if (textarea) {
                  this.setContent(textarea.value);
                  this.contentEl.removeClass("editing");
                }
              }
            }
          },
          {
            label: "Delete",
            tooltip: "Delete message",
            onClick: () => {
              messageEl.remove();
            }
          },
          {
            label: "Regenerate",
            tooltip: "Regenerate this response",
            onClick: () => {
              const event = new CustomEvent("ai-assistant:regenerate-response", {
                detail: { messageEl }
              });
              this.app.workspace.trigger("ai-assistant:regenerate-response", messageEl);
            }
          }
        ]);
        messageEl.addEventListener("mouseenter", () => {
        });
        messageEl.addEventListener("mouseleave", () => {
        });
        messageContainer.appendChild(actions);
        return messageEl;
      }
    };
  }
});

// src/components/chat/inputHandler.ts
var inputHandler_exports = {};
__export(inputHandler_exports, {
  setupInputHandler: () => setupInputHandler
});
function setupInputHandler(textarea, messagesContainer, sendMessage, handleSlashCommand, app, plugin, sendButton, stopButton) {
  const handleKeyboardShortcuts = async (e) => {
    if (e.ctrlKey && e.shiftKey) {
      if (e.key.toLowerCase() === "x") {
        e.preventDefault();
        await handleSlashCommand("/clear");
        return true;
      }
      if (e.key.toLowerCase() === "c") {
        e.preventDefault();
        await handleSlashCommand("/copy");
        return true;
      }
      if (e.key.toLowerCase() === "s") {
        e.preventDefault();
        await handleSlashCommand("/save");
        return true;
      }
      if (e.key.toLowerCase() === "o") {
        e.preventDefault();
        await handleSlashCommand("/settings");
        return true;
      }
      if (e.key.toLowerCase() === "h") {
        e.preventDefault();
        handleHelp(app)();
        return true;
      }
      if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        await handleSlashCommand("/ref");
        return true;
      }
    }
    return false;
  };
  textarea.addEventListener("keydown", async (e) => {
    if (await handleKeyboardShortcuts(e)) return;
    if (e.key === "Enter" && !e.shiftKey) {
      const val = textarea.value.trim();
      if (val === "/clear" || val === "/copy" || val === "/save" || val === "/settings" || val === "/help" || val === "/ref") {
        e.preventDefault();
        await handleSlashCommand(val);
        textarea.value = "";
        return;
      }
      await sendMessage();
      e.preventDefault();
    }
  });
  messagesContainer.addEventListener("keydown", async (e) => {
    await handleKeyboardShortcuts(e);
  });
}
var init_inputHandler = __esm({
  "src/components/chat/inputHandler.ts"() {
    init_eventHandlers();
  }
});

// src/utils/clearAICallLogs.ts
var clearAICallLogs_exports = {};
__export(clearAICallLogs_exports, {
  clearAICallLogs: () => clearAICallLogs
});
async function clearAICallLogs(pluginFolder, subfolder = "ai-calls") {
  const targetFolder = path2.join(pluginFolder, subfolder);
  if (!fs2.existsSync(targetFolder)) return 0;
  const files = fs2.readdirSync(targetFolder);
  let deleted = 0;
  for (const file of files) {
    const filePath = path2.join(targetFolder, file);
    if (fs2.lstatSync(filePath).isFile()) {
      fs2.unlinkSync(filePath);
      deleted++;
    }
  }
  return deleted;
}
var fs2, path2;
var init_clearAICallLogs = __esm({
  "src/utils/clearAICallLogs.ts"() {
    fs2 = __toESM(require("fs"));
    path2 = __toESM(require("path"));
  }
});

// src/YAMLHandler.ts
var YAMLHandler_exports = {};
__export(YAMLHandler_exports, {
  generateNoteTitle: () => generateNoteTitle,
  generateYamlAttribute: () => generateYamlAttribute,
  registerYamlAttributeCommands: () => registerYamlAttributeCommands,
  upsertYamlField: () => upsertYamlField
});
function generateTableOfContents(noteContent) {
  const headerLines = noteContent.split("\n").filter((line) => /^#{1,6}\s+.+/.test(line));
  if (headerLines.length === 0) return "";
  return headerLines.map((line) => {
    const match = line.match(/^(#{1,6})\s+(.+)/);
    if (!match) return "";
    const level = match[1].length;
    const title = match[2].trim();
    return `${"  ".repeat(level - 1)}- ${title}`;
  }).join("\n");
}
async function generateNoteTitle(app, settings, processMessages2, dispatcher) {
  var _a2, _b;
  debugLog(DEBUG, "debug", "Starting generateNoteTitle");
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian33.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const toc = generateTableOfContents(noteContent);
  const prompt = DEFAULT_TITLE_PROMPT;
  const userContent = (toc && toc.trim().length > 0 ? "Table of Contents:\n" + toc + "\n\n" : "") + noteContent;
  try {
    debugLog(DEBUG, "debug", "Provider:", settings.provider);
    const aiDispatcher = dispatcher != null ? dispatcher : new AIDispatcher(app.vault, { settings, saveSettings: async () => {
    } });
    const messages = [
      { role: "system", content: prompt },
      { role: "user", content: userContent }
    ];
    debugLog(DEBUG, "debug", "Original messages:", JSON.stringify(messages));
    const processedMessages = await withTemporarySetting(
      settings,
      "enableContextNotes",
      false,
      async () => {
        debugLog(DEBUG, "debug", "Context notes temporarily disabled for title generation");
        return await processMessages2(messages);
      }
    );
    debugLog(DEBUG, "debug", "Processed messages:", JSON.stringify(processedMessages));
    if (!processedMessages || processedMessages.length === 0) {
      debugLog(DEBUG, "debug", "No processed messages!");
      new import_obsidian33.Notice("No valid messages to send to the model. Please check your note content.");
      return;
    }
    debugLog(DEBUG, "debug", "Calling dispatcher.getCompletion");
    let resultBuffer = "";
    await aiDispatcher.getCompletion(processedMessages, {
      temperature: 0,
      streamCallback: (chunk) => {
        resultBuffer += chunk;
      }
    });
    debugLog(DEBUG, "debug", "Result from dispatcher (buffered):", resultBuffer);
    let title = resultBuffer.trim();
    debugLog(DEBUG, "debug", "Extracted title before sanitization:", title);
    title = title.replace(/[\\/:]/g, "").trim();
    debugLog(DEBUG, "debug", "Sanitized title:", title);
    if (title && typeof title === "string" && title.length > 0) {
      const outputMode = (_a2 = settings.titleOutputMode) != null ? _a2 : "clipboard";
      debugLog(DEBUG, "debug", "Output mode:", outputMode);
      if (outputMode === "replace-filename") {
        const file = app.workspace.getActiveFile();
        if (file) {
          const ext = file.extension ? "." + file.extension : "";
          const sanitized = title;
          const parentPath = file.parent ? file.parent.path : "";
          const newPath = parentPath ? parentPath + "/" + sanitized + ext : sanitized + ext;
          if (file.path !== newPath) {
            await app.fileManager.renameFile(file, newPath);
            new import_obsidian33.Notice(`Note renamed to: ${sanitized}${ext}`);
          } else {
            new import_obsidian33.Notice(`Note title is already: ${sanitized}${ext}`);
          }
        }
      } else if (outputMode === "metadata") {
        const file = app.workspace.getActiveFile();
        if (file) {
          await upsertYamlField(app, file, "title", title);
          new import_obsidian33.Notice(`Inserted title into metadata: ${title}`);
        }
      } else {
        try {
          await navigator.clipboard.writeText(title);
          new import_obsidian33.Notice(`Generated title (copied): ${title}`);
        } catch (e) {
          new import_obsidian33.Notice(`Generated title: ${title}`);
        }
      }
    } else {
      debugLog(DEBUG, "debug", "No title generated after sanitization.");
      new import_obsidian33.Notice("No title generated.");
    }
  } catch (err) {
    new import_obsidian33.Notice("Error generating title: " + ((_b = err == null ? void 0 : err.message) != null ? _b : err));
  }
}
async function generateYamlAttribute(app, settings, processMessages2, attributeName, prompt, outputMode = "metadata", dispatcher) {
  debugLog(DEBUG, "debug", `Starting generateYamlAttribute for ${attributeName}`);
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian33.Notice("No active note found.");
    return;
  }
  let noteContent = await app.vault.cachedRead(activeFile);
  noteContent = noteContent.slice(0, 15e3);
  const messages = [
    { role: "system", content: DEFAULT_YAML_SYSTEM_MESSAGE },
    { role: "user", content: prompt + "\n\n" + noteContent }
  ];
  debugLog(DEBUG, "debug", "Original messages:", JSON.stringify(messages));
  try {
    const processedMessages = await withTemporarySetting(
      settings,
      "enableContextNotes",
      false,
      async () => {
        debugLog(DEBUG, "debug", "Context notes temporarily disabled for YAML attribute generation");
        return await processMessages2(messages);
      }
    );
    debugLog(DEBUG, "debug", "Processed messages:", JSON.stringify(processedMessages));
    if (!processedMessages || processedMessages.length === 0) {
      debugLog(DEBUG, "debug", "No processed messages!");
      new import_obsidian33.Notice("No valid messages to send to the model. Please check your note content.");
      return;
    }
    debugLog(DEBUG, "debug", "Calling dispatcher.getCompletion");
    const aiDispatcher = dispatcher != null ? dispatcher : new AIDispatcher(app.vault, { settings, saveSettings: async () => {
    } });
    let resultBuffer = "";
    await aiDispatcher.getCompletion(processedMessages, {
      temperature: 0,
      // Always use temperature 0 for predictable YAML output
      streamCallback: (chunk) => {
        resultBuffer += chunk;
      }
    });
    debugLog(DEBUG, "debug", "Result from dispatcher (buffered):", resultBuffer);
    let value = resultBuffer.trim();
    debugLog(DEBUG, "debug", "Extracted value before sanitization:", value);
    value = value.replace(/[\\/]/g, "").trim();
    debugLog(DEBUG, "debug", "Sanitized value:", value);
    if (value && typeof value === "string" && value.length > 0) {
      debugLog(DEBUG, "debug", "Output mode:", outputMode);
      if (outputMode === "metadata") {
        await upsertYamlField(app, activeFile, attributeName, value);
        new import_obsidian33.Notice(`Inserted ${attributeName} into metadata: ${value}`);
      } else {
        try {
          await navigator.clipboard.writeText(value);
          new import_obsidian33.Notice(`Generated ${attributeName} (copied): ${value}`);
        } catch (e) {
          new import_obsidian33.Notice(`Generated ${attributeName}: ${value}`);
        }
      }
    } else {
      debugLog(DEBUG, "debug", `No value generated for ${attributeName} after sanitization.`);
      new import_obsidian33.Notice(`No value generated for ${attributeName}.`);
    }
  } catch (processError) {
    debugLog(DEBUG, "debug", "Error in processMessages or provider.getCompletion:", processError);
    throw processError;
  }
}
async function upsertYamlField(app, file, field, value) {
  let content = await app.vault.read(file);
  let newContent = content;
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  if (match) {
    let yamlObj = {};
    try {
      yamlObj = load(match[1]) || {};
    } catch (e) {
      yamlObj = {};
    }
    yamlObj[field] = value;
    const newYaml = dump(yamlObj, { lineWidth: -1 }).trim();
    newContent = content.replace(frontmatterRegex, `---
${newYaml}
---`);
  } else {
    const newYaml = dump({ [field]: value }, { lineWidth: -1 }).trim();
    newContent = `---
${newYaml}
---
` + content;
  }
  await app.vault.modify(file, newContent);
}
function registerYamlAttributeCommands(plugin, settings, processMessages2, yamlAttributeCommandIds, debugLog2) {
  debugLog2("debug", "[YAMLHandler.ts] registerYamlAttributeCommands called");
  if (yamlAttributeCommandIds && yamlAttributeCommandIds.length > 0) {
    for (const id of yamlAttributeCommandIds) {
      plugin.app.commands.removeCommand(id);
      debugLog2("debug", "[YAMLHandler.ts] Removed previous YAML command", { id });
    }
  }
  const newCommandIds = [];
  if (settings.yamlAttributeGenerators && Array.isArray(settings.yamlAttributeGenerators)) {
    for (const gen of settings.yamlAttributeGenerators) {
      if (!gen.attributeName || !gen.prompt || !gen.commandName) continue;
      const id = `generate-yaml-attribute-${gen.attributeName}`;
      debugLog2("debug", "[YAMLHandler.ts] Registering YAML attribute command", { id, gen });
      registerCommand(plugin, {
        id,
        name: gen.commandName,
        callback: async () => {
          await generateYamlAttribute(
            plugin.app,
            settings,
            processMessages2,
            gen.attributeName,
            gen.prompt,
            gen.outputMode
          );
        }
      });
      newCommandIds.push(id);
    }
  }
  return newCommandIds;
}
var import_obsidian33, DEBUG;
var init_YAMLHandler = __esm({
  "src/YAMLHandler.ts"() {
    import_obsidian33 = require("obsidian");
    init_aiDispatcher();
    init_promptConstants();
    init_pluginUtils();
    init_js_yaml();
    init_logger();
    init_typeGuards();
    DEBUG = true;
  }
});

// src/utils/eventBus.ts
var EventBus, globalEventBus, TypedEventBus, chatEventBus;
var init_eventBus = __esm({
  "src/utils/eventBus.ts"() {
    EventBus = class {
      constructor() {
        __publicField(this, "subscriptions", /* @__PURE__ */ new Map());
        __publicField(this, "subscriptionIdCounter", 0);
        __publicField(this, "isDisposed", false);
      }
      /**
       * Publishes an event to all subscribers
       */
      async publish(event, data) {
        if (this.isDisposed) {
          console.warn(`[EventBus] Cannot publish to disposed event bus: ${event}`);
          return;
        }
        const eventSubscriptions = this.subscriptions.get(event);
        if (!eventSubscriptions || eventSubscriptions.length === 0) {
          return;
        }
        const handlersToCall = [...eventSubscriptions];
        const onceHandlers = [];
        const promises = handlersToCall.map(async (subscription) => {
          try {
            const result = subscription.handler(data);
            if (result instanceof Promise) {
              await result;
            }
            if (subscription.once) {
              onceHandlers.push(subscription.id);
            }
          } catch (error) {
            console.error(`[EventBus] Error in event handler for '${event}':`, error);
          }
        });
        await Promise.all(promises);
        if (onceHandlers.length > 0) {
          this.removeSubscriptionsByIds(event, onceHandlers);
        }
      }
      /**
       * Subscribes to an event
       */
      subscribe(event, handler) {
        if (this.isDisposed) {
          console.warn(`[EventBus] Cannot subscribe to disposed event bus: ${event}`);
          return () => {
          };
        }
        const subscription = {
          event,
          handler,
          once: false,
          id: `sub_${++this.subscriptionIdCounter}`
        };
        if (!this.subscriptions.has(event)) {
          this.subscriptions.set(event, []);
        }
        this.subscriptions.get(event).push(subscription);
        return () => {
          this.removeSubscriptionById(event, subscription.id);
        };
      }
      /**
       * Subscribes to an event for one-time execution
       */
      subscribeOnce(event, handler) {
        if (this.isDisposed) {
          console.warn(`[EventBus] Cannot subscribe to disposed event bus: ${event}`);
          return () => {
          };
        }
        const subscription = {
          event,
          handler,
          once: true,
          id: `once_${++this.subscriptionIdCounter}`
        };
        if (!this.subscriptions.has(event)) {
          this.subscriptions.set(event, []);
        }
        this.subscriptions.get(event).push(subscription);
        return () => {
          this.removeSubscriptionById(event, subscription.id);
        };
      }
      /**
       * Unsubscribes from an event
       */
      unsubscribe(event, handler) {
        if (!this.subscriptions.has(event)) {
          return;
        }
        if (handler) {
          const subscriptions = this.subscriptions.get(event);
          const filtered = subscriptions.filter((sub) => sub.handler !== handler);
          if (filtered.length === 0) {
            this.subscriptions.delete(event);
          } else {
            this.subscriptions.set(event, filtered);
          }
        } else {
          this.subscriptions.delete(event);
        }
      }
      /**
       * Clears all subscriptions
       */
      clear() {
        this.subscriptions.clear();
        this.subscriptionIdCounter = 0;
      }
      /**
       * Gets the number of subscriptions for an event or total
       */
      getSubscriptionCount(event) {
        var _a2;
        if (event) {
          return ((_a2 = this.subscriptions.get(event)) == null ? void 0 : _a2.length) || 0;
        }
        let total = 0;
        for (const subs of this.subscriptions.values()) {
          total += subs.length;
        }
        return total;
      }
      /**
       * Gets all registered event names
       */
      getRegisteredEvents() {
        return Array.from(this.subscriptions.keys());
      }
      /**
       * Disposes the event bus and clears all subscriptions
       */
      dispose() {
        this.clear();
        this.isDisposed = true;
      }
      /**
       * Removes a subscription by ID
       */
      removeSubscriptionById(event, id) {
        const subscriptions = this.subscriptions.get(event);
        if (!subscriptions) return;
        const filtered = subscriptions.filter((sub) => sub.id !== id);
        if (filtered.length === 0) {
          this.subscriptions.delete(event);
        } else {
          this.subscriptions.set(event, filtered);
        }
      }
      /**
       * Removes multiple subscriptions by IDs
       */
      removeSubscriptionsByIds(event, ids) {
        const subscriptions = this.subscriptions.get(event);
        if (!subscriptions) return;
        const idsSet = new Set(ids);
        const filtered = subscriptions.filter((sub) => !idsSet.has(sub.id));
        if (filtered.length === 0) {
          this.subscriptions.delete(event);
        } else {
          this.subscriptions.set(event, filtered);
        }
      }
    };
    globalEventBus = new EventBus();
    TypedEventBus = class {
      constructor(eventBus = globalEventBus) {
        this.eventBus = eventBus;
      }
      publish(event, data) {
        return this.eventBus.publish(event, data);
      }
      subscribe(event, handler) {
        return this.eventBus.subscribe(event, handler);
      }
      subscribeOnce(event, handler) {
        return this.eventBus.subscribeOnce(event, handler);
      }
      unsubscribe(event, handler) {
        this.eventBus.unsubscribe(event, handler);
      }
    };
    chatEventBus = new TypedEventBus();
  }
});

// src/utils/dependencyInjection.ts
var dependencyInjection_exports = {};
__export(dependencyInjection_exports, {
  DIContainer: () => DIContainer,
  DIContainerFactory: () => DIContainerFactory,
  Injectable: () => Injectable,
  ServiceLocator: () => ServiceLocator,
  ServiceRegistry: () => ServiceRegistry
});
function Injectable(name, lifecycle = "singleton") {
  return function(constructor) {
    const container = ServiceLocator.getContainer();
    container.register(name, () => new constructor(), lifecycle);
    return constructor;
  };
}
var DIContainer, _ServiceLocator, ServiceLocator, DIContainerFactory, ServiceRegistry, ErrorBoundaryService, ConfigurationManagerService, ChatServiceImpl, ChatUIManagerImpl, StreamCoordinatorImpl, AgentServiceImpl, ToolExecutionEngineImpl, ExecutionLimitManagerImpl, ViewManagerImpl, CommandManagerImpl;
var init_dependencyInjection = __esm({
  "src/utils/dependencyInjection.ts"() {
    init_aiDispatcher();
    init_errorHandler();
    init_eventBus();
    DIContainer = class {
      constructor(eventBus = globalEventBus) {
        __publicField(this, "services", /* @__PURE__ */ new Map());
        __publicField(this, "instances", /* @__PURE__ */ new Map());
        __publicField(this, "metadata", /* @__PURE__ */ new Map());
        __publicField(this, "scopes", /* @__PURE__ */ new Map());
        __publicField(this, "currentScope", null);
        __publicField(this, "isDisposed", false);
        __publicField(this, "eventBus");
        __publicField(this, "serviceInitializationOrder", []);
        this.eventBus = eventBus;
        this.registerCoreServices();
      }
      /**
       * Register a service with the container
       */
      register(name, factory, lifecycle = "singleton", dependencies = []) {
        if (this.isDisposed) {
          throw new Error("Cannot register services on disposed container");
        }
        this.services.set(name, {
          factory,
          lifecycle,
          dependencies
        });
        this.metadata.set(name, {
          name,
          lifecycle,
          dependencies,
          createdAt: Date.now(),
          lastAccessed: 0,
          accessCount: 0
        });
      }
      /**
       * Register a service with interface validation
       */
      registerService(name, factory, lifecycle = "singleton", dependencies = [], interfaceValidator) {
        const enhancedFactory = (container) => {
          const instance = factory(container);
          if (interfaceValidator && !interfaceValidator(instance)) {
            throw new Error(`Service '${name}' does not implement required interface`);
          }
          this.eventBus.publish("service.registered", {
            name,
            lifecycle,
            dependencies,
            timestamp: Date.now()
          });
          return instance;
        };
        this.register(name, enhancedFactory, lifecycle, dependencies);
        this.serviceInitializationOrder.push(name);
      }
      /**
       * Register a singleton service
       */
      registerSingleton(name, factory, dependencies = []) {
        this.register(name, factory, "singleton", dependencies);
      }
      /**
       * Register a transient service (new instance every time)
       */
      registerTransient(name, factory, dependencies = []) {
        this.register(name, factory, "transient", dependencies);
      }
      /**
       * Register a scoped service (one instance per scope)
       */
      registerScoped(name, factory, dependencies = []) {
        this.register(name, factory, "scoped", dependencies);
      }
      /**
       * Resolve a service by name
       */
      resolve(name) {
        if (this.isDisposed) {
          throw new Error("Cannot resolve services from disposed container");
        }
        const service = this.services.get(name);
        if (!service) {
          throw new Error(`Service '${name}' not registered`);
        }
        const meta = this.metadata.get(name);
        meta.lastAccessed = Date.now();
        meta.accessCount++;
        this.checkCircularDependencies(name, /* @__PURE__ */ new Set());
        switch (service.lifecycle) {
          case "singleton":
            return this.resolveSingleton(name, service);
          case "transient":
            return this.resolveTransient(name, service);
          case "scoped":
            return this.resolveScoped(name, service);
          default:
            throw new Error(`Unknown lifecycle: ${service.lifecycle}`);
        }
      }
      /**
       * Resolve with dependency validation and circular dependency detection
       */
      resolveWithValidation(name, expectedInterface) {
        const instance = this.resolve(name);
        this.eventBus.publish("service.resolved", {
          name,
          timestamp: Date.now(),
          expectedInterface
        });
        return instance;
      }
      /**
       * Check if a service is registered
       */
      isRegistered(name) {
        return this.services.has(name);
      }
      /**
       * Get all registered service names
       */
      getRegisteredServices() {
        return Array.from(this.services.keys());
      }
      /**
       * Get service metadata
       */
      getServiceMetadata(name) {
        return this.metadata.get(name);
      }
      /**
       * Get all service metadata
       */
      getAllServiceMetadata() {
        return Array.from(this.metadata.values());
      }
      /**
       * Create a new scope
       */
      createScope(scopeId) {
        if (this.scopes.has(scopeId)) {
          throw new Error(`Scope '${scopeId}' already exists`);
        }
        this.scopes.set(scopeId, /* @__PURE__ */ new Map());
      }
      /**
       * Enter a scope
       */
      enterScope(scopeId) {
        if (!this.scopes.has(scopeId)) {
          this.createScope(scopeId);
        }
        this.currentScope = scopeId;
      }
      /**
       * Exit current scope
       */
      exitScope() {
        this.currentScope = null;
      }
      /**
       * Dispose a scope and all its instances
       */
      disposeScope(scopeId) {
        const scope = this.scopes.get(scopeId);
        if (scope) {
          for (const [, instance] of scope) {
            this.disposeInstance(instance);
          }
          this.scopes.delete(scopeId);
        }
        if (this.currentScope === scopeId) {
          this.currentScope = null;
        }
      }
      /**
       * Dispose the entire container
       */
      dispose() {
        if (this.isDisposed) return;
        for (const scopeId of this.scopes.keys()) {
          this.disposeScope(scopeId);
        }
        for (const [, instance] of this.instances) {
          this.disposeInstance(instance);
        }
        this.services.clear();
        this.instances.clear();
        this.metadata.clear();
        this.scopes.clear();
        this.currentScope = null;
        this.isDisposed = true;
      }
      /**
       * Get container statistics
       */
      getStats() {
        const totalResolutions = Array.from(this.metadata.values()).reduce((sum, meta) => sum + meta.accessCount, 0);
        return {
          totalServices: this.services.size,
          singletonInstances: this.instances.size,
          activeScopes: this.scopes.size,
          totalResolutions,
          memoryUsage: this.estimateMemoryUsage()
        };
      }
      /**
       * Initialize all services in dependency order
       */
      async initializeServices() {
        const initOrder = this.calculateInitializationOrder();
        for (const serviceName of initOrder) {
          try {
            const instance = this.resolve(serviceName);
            if (instance && typeof instance.initialize === "function") {
              await instance.initialize();
            }
            this.eventBus.publish("service.initialized", {
              name: serviceName,
              timestamp: Date.now()
            });
          } catch (error) {
            this.eventBus.publish("service.initialization.failed", {
              name: serviceName,
              error: error.message,
              timestamp: Date.now()
            });
            throw error;
          }
        }
      }
      /**
       * Calculate service initialization order based on dependencies
       */
      calculateInitializationOrder() {
        const visited = /* @__PURE__ */ new Set();
        const visiting = /* @__PURE__ */ new Set();
        const order = [];
        const visit = (serviceName) => {
          if (visiting.has(serviceName)) {
            throw new Error(`Circular dependency detected involving service: ${serviceName}`);
          }
          if (visited.has(serviceName)) {
            return;
          }
          visiting.add(serviceName);
          const service = this.services.get(serviceName);
          if (service && service.dependencies) {
            for (const dep of service.dependencies) {
              visit(dep);
            }
          }
          visiting.delete(serviceName);
          visited.add(serviceName);
          order.push(serviceName);
        };
        for (const serviceName of this.services.keys()) {
          visit(serviceName);
        }
        return order;
      }
      /**
       * Get service dependency graph
       */
      getDependencyGraph() {
        const graph = {};
        for (const [name, service] of this.services) {
          graph[name] = service.dependencies || [];
        }
        return graph;
      }
      registerCoreServices() {
        this.registerSingleton("errorHandler", () => ErrorHandler.getInstance());
        this.registerSingleton("eventBus", () => this.eventBus);
      }
      resolveSingleton(name, service) {
        if (this.instances.has(name)) {
          return this.instances.get(name);
        }
        const instance = this.createInstance(name, service);
        this.instances.set(name, instance);
        return instance;
      }
      resolveTransient(name, service) {
        return this.createInstance(name, service);
      }
      resolveScoped(name, service) {
        if (!this.currentScope) {
          throw new Error(`Cannot resolve scoped service '${name}' outside of a scope`);
        }
        const scope = this.scopes.get(this.currentScope);
        if (scope.has(name)) {
          return scope.get(name);
        }
        const instance = this.createInstance(name, service);
        scope.set(name, instance);
        return instance;
      }
      createInstance(name, service) {
        const dependencies = service.dependencies || [];
        const resolvedDependencies = dependencies.map((dep) => this.resolve(dep));
        try {
          return service.factory(this);
        } catch (error) {
          throw new Error(`Failed to create instance of '${name}': ${error.message}`);
        }
      }
      checkCircularDependencies(name, visited) {
        if (visited.has(name)) {
          throw new Error(`Circular dependency detected: ${Array.from(visited).join(" -> ")} -> ${name}`);
        }
        visited.add(name);
        const service = this.services.get(name);
        if (service && service.dependencies) {
          for (const dep of service.dependencies) {
            this.checkCircularDependencies(dep, new Set(visited));
          }
        }
        visited.delete(name);
      }
      disposeInstance(instance) {
        if (instance && typeof instance.dispose === "function") {
          try {
            instance.dispose();
          } catch (error) {
            console.warn("Error disposing instance:", error);
          }
        }
      }
      estimateMemoryUsage() {
        let size = 0;
        size += this.services.size * 100;
        size += this.instances.size * 500;
        size += this.metadata.size * 200;
        return size;
      }
    };
    _ServiceLocator = class _ServiceLocator {
      static initialize(container) {
        _ServiceLocator.container = container;
      }
      static getContainer() {
        if (!_ServiceLocator.container) {
          throw new Error("ServiceLocator not initialized. Call initialize() first.");
        }
        return _ServiceLocator.container;
      }
      static resolve(name) {
        return _ServiceLocator.getContainer().resolve(name);
      }
      static isInitialized() {
        return _ServiceLocator.container !== null;
      }
      static dispose() {
        if (_ServiceLocator.container) {
          _ServiceLocator.container.dispose();
          _ServiceLocator.container = null;
        }
      }
    };
    __publicField(_ServiceLocator, "container", null);
    ServiceLocator = _ServiceLocator;
    DIContainerFactory = class {
      /**
       * Create a container for the AI Assistant plugin
       */
      static createPluginContainer(app, plugin) {
        const container = new DIContainer();
        container.registerSingleton("app", () => app);
        container.registerSingleton("plugin", () => plugin);
        container.registerSingleton("vault", () => app.vault);
        container.registerSingleton("workspace", () => app.workspace);
        container.registerSingleton("aiDispatcher", (c) => {
          const vault = c.resolve("vault");
          const pluginInstance = c.resolve("plugin");
          return new AIDispatcher(vault, pluginInstance);
        }, ["vault", "plugin"]);
        container.registerSingleton("errorHandler", () => ErrorHandler.getInstance());
        return container;
      }
      /**
       * Create a container for testing
       */
      static createTestContainer() {
        const container = new DIContainer();
        container.registerSingleton("mockService", () => ({ test: true }));
        return container;
      }
      /**
       * Create a container with enhanced service registration
       */
      static createEnhancedPluginContainer(app, plugin) {
        const container = new DIContainer();
        container.registerSingleton("app", () => app);
        container.registerSingleton("plugin", () => plugin);
        container.registerSingleton("vault", () => app.vault);
        container.registerSingleton("workspace", () => app.workspace);
        container.registerService("aiService", (c) => {
          const vault = c.resolve("vault");
          const pluginInstance = c.resolve("plugin");
          return new AIDispatcher(vault, pluginInstance);
        }, "singleton", ["vault", "plugin"]);
        container.registerSingleton("errorHandler", () => ErrorHandler.getInstance());
        container.registerSingleton("eventBus", () => globalEventBus);
        return container;
      }
    };
    ServiceRegistry = class {
      constructor(container) {
        this.container = container;
      }
      registerCoreServices() {
        this.container.registerService(
          "eventBus",
          () => globalEventBus,
          "singleton"
        );
        this.container.registerService(
          "errorBoundary",
          (c) => new ErrorBoundaryService(c.resolve("eventBus")),
          "singleton",
          ["eventBus"]
        );
        this.container.registerService(
          "configManager",
          (c) => new ConfigurationManagerService(c.resolve("eventBus")),
          "singleton",
          ["eventBus"]
        );
      }
      registerChatServices() {
        this.container.registerService(
          "chatService",
          (c) => new ChatServiceImpl(
            c.resolve("eventBus"),
            c.resolve("aiService")
          ),
          "singleton",
          ["eventBus", "aiService"]
        );
        this.container.registerService(
          "chatUIManager",
          (c) => new ChatUIManagerImpl(c.resolve("eventBus")),
          "singleton",
          ["eventBus"]
        );
        this.container.registerService(
          "streamCoordinator",
          (c) => new StreamCoordinatorImpl(
            c.resolve("eventBus"),
            c.resolve("aiService")
          ),
          "singleton",
          ["eventBus", "aiService"]
        );
      }
      registerAgentServices() {
        this.container.registerService(
          "agentService",
          (c) => new AgentServiceImpl(
            c.resolve("eventBus"),
            c.resolve("toolExecutionEngine")
          ),
          "singleton",
          ["eventBus", "toolExecutionEngine"]
        );
        this.container.registerService(
          "toolExecutionEngine",
          (c) => new ToolExecutionEngineImpl(c.resolve("eventBus")),
          "singleton",
          ["eventBus"]
        );
        this.container.registerService(
          "executionLimitManager",
          (c) => new ExecutionLimitManagerImpl(c.resolve("eventBus")),
          "singleton",
          ["eventBus"]
        );
      }
      registerUIServices() {
        this.container.registerService(
          "viewManager",
          (c) => new ViewManagerImpl(
            c.resolve("app"),
            c.resolve("eventBus")
          ),
          "singleton",
          ["app", "eventBus"]
        );
        this.container.registerService(
          "commandManager",
          (c) => new CommandManagerImpl(
            c.resolve("plugin"),
            c.resolve("eventBus")
          ),
          "singleton",
          ["plugin", "eventBus"]
        );
      }
    };
    ErrorBoundaryService = class {
      constructor(eventBus) {
        this.eventBus = eventBus;
      }
      async wrap(operation) {
        return operation();
      }
      handleError(error, context) {
      }
      getErrorStats() {
        return { totalErrors: 0, errorsByService: {}, errorsByType: {}, recentErrors: [] };
      }
      clearErrors() {
      }
    };
    ConfigurationManagerService = class {
      constructor(eventBus) {
        this.eventBus = eventBus;
      }
      get(key) {
        return void 0;
      }
      async set(key, value) {
      }
      subscribe(key, callback) {
        return () => {
        };
      }
      validate(config) {
        return { isValid: true, errors: [], warnings: [] };
      }
      export() {
        return "{}";
      }
      async import(config) {
      }
    };
    ChatServiceImpl = class {
      constructor(eventBus, aiService) {
        this.eventBus = eventBus;
        this.aiService = aiService;
      }
      async sendMessage(content) {
      }
      async regenerateMessage(messageId) {
      }
      async clearHistory() {
      }
      async getHistory() {
        return [];
      }
      async addMessage(message) {
      }
      async updateMessage(timestamp2, role, oldContent, newContent, metadata) {
      }
    };
    ChatUIManagerImpl = class {
      constructor(eventBus) {
        this.eventBus = eventBus;
      }
      createChatInterface() {
        return document.createElement("div");
      }
      updateMessageDisplay(message) {
      }
      scrollToBottom() {
      }
      showTypingIndicator() {
      }
      hideTypingIndicator() {
      }
      updateModelDisplay(modelName) {
      }
      updateReferenceNoteIndicator(isEnabled, fileName) {
      }
    };
    StreamCoordinatorImpl = class {
      constructor(eventBus, aiService) {
        this.eventBus = eventBus;
        this.aiService = aiService;
      }
      async startStream(messages) {
        return "";
      }
      stopStream() {
      }
      isStreaming() {
        return false;
      }
      getActiveStreams() {
        return [];
      }
      abortStream(streamId) {
      }
    };
    AgentServiceImpl = class {
      constructor(eventBus, toolEngine) {
        this.eventBus = eventBus;
        this.toolEngine = toolEngine;
      }
      async processResponse(response) {
        return { processedText: response, toolResults: [], hasTools: false, taskStatus: {} };
      }
      async executeTools(commands) {
        return [];
      }
      isLimitReached() {
        return false;
      }
      resetExecutionCount() {
      }
      getExecutionStats() {
        return {
          executionCount: 0,
          maxExecutions: 10,
          remaining: 10,
          averageExecutionTime: 0,
          successfulExecutions: 0,
          failedExecutions: 0,
          totalExecutions: 0
        };
      }
      isAgentModeEnabled() {
        return false;
      }
      async setAgentModeEnabled(enabled) {
      }
    };
    ToolExecutionEngineImpl = class {
      constructor(eventBus) {
        this.eventBus = eventBus;
      }
      async executeCommand(command) {
        return { success: true };
      }
      canExecute(command) {
        return true;
      }
      getExecutionStats() {
        return {
          executionCount: 0,
          maxExecutions: 10,
          remaining: 10,
          averageExecutionTime: 0,
          successfulExecutions: 0,
          failedExecutions: 0,
          totalExecutions: 0
        };
      }
      registerTool(tool) {
      }
      unregisterTool(toolName) {
      }
    };
    ExecutionLimitManagerImpl = class {
      // 1 minute
      constructor(eventBus) {
        this.eventBus = eventBus;
        __publicField(this, "currentCount", 0);
        __publicField(this, "limit", 10);
        __publicField(this, "lastResetTime", Date.now());
        __publicField(this, "autoReset", false);
        __publicField(this, "resetIntervalMs", 6e4);
      }
      isLimitReached() {
        return this.currentCount >= this.limit;
      }
      canExecute(count) {
        return this.currentCount + count <= this.limit;
      }
      addExecutions(count) {
        this.currentCount += count;
      }
      resetLimit() {
        this.currentCount = 0;
        this.lastResetTime = Date.now();
      }
      getLimit() {
        return this.limit;
      }
      setLimit(limit) {
        this.limit = limit;
      }
      getCurrentCount() {
        return this.currentCount;
      }
      getRemaining() {
        return Math.max(0, this.limit - this.currentCount);
      }
      getUsagePercentage() {
        return this.currentCount / this.limit * 100;
      }
      getStatus() {
        return {
          count: this.currentCount,
          limit: this.limit,
          remaining: this.getRemaining(),
          percentage: this.getUsagePercentage(),
          isLimitReached: this.isLimitReached(),
          lastResetTime: this.lastResetTime,
          autoReset: this.autoReset,
          resetIntervalMs: this.resetIntervalMs
        };
      }
      setAutoReset(enabled, intervalMs) {
        this.autoReset = enabled;
        if (intervalMs) this.resetIntervalMs = intervalMs;
      }
      destroy() {
      }
    };
    ViewManagerImpl = class {
      constructor(app, eventBus) {
        this.app = app;
        this.eventBus = eventBus;
      }
      registerViews() {
      }
      async activateView(type2) {
      }
      getActiveViews() {
        return [];
      }
      async closeView(type2) {
      }
    };
    CommandManagerImpl = class {
      constructor(plugin, eventBus) {
        this.plugin = plugin;
        this.eventBus = eventBus;
      }
      registerCommands() {
      }
      unregisterCommands() {
      }
      async executeCommand(id, ...args) {
      }
      getRegisteredCommands() {
        return [];
      }
    };
  }
});

// src/utils/stateManager.ts
var stateManager_exports = {};
__export(stateManager_exports, {
  StateManager: () => StateManager,
  StateUtils: () => StateUtils,
  globalStateManager: () => globalStateManager
});
var import_events, StateManager, globalStateManager, StateUtils;
var init_stateManager = __esm({
  "src/utils/stateManager.ts"() {
    import_events = require("events");
    init_lruCache();
    init_errorHandler();
    StateManager = class extends import_events.EventEmitter {
      constructor(storageKey = "ai-assistant-state") {
        super();
        this.storageKey = storageKey;
        __publicField(this, "state", {});
        __publicField(this, "stateListeners", /* @__PURE__ */ new Map());
        __publicField(this, "validators", /* @__PURE__ */ new Map());
        __publicField(this, "transformers", /* @__PURE__ */ new Map());
        __publicField(this, "persistentKeys", /* @__PURE__ */ new Set());
        __publicField(this, "debounceTimers", /* @__PURE__ */ new Map());
        __publicField(this, "snapshots");
        __publicField(this, "version", 0);
        __publicField(this, "isDisposed", false);
        this.snapshots = new LRUCache({
          maxSize: 50,
          defaultTTL: 60 * 60 * 1e3
          // 1 hour
        });
        this.loadPersistedState();
      }
      /**
       * Set a value in the state
       */
      setState(path3, value, options = {}) {
        if (this.isDisposed) {
          throw new Error("Cannot set state on disposed StateManager");
        }
        try {
          const transformer = options.transformer || this.transformers.get(path3);
          const transformedValue = transformer ? transformer(value, path3) : value;
          const validator = options.validator || this.validators.get(path3);
          if (validator) {
            const validationResult = validator(transformedValue, path3);
            if (validationResult !== true) {
              const errorMessage = typeof validationResult === "string" ? validationResult : `Invalid value for state path: ${path3}`;
              throw new Error(errorMessage);
            }
          }
          const oldValue = this.getState(path3);
          this.setNestedValue(this.state, path3, transformedValue);
          this.version++;
          if (options.persistent) {
            this.persistentKeys.add(path3);
          }
          this.createSnapshot();
          const debounceMs = options.debounceMs || 0;
          if (debounceMs > 0) {
            this.debouncedNotify(path3, transformedValue, oldValue, debounceMs);
          } else {
            this.notifyListeners(path3, transformedValue, oldValue);
          }
          if (this.persistentKeys.has(path3)) {
            this.persistState();
          }
        } catch (error) {
          errorHandler.handleError(error, {
            component: "StateManager",
            operation: "setState",
            metadata: { path: path3, valueType: typeof value }
          });
          throw error;
        }
      }
      /**
       * Get a value from the state
       */
      getState(path3, defaultValue) {
        if (this.isDisposed) {
          throw new Error("Cannot get state from disposed StateManager");
        }
        try {
          const value = this.getNestedValue(this.state, path3);
          return value !== void 0 ? value : defaultValue;
        } catch (error) {
          errorHandler.handleError(error, {
            component: "StateManager",
            operation: "getState",
            metadata: { path: path3 }
          });
          return defaultValue;
        }
      }
      /**
       * Check if a state path exists
       */
      hasState(path3) {
        return this.getNestedValue(this.state, path3) !== void 0;
      }
      /**
       * Delete a state path
       */
      deleteState(path3) {
        if (this.isDisposed) {
          throw new Error("Cannot delete state from disposed StateManager");
        }
        const oldValue = this.getState(path3);
        this.deleteNestedValue(this.state, path3);
        this.version++;
        this.persistentKeys.delete(path3);
        this.notifyListeners(path3, void 0, oldValue);
        this.createSnapshot();
        this.persistState();
      }
      /**
       * Subscribe to state changes for a specific path
       */
      subscribe(path3, listener) {
        if (!this.stateListeners.has(path3)) {
          this.stateListeners.set(path3, /* @__PURE__ */ new Set());
        }
        this.stateListeners.get(path3).add(listener);
        return () => {
          const pathListeners = this.stateListeners.get(path3);
          if (pathListeners) {
            pathListeners.delete(listener);
            if (pathListeners.size === 0) {
              this.stateListeners.delete(path3);
            }
          }
        };
      }
      /**
       * Subscribe to all state changes
       */
      subscribeAll(listener) {
        this.on("stateChange", listener);
        return () => this.off("stateChange", listener);
      }
      /**
       * Register a validator for a state path
       */
      registerValidator(path3, validator) {
        this.validators.set(path3, validator);
      }
      /**
       * Register a transformer for a state path
       */
      registerTransformer(path3, transformer) {
        this.transformers.set(path3, transformer);
      }
      /**
       * Get the entire state object (read-only)
       */
      getFullState() {
        return Object.freeze(JSON.parse(JSON.stringify(this.state)));
      }
      /**
       * Reset the entire state
       */
      resetState(newState = {}) {
        if (this.isDisposed) {
          throw new Error("Cannot reset state on disposed StateManager");
        }
        const oldState = this.getFullState();
        this.state = { ...newState };
        this.version++;
        this.createSnapshot();
        this.emit("stateReset", this.state, oldState);
        this.persistState();
      }
      /**
       * Create a snapshot of the current state
       */
      createSnapshot() {
        const snapshot = {
          timestamp: Date.now(),
          state: JSON.parse(JSON.stringify(this.state)),
          version: this.version
        };
        this.snapshots.set(`snapshot-${this.version}`, snapshot);
      }
      /**
       * Restore state from a snapshot
       */
      restoreSnapshot(version) {
        const snapshot = this.snapshots.get(`snapshot-${version}`);
        if (!snapshot) {
          return false;
        }
        const oldState = this.getFullState();
        this.state = JSON.parse(JSON.stringify(snapshot.state));
        this.version = snapshot.version;
        this.emit("stateRestored", this.state, oldState, snapshot);
        this.persistState();
        return true;
      }
      /**
       * Get available snapshots
       */
      getSnapshots() {
        return this.snapshots.values().sort((a, b) => b.timestamp - a.timestamp);
      }
      /**
       * Get current state version
       */
      getVersion() {
        return this.version;
      }
      /**
       * Batch multiple state updates
       */
      batch(updates) {
        var _a2;
        if (this.isDisposed) {
          throw new Error("Cannot batch updates on disposed StateManager");
        }
        const oldStates = /* @__PURE__ */ new Map();
        try {
          for (const update of updates) {
            oldStates.set(update.path, this.getState(update.path));
          }
          for (const update of updates) {
            this.setNestedValue(this.state, update.path, update.value);
            if ((_a2 = update.options) == null ? void 0 : _a2.persistent) {
              this.persistentKeys.add(update.path);
            }
          }
          this.version++;
          this.createSnapshot();
          for (const update of updates) {
            const oldValue = oldStates.get(update.path);
            this.notifyListeners(update.path, update.value, oldValue);
          }
          this.persistState();
        } catch (error) {
          for (const [path3, oldValue] of oldStates) {
            this.setNestedValue(this.state, path3, oldValue);
          }
          throw error;
        }
      }
      /**
       * Watch for changes to multiple paths
       */
      watch(paths, listener) {
        const unsubscribers = [];
        const changes = [];
        let debounceTimer = null;
        for (const path3 of paths) {
          const unsubscribe = this.subscribe(path3, (newValue, oldValue, changePath) => {
            changes.push({ path: changePath, newValue, oldValue });
            if (debounceTimer) {
              clearTimeout(debounceTimer);
            }
            debounceTimer = setTimeout(() => {
              if (changes.length > 0) {
                listener([...changes]);
                changes.length = 0;
              }
            }, 10);
          });
          unsubscribers.push(unsubscribe);
        }
        return () => {
          unsubscribers.forEach((unsub) => unsub());
          if (debounceTimer) {
            clearTimeout(debounceTimer);
          }
        };
      }
      /**
       * Get state statistics
       */
      getStats() {
        const totalListeners = Array.from(this.stateListeners.values()).reduce((sum, set2) => sum + set2.size, 0);
        return {
          totalKeys: this.countKeys(this.state),
          persistentKeys: this.persistentKeys.size,
          listeners: totalListeners,
          snapshots: this.snapshots.size(),
          version: this.version,
          memoryUsage: this.estimateMemoryUsage()
        };
      }
      /**
       * Dispose the state manager
       */
      dispose() {
        if (this.isDisposed) return;
        for (const timer of this.debounceTimers.values()) {
          clearTimeout(timer);
        }
        this.debounceTimers.clear();
        this.stateListeners.clear();
        this.removeAllListeners();
        this.state = {};
        this.validators.clear();
        this.transformers.clear();
        this.persistentKeys.clear();
        this.snapshots.destroy();
        this.isDisposed = true;
      }
      setNestedValue(obj, path3, value) {
        const keys = path3.split(".");
        let current = obj;
        for (let i = 0; i < keys.length - 1; i++) {
          const key = keys[i];
          if (!(key in current) || typeof current[key] !== "object") {
            current[key] = {};
          }
          current = current[key];
        }
        current[keys[keys.length - 1]] = value;
      }
      getNestedValue(obj, path3) {
        const keys = path3.split(".");
        let current = obj;
        for (const key of keys) {
          if (current === null || current === void 0 || !(key in current)) {
            return void 0;
          }
          current = current[key];
        }
        return current;
      }
      deleteNestedValue(obj, path3) {
        const keys = path3.split(".");
        let current = obj;
        for (let i = 0; i < keys.length - 1; i++) {
          const key = keys[i];
          if (!(key in current) || typeof current[key] !== "object") {
            return;
          }
          current = current[key];
        }
        delete current[keys[keys.length - 1]];
      }
      notifyListeners(path3, newValue, oldValue) {
        const pathListeners = this.stateListeners.get(path3);
        if (pathListeners) {
          for (const listener of pathListeners) {
            try {
              listener(newValue, oldValue, path3);
            } catch (error) {
              errorHandler.handleError(error, {
                component: "StateManager",
                operation: "notifyListeners",
                metadata: { path: path3 }
              });
            }
          }
        }
        this.emit("stateChange", newValue, oldValue, path3);
      }
      debouncedNotify(path3, newValue, oldValue, debounceMs) {
        const existingTimer = this.debounceTimers.get(path3);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(() => {
          this.notifyListeners(path3, newValue, oldValue);
          this.debounceTimers.delete(path3);
        }, debounceMs);
        this.debounceTimers.set(path3, timer);
      }
      loadPersistedState() {
        try {
          const stored = localStorage.getItem(this.storageKey);
          if (stored) {
            const parsed = JSON.parse(stored);
            this.state = parsed.state || {};
            this.persistentKeys = new Set(parsed.persistentKeys || []);
            this.version = parsed.version || 0;
          }
        } catch (error) {
          errorHandler.handleError(error, {
            component: "StateManager",
            operation: "loadPersistedState"
          });
        }
      }
      persistState() {
        try {
          const persistentState = {};
          for (const key of this.persistentKeys) {
            const value = this.getState(key);
            if (value !== void 0) {
              this.setNestedValue(persistentState, key, value);
            }
          }
          const toStore = {
            state: persistentState,
            persistentKeys: Array.from(this.persistentKeys),
            version: this.version,
            timestamp: Date.now()
          };
          localStorage.setItem(this.storageKey, JSON.stringify(toStore));
        } catch (error) {
          errorHandler.handleError(error, {
            component: "StateManager",
            operation: "persistState"
          });
        }
      }
      countKeys(obj, depth = 0) {
        if (depth > 10 || typeof obj !== "object" || obj === null) {
          return 0;
        }
        let count = 0;
        for (const key in obj) {
          count++;
          if (typeof obj[key] === "object" && obj[key] !== null) {
            count += this.countKeys(obj[key], depth + 1);
          }
        }
        return count;
      }
      estimateMemoryUsage() {
        try {
          return JSON.stringify(this.state).length * 2;
        } catch (e) {
          return 0;
        }
      }
    };
    globalStateManager = new StateManager();
    StateUtils = class {
      /**
       * Create a computed state that updates when dependencies change
       */
      static createComputed(stateManager, dependencies, computeFn, targetPath) {
        const updateComputed = () => {
          const values = dependencies.map((dep) => stateManager.getState(dep));
          const computed = computeFn(values);
          stateManager.setState(targetPath, computed);
        };
        updateComputed();
        const unsubscribe = stateManager.watch(dependencies, updateComputed);
        return unsubscribe;
      }
      /**
       * Create a state slice with a specific prefix
       */
      static createSlice(stateManager, prefix) {
        return {
          get: (path3, defaultValue) => stateManager.getState(`${prefix}.${path3}`, defaultValue),
          set: (path3, value, options) => stateManager.setState(`${prefix}.${path3}`, value, options),
          subscribe: (path3, listener) => stateManager.subscribe(`${prefix}.${path3}`, listener),
          delete: (path3) => stateManager.deleteState(`${prefix}.${path3}`)
        };
      }
    };
  }
});

// src/utils/streamManager.ts
var streamManager_exports = {};
__export(streamManager_exports, {
  ManagedStream: () => ManagedStream,
  StreamManager: () => StreamManager,
  StreamUtils: () => StreamUtils,
  globalStreamManager: () => globalStreamManager
});
var import_events2, StreamManager, ManagedStream, globalStreamManager, StreamUtils;
var init_streamManager = __esm({
  "src/utils/streamManager.ts"() {
    import_events2 = require("events");
    init_errorHandler();
    init_lruCache();
    StreamManager = class extends import_events2.EventEmitter {
      constructor(options = {}) {
        super();
        __publicField(this, "streams", /* @__PURE__ */ new Map());
        __publicField(this, "transformers", /* @__PURE__ */ new Map());
        __publicField(this, "filters", /* @__PURE__ */ new Map());
        __publicField(this, "streamCache");
        __publicField(this, "activeStreams", /* @__PURE__ */ new Set());
        __publicField(this, "pausedStreams", /* @__PURE__ */ new Set());
        __publicField(this, "streamPool", []);
        __publicField(this, "maxConcurrentStreams");
        __publicField(this, "defaultTimeout");
        __publicField(this, "isDisposed", false);
        this.maxConcurrentStreams = options.maxConcurrentStreams || 10;
        this.defaultTimeout = options.defaultTimeout || 3e4;
        this.streamCache = new LRUCache({
          maxSize: options.cacheSize || 50,
          defaultTTL: 5 * 60 * 1e3,
          // 5 minutes
          onEvict: (key, stream) => this.destroyStream(key)
        });
        this.setupCleanupInterval();
      }
      /**
       * Create a new managed stream
       */
      createStream(id, source, options = {}) {
        if (this.isDisposed) {
          throw new Error("Cannot create stream on disposed StreamManager");
        }
        if (this.streams.has(id)) {
          throw new Error(`Stream with id '${id}' already exists`);
        }
        if (this.activeStreams.size >= this.maxConcurrentStreams) {
          throw new Error(`Maximum concurrent streams (${this.maxConcurrentStreams}) reached`);
        }
        const streamState = {
          id,
          status: "idle",
          metrics: {
            bytesRead: 0,
            bytesWritten: 0,
            chunksProcessed: 0,
            errors: 0,
            startTime: Date.now()
          },
          options: {
            timeout: this.defaultTimeout,
            retryAttempts: 3,
            backpressureThreshold: 16384,
            // 16KB
            ...options
          },
          createdAt: Date.now(),
          lastActivity: Date.now()
        };
        this.streams.set(id, streamState);
        const actualSource = typeof source === "function" ? source() : source;
        const managedStream = new ManagedStream(id, actualSource, this, streamState);
        this.streamCache.set(id, actualSource);
        this.emit("streamCreated", id, streamState);
        return managedStream;
      }
      /**
       * Get a stream by ID
       */
      getStream(id) {
        const state = this.streams.get(id);
        const source = this.streamCache.get(id);
        if (!state || !source) {
          return null;
        }
        return new ManagedStream(id, source, this, state);
      }
      /**
       * Pause a stream
       */
      pauseStream(id) {
        const state = this.streams.get(id);
        if (!state || state.status !== "active") {
          return false;
        }
        state.status = "paused";
        state.lastActivity = Date.now();
        this.activeStreams.delete(id);
        this.pausedStreams.add(id);
        this.emit("streamPaused", id);
        return true;
      }
      /**
       * Resume a paused stream
       */
      resumeStream(id) {
        const state = this.streams.get(id);
        if (!state || state.status !== "paused") {
          return false;
        }
        if (this.activeStreams.size >= this.maxConcurrentStreams) {
          return false;
        }
        state.status = "active";
        state.lastActivity = Date.now();
        this.pausedStreams.delete(id);
        this.activeStreams.add(id);
        this.emit("streamResumed", id);
        return true;
      }
      /**
       * Destroy a stream
       */
      destroyStream(id) {
        const state = this.streams.get(id);
        if (!state) {
          return false;
        }
        try {
          state.status = "destroyed";
          state.metrics.endTime = Date.now();
          state.metrics.duration = state.metrics.endTime - state.metrics.startTime;
          this.activeStreams.delete(id);
          this.pausedStreams.delete(id);
          this.streams.delete(id);
          this.streamCache.delete(id);
          this.emit("streamDestroyed", id, state);
          return true;
        } catch (error) {
          errorHandler.handleError(error, {
            component: "StreamManager",
            operation: "destroyStream",
            metadata: { streamId: id }
          });
          return false;
        }
      }
      /**
       * Register a transformer for streams
       */
      registerTransformer(name, transformer) {
        this.transformers.set(name, transformer);
      }
      /**
       * Register a filter for streams
       */
      registerFilter(name, filter) {
        this.filters.set(name, filter);
      }
      /**
       * Get transformer by name
       */
      getTransformer(name) {
        return this.transformers.get(name);
      }
      /**
       * Get filter by name
       */
      getFilter(name) {
        return this.filters.get(name);
      }
      /**
       * Get all stream states
       */
      getAllStreams() {
        return Array.from(this.streams.values());
      }
      /**
       * Get active streams
       */
      getActiveStreams() {
        return Array.from(this.activeStreams).map((id) => this.streams.get(id));
      }
      /**
       * Get stream statistics
       */
      getStats() {
        const states = Array.from(this.streams.values());
        const totalBytesProcessed = states.reduce((sum, state) => sum + state.metrics.bytesRead + state.metrics.bytesWritten, 0);
        const completedStreams = states.filter((s) => s.status === "completed");
        const averageThroughput = completedStreams.length > 0 ? completedStreams.reduce((sum, s) => sum + (s.metrics.throughput || 0), 0) / completedStreams.length : 0;
        return {
          totalStreams: this.streams.size,
          activeStreams: this.activeStreams.size,
          pausedStreams: this.pausedStreams.size,
          completedStreams: states.filter((s) => s.status === "completed").length,
          errorStreams: states.filter((s) => s.status === "error").length,
          totalBytesProcessed,
          averageThroughput,
          cacheHitRate: this.streamCache.getStats().hitRate || 0
        };
      }
      /**
       * Cleanup inactive streams
       */
      cleanup(maxAge = 6e4) {
        const now = Date.now();
        let cleaned = 0;
        for (const [id, state] of this.streams) {
          if (now - state.lastActivity > maxAge && (state.status === "completed" || state.status === "error")) {
            this.destroyStream(id);
            cleaned++;
          }
        }
        return cleaned;
      }
      /**
       * Dispose the stream manager
       */
      dispose() {
        if (this.isDisposed) return;
        for (const id of this.streams.keys()) {
          this.destroyStream(id);
        }
        this.streams.clear();
        this.transformers.clear();
        this.filters.clear();
        this.activeStreams.clear();
        this.pausedStreams.clear();
        this.streamPool.length = 0;
        this.streamCache.destroy();
        this.removeAllListeners();
        this.isDisposed = true;
      }
      setupCleanupInterval() {
        setInterval(() => {
          if (!this.isDisposed) {
            this.cleanup();
          }
        }, 6e4);
      }
      updateStreamMetrics(id, metrics) {
        const state = this.streams.get(id);
        if (state) {
          Object.assign(state.metrics, metrics);
          state.lastActivity = Date.now();
          if (state.metrics.duration && state.metrics.duration > 0) {
            const totalBytes = state.metrics.bytesRead + state.metrics.bytesWritten;
            state.metrics.throughput = totalBytes / (state.metrics.duration / 1e3);
          }
        }
      }
      updateStreamStatus(id, status) {
        const state = this.streams.get(id);
        if (state) {
          const oldStatus = state.status;
          state.status = status;
          state.lastActivity = Date.now();
          if (status === "active" && oldStatus !== "active") {
            this.activeStreams.add(id);
            this.pausedStreams.delete(id);
          } else if (status === "paused" && oldStatus !== "paused") {
            this.activeStreams.delete(id);
            this.pausedStreams.add(id);
          } else if (status === "completed" || status === "error" || status === "destroyed") {
            this.activeStreams.delete(id);
            this.pausedStreams.delete(id);
            if (status === "completed") {
              state.metrics.endTime = Date.now();
              state.metrics.duration = state.metrics.endTime - state.metrics.startTime;
            }
          }
          this.emit("streamStatusChanged", id, status, oldStatus);
        }
      }
    };
    ManagedStream = class extends import_events2.EventEmitter {
      constructor(id, source, manager, state) {
        super();
        this.id = id;
        this.source = source;
        this.manager = manager;
        this.state = state;
        __publicField(this, "reader", null);
        __publicField(this, "isReading", false);
        __publicField(this, "backpressureActive", false);
        this.setupTimeout();
      }
      /**
       * Start reading from the stream
       */
      async start() {
        if (this.isReading) {
          throw new Error("Stream is already reading");
        }
        try {
          this.manager.updateStreamStatus(this.id, "active");
          this.reader = this.source.getReader();
          this.isReading = true;
          await this.readLoop();
        } catch (error) {
          this.handleError(error);
        }
      }
      /**
       * Transform stream data
       */
      transform(transformer) {
        const actualTransformer = typeof transformer === "string" ? this.manager.getTransformer(transformer) : transformer;
        if (!actualTransformer) {
          throw new Error(`Transformer not found: ${transformer}`);
        }
        const transformedSource = new ReadableStream({
          start: (controller) => {
            this.on("data", async (chunk) => {
              try {
                const transformed = await actualTransformer(chunk);
                controller.enqueue(transformed);
              } catch (error) {
                controller.error(error);
              }
            });
            this.on("end", () => controller.close());
            this.on("error", (error) => controller.error(error));
          }
        });
        return this.manager.createStream(`${this.id}-transformed`, transformedSource, this.state.options);
      }
      /**
       * Filter stream data
       */
      filter(filter) {
        const actualFilter = typeof filter === "string" ? this.manager.getFilter(filter) : filter;
        if (!actualFilter) {
          throw new Error(`Filter not found: ${filter}`);
        }
        const filteredSource = new ReadableStream({
          start: (controller) => {
            this.on("data", async (chunk) => {
              try {
                const shouldInclude = await actualFilter(chunk);
                if (shouldInclude) {
                  controller.enqueue(chunk);
                }
              } catch (error) {
                controller.error(error);
              }
            });
            this.on("end", () => controller.close());
            this.on("error", (error) => controller.error(error));
          }
        });
        return this.manager.createStream(`${this.id}-filtered`, filteredSource, this.state.options);
      }
      /**
       * Pause the stream
       */
      pause() {
        return this.manager.pauseStream(this.id);
      }
      /**
       * Resume the stream
       */
      resume() {
        return this.manager.resumeStream(this.id);
      }
      /**
       * Destroy the stream
       */
      destroy() {
        if (this.reader) {
          this.reader.releaseLock();
          this.reader = null;
        }
        this.isReading = false;
        return this.manager.destroyStream(this.id);
      }
      /**
       * Get stream metrics
       */
      getMetrics() {
        return { ...this.state.metrics };
      }
      /**
       * Get stream status
       */
      getStatus() {
        return this.state.status;
      }
      async readLoop() {
        if (!this.reader) return;
        try {
          while (this.isReading && this.state.status === "active") {
            const { done, value } = await this.reader.read();
            if (done) {
              this.manager.updateStreamStatus(this.id, "completed");
              this.emit("end");
              break;
            }
            this.state.metrics.chunksProcessed++;
            if (typeof value === "string") {
              this.state.metrics.bytesRead += value.length;
            } else if (value instanceof Uint8Array) {
              this.state.metrics.bytesRead += value.length;
            }
            this.manager.updateStreamMetrics(this.id, this.state.metrics);
            if (this.state.options.backpressureThreshold && this.state.metrics.bytesRead > this.state.options.backpressureThreshold && !this.backpressureActive) {
              this.backpressureActive = true;
              this.emit("backpressure");
              await this.handleBackpressure();
            }
            this.emit("data", value);
            await new Promise((resolve) => setImmediate(resolve));
          }
        } catch (error) {
          this.handleError(error);
        } finally {
          if (this.reader) {
            this.reader.releaseLock();
            this.reader = null;
          }
          this.isReading = false;
        }
      }
      async handleBackpressure() {
        await new Promise((resolve) => setTimeout(resolve, 100));
        this.backpressureActive = false;
      }
      handleError(error) {
        this.state.metrics.errors++;
        this.manager.updateStreamStatus(this.id, "error");
        this.manager.updateStreamMetrics(this.id, this.state.metrics);
        errorHandler.handleError(error, {
          component: "ManagedStream",
          operation: "readLoop",
          metadata: { streamId: this.id }
        });
        this.emit("error", error);
      }
      setupTimeout() {
        if (this.state.options.timeout) {
          setTimeout(() => {
            if (this.state.status === "active" || this.state.status === "idle") {
              this.handleError(new Error(`Stream timeout after ${this.state.options.timeout}ms`));
            }
          }, this.state.options.timeout);
        }
      }
    };
    globalStreamManager = new StreamManager();
    StreamUtils = class {
      /**
       * Create a stream from an array
       */
      static fromArray(items) {
        let index = 0;
        return new ReadableStream({
          pull(controller) {
            if (index < items.length) {
              controller.enqueue(items[index++]);
            } else {
              controller.close();
            }
          }
        });
      }
      /**
       * Create a stream from a generator
       */
      static fromGenerator(generator) {
        return new ReadableStream({
          pull(controller) {
            const { done, value } = generator.next();
            if (done) {
              controller.close();
            } else {
              controller.enqueue(value);
            }
          }
        });
      }
      /**
       * Merge multiple streams
       */
      static merge(...streams) {
        return new ReadableStream({
          start(controller) {
            let activeStreams = streams.length;
            streams.forEach((stream) => {
              const reader = stream.getReader();
              const pump = async () => {
                try {
                  while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                      activeStreams--;
                      if (activeStreams === 0) {
                        controller.close();
                      }
                      break;
                    }
                    controller.enqueue(value);
                  }
                } catch (error) {
                  controller.error(error);
                } finally {
                  reader.releaseLock();
                }
              };
              pump();
            });
          }
        });
      }
      /**
       * Convert stream to array
       */
      static async toArray(stream) {
        const reader = stream.getReader();
        const chunks = [];
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
          }
        } finally {
          reader.releaseLock();
        }
        return chunks;
      }
    };
  }
});

// tests/testRunner.ts
var testRunner_exports = {};
__export(testRunner_exports, {
  registerTestCommands: () => registerTestCommands
});
function registerTestCommands(plugin) {
  plugin.addCommand({
    id: "test-basic-indexeddb",
    name: "Test: Basic IndexedDB Functionality",
    callback: async () => {
      try {
        new import_obsidian36.Notice("Testing basic IndexedDB functionality...");
        await runBasicIndexedDBTest();
        new import_obsidian36.Notice("\u2705 IndexedDB test completed successfully!");
      } catch (error) {
        new import_obsidian36.Notice(`\u274C IndexedDB test failed: ${error.message}`);
        console.error("IndexedDB test failed:", error);
      }
    }
  });
  async function runBasicIndexedDBTest() {
    try {
      const dbName = "test-db-" + Date.now();
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onerror = () => reject(new Error("Failed to open test database"));
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
          const db2 = event.target.result;
          const store = db2.createObjectStore("test", { keyPath: "id" });
        };
      });
      await new Promise((resolve, reject) => {
        const transaction = db.transaction(["test"], "readwrite");
        const store = transaction.objectStore("test");
        const request = store.put({ id: 1, name: "Hello IndexedDB" });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error("Failed to write test data"));
      });
      const result = await new Promise((resolve, reject) => {
        const transaction = db.transaction(["test"], "readonly");
        const store = transaction.objectStore("test");
        const request = store.get(1);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(new Error("Failed to read test data"));
      });
      db.close();
      indexedDB.deleteDatabase(dbName);
      console.log("\u2705 IndexedDB basic test: SUCCESS", result);
    } catch (error) {
      console.error("\u274C IndexedDB basic test: ERROR", error);
      throw error;
    }
  }
  console.log("Test commands registered for basic functionality debugging");
}
var import_obsidian36;
var init_testRunner = __esm({
  "tests/testRunner.ts"() {
    import_obsidian36 = require("obsidian");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian37 = require("obsidian");
init_types();

// src/settings/SettingTab.ts
var import_obsidian31 = require("obsidian");

// src/components/commands/viewCommands.ts
init_pluginUtils();

// src/utils/viewManager.ts
async function activateView(app, viewType, reveal = true) {
  app.workspace.detachLeavesOfType(viewType);
  let leaf = app.workspace.getRightLeaf(false) || app.workspace.getLeaf(true);
  await leaf.setViewState({
    type: viewType,
    active: true
  });
  if (reveal) {
    app.workspace.revealLeaf(leaf);
  }
}

// src/chat.ts
var import_obsidian25 = require("obsidian");

// src/components/chat/ChatHistoryManager.ts
var import_obsidian7 = require("obsidian");
var ChatHistoryManager = class {
  /**
   * @param vault The Obsidian Vault instance
   * @param pluginId The plugin ID (used for folder path)
   * @param historyFilePath Optional custom file path for history storage
   */
  constructor(vault, pluginId, historyFilePath) {
    __publicField(this, "vault");
    __publicField(this, "historyFilePath");
    __publicField(this, "history", []);
    __publicField(this, "isLoaded", false);
    this.vault = vault;
    let effectivePluginId = pluginId;
    if (!pluginId) {
      console.error("CRITICAL: ChatHistoryManager instantiated without pluginId! Using placeholder. This will likely lead to incorrect file paths.");
      effectivePluginId = "unknown-plugin-id-error";
    }
    const fPath = historyFilePath || "chat-history.json";
    this.historyFilePath = (0, import_obsidian7.normalizePath)(`.obsidian/plugins/${effectivePluginId}/${fPath}`);
    if (typeof window !== "undefined" && window.Notice) {
    }
  }
  /**
   * Ensures the directory for the history file exists, creating it if needed.
   */
  async ensureDirectoryExists() {
    const dirPath = this.historyFilePath.substring(0, this.historyFilePath.lastIndexOf("/"));
    if (!dirPath) return;
    try {
      const abstractFile = this.vault.getAbstractFileByPath(dirPath);
      if (abstractFile === null) {
        await this.vault.createFolder(dirPath);
      } else if (!(abstractFile instanceof import_obsidian7.TFolder)) {
        console.error(`Path ${dirPath} exists but is not a folder.`);
        throw new Error(`Path ${dirPath} exists but is not a folder.`);
      }
    } catch (e) {
      if (e.message && e.message.toLowerCase().includes("folder already exists")) {
        return;
      }
      console.error(`Failed to ensure directory ${dirPath} exists:`, e);
      throw e;
    }
  }
  /**
   * Loads chat history from the history file.
   * If the file does not exist or is invalid, returns an empty array.
   * @returns Promise resolving to the chat history array
   */
  async loadHistory() {
    try {
      const exists = await this.vault.adapter.exists(this.historyFilePath);
      if (exists) {
        const data = await this.vault.adapter.read(this.historyFilePath);
        try {
          this.history = JSON.parse(data);
        } catch (parseError) {
          console.error("Failed to parse chat history:", parseError);
          this.history = [];
        }
      } else {
        this.history = [];
      }
    } catch (e) {
      console.error("Failed to load chat history:", e);
      this.history = [];
    }
    return this.history;
  }
  /**
   * Adds a new message to the chat history and saves it.
   * @param message The ChatMessage to add
   */
  async addMessage(message) {
    const currentHistory = await this.loadHistory();
    currentHistory.push(message);
    this.history = currentHistory;
    await this.saveHistory();
  }
  /**
   * Returns the current chat history (loads from disk if needed).
   * @returns Promise resolving to the chat history array
   */
  async getHistory() {
    return await this.loadHistory();
  }
  /**
   * Clears the chat history and saves the empty history.
   */
  async clearHistory() {
    this.history = [];
    await this.saveHistory();
  }
  /**
   * Deletes a specific message from the chat history by timestamp, sender, and content.
   * @param timestamp The timestamp of the message to delete
   * @param sender The sender of the message to delete
   * @param content The content of the message to delete
   */
  async deleteMessage(timestamp2, sender, content) {
    await this.loadHistory();
    const index = this.history.findIndex(
      (msg) => msg.timestamp === timestamp2 && msg.sender === sender && msg.content === content
    );
    if (index !== -1) {
      this.history.splice(index, 1);
      await this.saveHistory();
    }
  }
  /**
   * Updates a specific message in the chat history.
   * Optionally updates reasoning, taskStatus, and toolResults.
   * @param timestamp The timestamp of the message to update
   * @param sender The sender of the message to update
   * @param oldContent The old content to match
   * @param newContent The new content to set
   * @param enhancedData Optional additional fields to update
   */
  async updateMessage(timestamp2, sender, oldContent, newContent, enhancedData) {
    await this.loadHistory();
    const message = this.history.find(
      (msg) => msg.timestamp === timestamp2 && msg.sender === sender && msg.content === oldContent
    );
    if (message) {
      message.content = newContent;
      if (enhancedData) {
        if ("reasoning" in enhancedData) message.reasoning = enhancedData.reasoning;
        if ("taskStatus" in enhancedData) message.taskStatus = enhancedData.taskStatus;
        if ("toolResults" in enhancedData) message.toolResults = enhancedData.toolResults;
      }
      await this.saveHistory();
    } else {
    }
  }
  /**
   * Saves the current chat history to the history file.
   * Ensures the directory exists before writing.
   */
  async saveHistory() {
    try {
      await this.ensureDirectoryExists();
      const data = JSON.stringify(this.history, null, 2);
      const abstractTarget = this.vault.getAbstractFileByPath(this.historyFilePath);
      if (abstractTarget instanceof import_obsidian7.TFolder) {
        throw new Error(`Path ${this.historyFilePath} is a directory, not a file.`);
      }
      await this.vault.adapter.write(this.historyFilePath, data);
      if (!abstractTarget || !(abstractTarget instanceof import_obsidian7.TFile)) {
        await this.vault.adapter.exists(this.historyFilePath);
      }
    } catch (e) {
      console.error(`Failed to save history to ${this.historyFilePath}:`, e);
      throw e;
    }
  }
};

// src/components/chat/Message.ts
var import_obsidian18 = require("obsidian");
init_Buttons();
init_MessageRenderer();
init_eventHandlers();
async function createMessageElement(app, role, content, chatHistoryManager, plugin, regenerateCallback, parentComponent, messageData) {
  const messageEl = document.createElement("div");
  messageEl.addClass("ai-chat-message", role);
  const messageContainer = messageEl.createDiv("message-container");
  messageEl.dataset.rawContent = content;
  messageEl.dataset.timestamp = (/* @__PURE__ */ new Date()).toISOString();
  if (messageData) {
    messageEl.dataset.messageData = JSON.stringify(messageData);
  }
  const messageRenderer = new MessageRenderer(app);
  let contentEl = null;
  if (role === "assistant") {
    if (messageData && (messageData.reasoning || messageData.taskStatus)) {
      messageRenderer.updateMessageWithEnhancedData(messageEl, {
        ...messageData,
        role: "assistant",
        content
      }, parentComponent);
    }
    if (messageData && messageData.toolResults && messageData.toolResults.length > 0) {
      contentEl = messageEl.querySelector(".message-content");
      if (!contentEl) {
        contentEl = messageContainer.createDiv("message-content");
      }
      await messageRenderer.renderMessage({
        ...messageData,
        role: "assistant",
        content
      }, messageEl, parentComponent);
    } else if (!(messageData == null ? void 0 : messageData.reasoning) && !(messageData == null ? void 0 : messageData.taskStatus)) {
      contentEl = messageEl.querySelector(".message-content");
      if (!contentEl) {
        contentEl = messageContainer.createDiv("message-content");
      }
      await import_obsidian18.MarkdownRenderer.render(app, content, contentEl, "", parentComponent);
    }
  } else {
    contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) {
      contentEl = messageContainer.createDiv("message-content");
    }
    await import_obsidian18.MarkdownRenderer.render(app, content, contentEl, "", parentComponent);
  }
  if (!contentEl) {
    contentEl = messageEl.querySelector(".message-content");
    if (!contentEl) {
      contentEl = messageContainer.createDiv("message-content");
    }
  }
  const actionsEl = messageContainer.createDiv("message-actions");
  actionsEl.classList.add("hidden");
  messageEl.addEventListener("mouseenter", () => {
    actionsEl.classList.remove("hidden");
    actionsEl.classList.add("visible");
  });
  messageEl.addEventListener("mouseleave", () => {
    actionsEl.classList.remove("visible");
    actionsEl.classList.add("hidden");
  });
  actionsEl.appendChild(createActionButton("Copy", "Copy message (including tool results)", handleCopyMessage(messageEl, plugin)));
  actionsEl.appendChild(createActionButton("Edit", "Edit message", handleEditMessage(messageEl, chatHistoryManager, plugin)));
  actionsEl.appendChild(createActionButton("Delete", "Delete message", handleDeleteMessage(messageEl, chatHistoryManager, app)));
  if (role === "assistant") {
    actionsEl.appendChild(createActionButton("Regenerate", "Regenerate this response", handleRegenerateMessage(messageEl, regenerateCallback)));
  }
  messageContainer.appendChild(actionsEl);
  return messageEl;
}

// src/components/chat/ui.ts
function createChatUI(app, contentEl) {
  const fadedHelp = contentEl.createDiv();
  fadedHelp.setText("Tip: Type /help or press Ctrl+Shift+H for chat commands and shortcuts. Use Ctrl+Shift+X to clear chat and Ctrl+Shift+C to copy.");
  fadedHelp.style.textAlign = "center";
  fadedHelp.style.opacity = "0.6";
  fadedHelp.style.fontSize = "0.95em";
  fadedHelp.style.margin = "0.5em 0 0.2em 0";
  const topButtonContainer = contentEl.createDiv("ai-chat-buttons");
  const settingsButton = document.createElement("button");
  settingsButton.setText("Settings");
  settingsButton.setAttribute("aria-label", "Toggle model settings");
  topButtonContainer.appendChild(settingsButton);
  const copyAllButton = document.createElement("button");
  copyAllButton.textContent = "Copy All";
  topButtonContainer.appendChild(copyAllButton);
  const saveNoteButton = document.createElement("button");
  saveNoteButton.textContent = "Save as Note";
  topButtonContainer.appendChild(saveNoteButton);
  const clearButton = document.createElement("button");
  clearButton.textContent = "Clear Chat";
  topButtonContainer.appendChild(clearButton);
  const referenceNoteButton = document.createElement("button");
  referenceNoteButton.setText("\u{1F4DD}");
  referenceNoteButton.setAttribute("aria-label", "Toggle referencing current note");
  referenceNoteButton.addClass("ai-chat-reference-button");
  referenceNoteButton.style.fontSize = "0.85em";
  referenceNoteButton.style.fontFamily = "inherit";
  referenceNoteButton.style.width = "1.8em";
  referenceNoteButton.style.height = "1.8em";
  referenceNoteButton.style.marginBottom = "0.2em";
  referenceNoteButton.style.opacity = "0.7";
  topButtonContainer.appendChild(referenceNoteButton);
  const referenceNoteIndicator = document.createElement("div");
  referenceNoteIndicator.className = "ai-reference-note-indicator";
  referenceNoteIndicator.style.textAlign = "center";
  referenceNoteIndicator.style.opacity = "0.5";
  referenceNoteIndicator.style.fontSize = "0.85em";
  referenceNoteIndicator.style.margin = "0.1em 0 0.2em 0";
  referenceNoteIndicator.style.display = "none";
  topButtonContainer.appendChild(referenceNoteIndicator);
  const modelNameDisplay = document.createElement("div");
  modelNameDisplay.className = "ai-model-name-display";
  modelNameDisplay.style.textAlign = "center";
  modelNameDisplay.style.opacity = "0.7";
  modelNameDisplay.style.fontSize = "0.75em";
  modelNameDisplay.style.margin = "0.2em 0 0.5em 0";
  modelNameDisplay.style.fontWeight = "bold";
  topButtonContainer.appendChild(modelNameDisplay);
  const messagesContainer = contentEl.createDiv("ai-chat-messages");
  messagesContainer.setAttribute("tabindex", "0");
  const toolContinuationContainer = contentEl.createDiv("ai-tool-continuation-container");
  toolContinuationContainer.style.display = "none";
  const inputContainer = contentEl.createDiv("ai-chat-input-container");
  const textarea = inputContainer.createEl("textarea", {
    cls: "ai-chat-input",
    attr: {
      placeholder: "Type your message...",
      rows: "3"
    }
  });
  const sendButton = inputContainer.createEl("button", {
    text: "Send",
    cls: "mod-cta"
  });
  const stopButton = inputContainer.createEl("button", {
    text: "Stop"
  });
  stopButton.classList.add("hidden");
  stopButton.disabled = false;
  stopButton.style.pointerEvents = "";
  stopButton.tabIndex = 0;
  stopButton.onclick = null;
  stopButton.style.zIndex = "10";
  stopButton.title = "Stop AI response";
  const helpButton = inputContainer.createEl("button", {
    text: "?"
  });
  helpButton.setAttr("aria-label", "Show chat help");
  helpButton.style.fontSize = "0.9em";
  helpButton.style.width = "1.8em";
  helpButton.style.height = "1.8em";
  helpButton.style.marginBottom = "0.2em";
  helpButton.style.opacity = "0.7";
  helpButton.style.position = "absolute";
  helpButton.style.right = "0.5em";
  helpButton.style.top = "-2.2em";
  helpButton.style.zIndex = "2";
  const agentModeButton = inputContainer.createEl("button", {
    text: "\u{1F916}"
  });
  agentModeButton.setAttr("aria-label", "Toggle Agent Mode");
  agentModeButton.style.fontSize = "0.9em";
  agentModeButton.style.width = "1.8em";
  agentModeButton.style.height = "1.8em";
  agentModeButton.style.marginBottom = "0.2em";
  agentModeButton.style.opacity = "0.7";
  agentModeButton.style.position = "absolute";
  agentModeButton.style.right = "2.8em";
  agentModeButton.style.top = "-2.2em";
  agentModeButton.style.zIndex = "2";
  agentModeButton.classList.add("ai-agent-mode-btn");
  function setAgentModeActive(isActive) {
    if (isActive) {
      agentModeButton.classList.add("active");
    } else {
      agentModeButton.classList.remove("active");
    }
  }
  agentModeButton.setActive = setAgentModeActive;
  inputContainer.appendChild(agentModeButton);
  inputContainer.style.position = "relative";
  [topButtonContainer.querySelectorAll("button")].forEach((btns) => {
    btns.forEach((btn) => {
      btn.style.fontSize = "0.85em";
      btn.style.fontFamily = "inherit";
    });
  });
  return {
    contentEl,
    fadedHelp,
    topButtonContainer,
    settingsButton,
    copyAllButton,
    saveNoteButton,
    clearButton,
    messagesContainer,
    toolContinuationContainer,
    inputContainer,
    textarea,
    sendButton,
    stopButton,
    helpButton,
    agentModeButton,
    referenceNoteButton,
    referenceNoteIndicator,
    modelNameDisplay
  };
}

// src/chat.ts
init_eventHandlers();
init_chatPersistence();

// src/utils/messageContentParser.ts
function parseToolDataFromContent(content) {
  const toolDataRegex = /```ai-tool-execution\n([\s\S]*?)\n```/g;
  const match = toolDataRegex.exec(content);
  if (match) {
    try {
      return JSON.parse(match[1]);
    } catch (e) {
      console.error("Failed to parse tool data:", e);
    }
  }
  return null;
}
function cleanContentFromToolData(content) {
  let cleanContent = content.replace(/```ai-tool-execution\n[\s\S]*?\n```\n?/g, "");
  cleanContent = cleanContent.replace(/\n\n\*\*Tool Execution:\*\*[\s\S]*?(?=\n\n\*\*Tool Execution:\*\*|\n\n[^*]|$)/g, "");
  return cleanContent.trim();
}

// src/components/chat/chatHistoryUtils.ts
async function renderChatHistory({
  messagesContainer,
  loadedHistory,
  chatHistoryManager,
  plugin,
  regenerateResponse,
  scrollToBottom = true
}) {
  messagesContainer.empty();
  for (const msg of loadedHistory) {
    if (msg.sender === "user" || msg.sender === "assistant") {
      const toolData = parseToolDataFromContent(msg.content);
      let messageData = msg;
      let cleanContent = msg.content;
      if (toolData) {
        messageData = {
          ...msg,
          toolResults: toolData.toolResults,
          reasoning: toolData.reasoning,
          taskStatus: toolData.taskStatus
        };
        cleanContent = cleanContentFromToolData(msg.content);
        messageData.content = cleanContent;
      }
      const messageEl = await createMessageElement(
        plugin.app,
        msg.sender,
        cleanContent,
        chatHistoryManager,
        plugin,
        regenerateResponse,
        plugin,
        // Pass plugin again for legacy compatibility
        messageData
        // Pass the full message data for enhanced rendering
      );
      messageEl.dataset.timestamp = msg.timestamp;
      messagesContainer.appendChild(messageEl);
    }
  }
  if (scrollToBottom) {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

// src/components/agent/CommandParser.ts
init_toolcollect();
var CommandParser = class {
  /**
   * @param plugin Optional plugin instance for debug logging.
   */
  constructor(plugin) {
    this.plugin = plugin;
    __publicField(this, "validActions");
    this.validActions = getAllToolNames();
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Constructor - Valid actions loaded:", this.validActions);
    }
  }
  /**
   * Parse AI response to extract tool commands and regular text.
   * @param response The AI response string.
   * @returns Object containing separated text and commands.
   */
  parseResponse(response) {
    const commands = [];
    let cleanText = response;
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Parsing response:", response);
      this.plugin.debugLog("debug", "[CommandParser] Valid actions:", this.validActions);
    }
    const extractedCommands = this.extractCommands(response);
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Extracted commands:", extractedCommands);
    }
    for (const command of extractedCommands) {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Validating command:", command.command);
      }
      if (this.validateCommand(command.command)) {
        if (this.plugin) {
          this.plugin.debugLog("debug", "[CommandParser] Command is valid, adding to commands");
        }
        commands.push(command.command);
        cleanText = cleanText.replace(command.originalText, "").trim();
      } else {
        if (this.plugin) {
          this.plugin.debugLog("debug", "[CommandParser] Command is invalid");
        }
      }
    }
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Final commands:", commands);
    }
    return {
      text: cleanText,
      commands
    };
  }
  /**
   * Validate that a command has the required structure and is a known action.
   * @param command The command to validate.
   * @returns True if command is valid.
   */
  validateCommand(command) {
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] validateCommand called with:", command);
    }
    if (!command || typeof command !== "object") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command is not an object");
      }
      return false;
    }
    if (!command.action || typeof command.action !== "string") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command missing action field:", command.action);
      }
      return false;
    }
    if (!command.parameters || typeof command.parameters !== "object") {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command missing parameters field:", command.parameters);
      }
      return false;
    }
    if (!this.validActions.includes(command.action)) {
      if (this.plugin) {
        this.plugin.debugLog("debug", "[CommandParser] Command action not in valid actions:", command.action, "Valid actions:", this.validActions);
      }
      return false;
    }
    if (this.plugin) {
      this.plugin.debugLog("debug", "[CommandParser] Command is valid");
    }
    return true;
  }
  /**
   * Extract JSON commands from text using several patterns.
   * Handles both inline and code block JSON, as well as "thought" objects.
   * @param text The text to extract commands from.
   * @returns Array of extracted commands with their original text.
   */
  extractCommands(text) {
    var _a2, _b, _c, _d;
    const commands = [];
    try {
      const parsed = JSON.parse(text.trim());
      if (Array.isArray(parsed)) {
        for (const item of parsed) {
          if (item && typeof item === "object" && item.action) {
            let parameters = item.parameters;
            if (!parameters) {
              parameters = { ...item };
              delete parameters.action;
              delete parameters.requestId;
            }
            commands.push({
              command: {
                action: item.action,
                parameters,
                requestId: item.requestId || this.generateRequestId(),
                finished: item.finished || false
              },
              originalText: JSON.stringify(item)
            });
          } else if (item && typeof item === "object" && item.thought && item.nextTool) {
            commands.push({
              command: {
                action: "thought",
                parameters: {
                  thought: item.thought,
                  nextTool: item.nextTool,
                  nextActionDescription: item.nextActionDescription,
                  step: item.step,
                  totalSteps: item.totalSteps
                },
                requestId: this.generateRequestId(),
                finished: ((_a2 = item.nextTool) == null ? void 0 : _a2.toLowerCase()) === "finished"
              },
              originalText: JSON.stringify(item)
            });
          }
        }
        return commands;
      } else if (parsed.action) {
        let parameters = parsed.parameters;
        if (!parameters) {
          parameters = { ...parsed };
          delete parameters.action;
          delete parameters.requestId;
        }
        commands.push({
          command: {
            action: parsed.action,
            parameters,
            requestId: parsed.requestId || this.generateRequestId(),
            finished: parsed.finished || false
          },
          originalText: text.trim()
        });
        return commands;
      } else if (parsed.thought && parsed.nextTool) {
        commands.push({
          command: {
            action: "thought",
            parameters: {
              thought: parsed.thought,
              nextTool: parsed.nextTool,
              nextActionDescription: parsed.nextActionDescription,
              step: parsed.step,
              totalSteps: parsed.totalSteps
            },
            requestId: this.generateRequestId(),
            finished: ((_b = parsed.nextTool) == null ? void 0 : _b.toLowerCase()) === "finished"
          },
          originalText: text.trim()
        });
        return commands;
      }
    } catch (error) {
    }
    if (commands.length === 0) {
      const jsonObjects = this.extractIndividualJsonObjects(text);
      for (const jsonText of jsonObjects) {
        try {
          const parsed = JSON.parse(jsonText);
          if (parsed.action) {
            let parameters = parsed.parameters;
            if (!parameters) {
              parameters = { ...parsed };
              delete parameters.action;
              delete parameters.requestId;
            }
            commands.push({
              command: {
                action: parsed.action,
                parameters,
                requestId: parsed.requestId || this.generateRequestId(),
                finished: parsed.finished || false
              },
              originalText: jsonText
            });
          } else if (parsed.thought && parsed.nextTool) {
            commands.push({
              command: {
                action: "thought",
                parameters: {
                  thought: parsed.thought,
                  nextTool: parsed.nextTool,
                  nextActionDescription: parsed.nextActionDescription,
                  step: parsed.step,
                  totalSteps: parsed.totalSteps
                },
                requestId: this.generateRequestId(),
                finished: ((_c = parsed.nextTool) == null ? void 0 : _c.toLowerCase()) === "finished"
              },
              originalText: jsonText
            });
          }
        } catch (error) {
          continue;
        }
      }
    }
    const patterns = [
      /```json\s*(\{[\s\S]*?\})\s*```/g,
      // ```json ... ```
      /```\s*(\{[\s\S]*?\})\s*```/g,
      // ``` ... ```
      /(\{[\s\S]*?\})/g
      // Inline {...}
    ];
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const jsonText = match[1];
        const originalText = match[0];
        try {
          const parsed = JSON.parse(jsonText);
          if (parsed.action) {
            let parameters = parsed.parameters;
            if (!parameters) {
              parameters = { ...parsed };
              delete parameters.action;
              delete parameters.requestId;
            }
            commands.push({
              command: {
                action: parsed.action,
                parameters,
                requestId: parsed.requestId || this.generateRequestId(),
                finished: parsed.finished || false
              },
              originalText
            });
          } else if (parsed.thought && parsed.nextTool) {
            commands.push({
              command: {
                action: "thought",
                parameters: {
                  thought: parsed.thought,
                  nextTool: parsed.nextTool,
                  nextActionDescription: parsed.nextActionDescription,
                  step: parsed.step,
                  totalSteps: parsed.totalSteps
                },
                requestId: this.generateRequestId(),
                finished: ((_d = parsed.nextTool) == null ? void 0 : _d.toLowerCase()) === "finished"
              },
              originalText
            });
          }
        } catch (error) {
          continue;
        }
      }
      pattern.lastIndex = 0;
    }
    return commands;
  }
  /**
   * Extract individual JSON objects from text with proper brace balancing.
   * @param text The text containing multiple JSON objects.
   * @returns Array of individual JSON object strings.
   */
  extractIndividualJsonObjects(text) {
    const jsonObjects = [];
    let braceCount = 0;
    let currentObject = "";
    let inString = false;
    let escapeNext = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (escapeNext) {
        currentObject += char;
        escapeNext = false;
        continue;
      }
      if (char === "\\" && inString) {
        currentObject += char;
        escapeNext = true;
        continue;
      }
      if (char === '"' && !escapeNext) {
        inString = !inString;
        currentObject += char;
        continue;
      }
      if (!inString) {
        if (char === "{") {
          if (braceCount === 0) {
            currentObject = char;
          } else {
            currentObject += char;
          }
          braceCount++;
        } else if (char === "}") {
          currentObject += char;
          braceCount--;
          if (braceCount === 0 && currentObject.trim()) {
            jsonObjects.push(currentObject.trim());
            currentObject = "";
          }
        } else if (braceCount > 0) {
          currentObject += char;
        }
      } else {
        currentObject += char;
      }
    }
    return jsonObjects;
  }
  /**
   * Generate a unique request ID for tool commands.
   * @returns A unique request ID string.
   */
  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/components/agent/ToolRegistry.ts
init_logger();
var ToolRegistry = class {
  /**
   * @param plugin The plugin instance (for settings, logging, and app access)
   */
  constructor(plugin) {
    __publicField(this, "tools", /* @__PURE__ */ new Map());
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  /**
   * Registers a tool instance by its name.
   * @param tool The tool instance to register
   */
  register(tool) {
    var _a2;
    this.tools.set(tool.name, tool);
    if (this.plugin && this.plugin.settings) {
      debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "debug", "[ToolRegistry] Registering tool:", tool.name);
    }
  }
  /**
   * Executes a tool command by looking up the tool and calling its execute method.
   * Handles special context injection for certain tools (e.g., file_diff/editor).
   * @param command The ToolCommand to execute
   * @returns ToolResult with the result or error
   */
  async execute(command) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    const tool = this.tools.get(command.action);
    if (!tool) {
      if (this.plugin && this.plugin.settings) {
        debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "debug", "[ToolRegistry] Tool not found", { action: command.action });
      }
      return {
        success: false,
        error: `Tool not found: ${command.action}`,
        requestId: command.requestId
      };
    }
    try {
      if (this.plugin && this.plugin.settings) {
        debugLog((_b = this.plugin.settings.debugMode) != null ? _b : false, "debug", "[ToolRegistry] Executing tool", { command });
      }
      let parameters = { ...command.parameters };
      if (tool.name === "file_diff" && !parameters.editor) {
        const app = (_c = this.plugin) == null ? void 0 : _c.app;
        let editor = null;
        try {
          if ((_f = (_e = (_d = app == null ? void 0 : app.workspace) == null ? void 0 : _d.activeLeaf) == null ? void 0 : _e.view) == null ? void 0 : _f.editor) {
            editor = app.workspace.activeLeaf.view.editor;
          }
        } catch (error) {
        }
        if (!editor) {
          try {
            const activeView = (_k = (_g = app == null ? void 0 : app.workspace) == null ? void 0 : _g.getActiveViewOfType) == null ? void 0 : _k.call(_g, (_j = (_i = (_h = app == null ? void 0 : app.workspace) == null ? void 0 : _h.viewRegistry) == null ? void 0 : _i.getTypeByID) == null ? void 0 : _j.call(_i, "markdown"));
            if (activeView == null ? void 0 : activeView.editor) {
              editor = activeView.editor;
            }
          } catch (error) {
          }
        }
        if (!editor) {
          try {
            const leaves = (_m = (_l = app == null ? void 0 : app.workspace) == null ? void 0 : _l.getLeavesOfType) == null ? void 0 : _m.call(_l, "markdown");
            if (leaves && leaves.length > 0) {
              for (const leaf of leaves) {
                if ((_n = leaf.view) == null ? void 0 : _n.editor) {
                  editor = leaf.view.editor;
                  break;
                }
              }
            }
          } catch (error) {
          }
        }
        if (editor) {
          parameters.editor = editor;
          if (this.plugin && this.plugin.settings) {
            debugLog((_o = this.plugin.settings.debugMode) != null ? _o : false, "debug", "[ToolRegistry] Injected editor for file_diff tool");
          }
        } else {
          if (this.plugin && this.plugin.settings) {
            debugLog((_p = this.plugin.settings.debugMode) != null ? _p : false, "debug", "[ToolRegistry] No editor available for file_diff tool, will use fallback mode");
          }
        }
      }
      const result = await tool.execute(parameters, {});
      if (this.plugin && this.plugin.settings) {
        debugLog((_q = this.plugin.settings.debugMode) != null ? _q : false, "debug", "[ToolRegistry] Tool execution result", { command, result });
      }
      return {
        ...result,
        requestId: command.requestId
      };
    } catch (error) {
      if (this.plugin && this.plugin.settings) {
        debugLog((_r = this.plugin.settings.debugMode) != null ? _r : false, "error", "[ToolRegistry] Tool execution error", { command, error });
      }
      return {
        success: false,
        error: error.message || String(error),
        requestId: command.requestId
      };
    }
  }
  /**
   * Returns an array of all registered tool instances.
   * @returns Array of Tool objects
   */
  getAvailableTools() {
    return Array.from(this.tools.values());
  }
};

// src/components/agent/AgentResponseHandler/AgentResponseHandler.ts
init_ToolRichDisplay();
init_toolcollect();

// src/components/agent/AgentResponseHandler/constants.ts
var CONSTANTS = {
  NOTIFICATION_DISPLAY_DELAY: 100,
  NOTIFICATION_AUTO_REMOVE_DELAY: 5e3,
  NOTIFICATION_FADE_DELAY: 300,
  MAX_ADDITIONAL_TOOLS: 100,
  REASONING_ID_PREFIX: "reasoning-",
  TOOL_DISPLAY_ID_SEPARATOR: "-",
  ERROR_MESSAGES: {
    TOOL_EXECUTION_FAILED: "Tool execution failed",
    TOOL_EXECUTION_TIMEOUT: "Tool execution timed out",
    COPY_FAILED: "Failed to copy tool result",
    RERUN_FAILED: "Failed to re-run tool"
  },
  JSON_INDENT: 2,
  MD_EXTENSION: ".md",
  PATH_SEPARATOR: "/",
  COMMAND_KEY_SEPARATOR: ":"
};

// src/components/agent/AgentResponseHandler/utils.ts
function stringifyJson(obj) {
  return JSON.stringify(obj, null, CONSTANTS.JSON_INDENT);
}

// src/components/agent/AgentResponseHandler/TaskNotificationManager.ts
var TaskNotificationManager = class {
  /**
   * Constructs a TaskNotificationManager with the given context.
   * @param context The plugin context, including settings.
   */
  constructor(context) {
    // Context containing plugin instance and settings.
    __publicField(this, "context");
    this.context = context;
  }
  /**
   * Creates a DOM element representing a task completion notification.
   * @param message The message to display.
   * @param type The notification type ("success", "error", "warning").
   * @returns The notification HTMLElement.
   */
  createTaskCompletionNotification(message, type2 = "success") {
    const notification = document.createElement("div");
    notification.className = `task-completion-notification ${type2}`;
    const icon = this.getNotificationIcon(type2);
    notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <span>${icon}</span>
                <span>${message}</span>
            </div>
        `;
    this.setupNotificationAutoRemoval(notification);
    return notification;
  }
  /**
   * Shows a task completion notification if enabled in settings.
   * @param message The message to display.
   * @param type The notification type.
   */
  showTaskCompletionNotification(message, type2 = "success") {
    var _a2;
    if (!((_a2 = this.context.plugin.settings.uiBehavior) == null ? void 0 : _a2.showCompletionNotifications)) {
      return;
    }
    const notification = this.createTaskCompletionNotification(message, type2);
    document.body.appendChild(notification);
  }
  /**
   * Updates the task progress indicator (not implemented).
   * @param current The current progress value.
   * @param total The total value for completion (optional).
   * @param description Optional description of the progress.
   */
  updateTaskProgress(current, total, description) {
  }
  /**
   * Hides the task progress indicator (not implemented).
   */
  hideTaskProgress() {
  }
  /**
   * Returns an icon string for the given notification type.
   * @param type The notification type.
   * @returns The icon as a string.
   */
  getNotificationIcon(type2) {
    const icons = {
      success: "\u2705",
      error: "\u274C",
      warning: "\u26A0\uFE0F"
    };
    return icons[type2];
  }
  /**
   * Sets up automatic removal of the notification element after a delay,
   * including a fade-out effect.
   * @param notification The notification HTMLElement.
   */
  setupNotificationAutoRemoval(notification) {
    setTimeout(() => {
      notification.classList.add("show");
    }, CONSTANTS.NOTIFICATION_DISPLAY_DELAY);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), CONSTANTS.NOTIFICATION_FADE_DELAY);
    }, CONSTANTS.NOTIFICATION_AUTO_REMOVE_DELAY);
  }
};

// src/components/agent/AgentResponseHandler/ToolResultFormatter.ts
var ToolResultFormatter = class {
  /**
   * Returns a status icon or label based on success and style.
   * @param success Whether the tool execution was successful.
   * @param style The formatting style ("markdown", "copy", or "plain").
   */
  getStatusIcon(success, style) {
    if (success) {
      return style === "markdown" ? "\u2705" : style === "copy" ? "SUCCESS" : "\u2713";
    } else {
      return style === "markdown" ? "\u274C" : style === "copy" ? "ERROR" : "\u2717";
    }
  }
  /**
   * Formats a single tool result for display in the specified style.
   * @param command The tool command.
   * @param result The tool result.
   * @param opts Optional formatting options.
   */
  formatToolResult(command, result, opts) {
    const style = (opts == null ? void 0 : opts.style) || "plain";
    const status = this.getStatusIcon(result.success, style);
    const action = command.action.replace("_", " ");
    const context = this.getResultContext(command, result);
    switch (style) {
      case "markdown":
        return `${status} **${action}** completed successfully${context}`;
      case "copy":
        return this.formatToolResultForCopy(command, result, status);
      default:
        return this.formatToolResultPlain(command, result, status);
    }
  }
  /**
   * Returns additional context for a tool result, such as file path or summary.
   * @param command The tool command.
   * @param result The tool result.
   */
  getResultContext(command, result) {
    var _a2;
    if (!result.success || !result.data) return "";
    switch (command.action) {
      case "file_write":
      case "file_read":
      case "file_diff":
        if (result.data.filePath) {
          return ` [[${result.data.filePath}]]`;
        }
        break;
      case "file_select":
        if (result.data.count !== void 0) {
          return ` [[${result.data.count} files found]]`;
        }
        break;
      case "thought":
        if ((_a2 = result.data) == null ? void 0 : _a2.formattedThought) {
          return result.data.formattedThought;
        }
        break;
    }
    return "";
  }
  /**
   * Formats a tool result for copying (machine-readable).
   * @param command The tool command.
   * @param result The tool result.
   * @param status The status label.
   */
  formatToolResultForCopy(command, result, status) {
    const params = stringifyJson(command.parameters);
    const resultData = result.success ? stringifyJson(result.data) : result.error;
    return `TOOL EXECUTION: ${command.action}
STATUS: ${status}
PARAMETERS:
${params}
RESULT:
${resultData}`;
  }
  /**
   * Formats a tool result as plain text.
   * @param command The tool command.
   * @param result The tool result.
   * @param status The status icon or label.
   */
  formatToolResultPlain(command, result, status) {
    const data = result.success ? stringifyJson(result.data) : result.error;
    return `${status} Tool: ${command.action}
Parameters: ${stringifyJson(command.parameters)}
Result: ${data}`;
  }
  /**
   * Formats an array of tool results for display in markdown.
   * @param toolResults Array of tool command/result pairs.
   * @returns Markdown string for display.
   */
  formatToolResultsForDisplay(toolResults) {
    if (toolResults.length === 0) {
      return "";
    }
    const resultText = toolResults.map(
      ({ command, result }) => this.formatToolResult(command, result, { style: "markdown" })
    ).join("\n");
    return `

**Tool Execution:**
${resultText}`;
  }
  /**
   * Creates a system message summarizing tool execution results.
   * @param toolResults Array of tool command/result pairs.
   * @returns A Message object or null if no results.
   */
  createToolResultMessage(toolResults) {
    if (toolResults.length === 0) {
      return null;
    }
    const resultText = toolResults.map(
      ({ command, result }) => this.formatToolResult(command, result, { style: "plain" })
    ).join("\n\n");
    return {
      role: "system",
      content: `Tool execution results:

${resultText}`
    };
  }
};

// src/components/agent/AgentResponseHandler/ToolExecutor.ts
var ToolExecutor = class {
  /**
   * Constructs a ToolExecutor.
   * @param toolRegistry The registry of available tools.
   * @param onToolResult Callback for handling tool results.
   * @param createToolDisplay Callback for displaying tool results.
   */
  constructor(toolRegistry, onToolResult, createToolDisplay) {
    // Registry of available tools.
    __publicField(this, "toolRegistry");
    // Counter for the number of tool executions.
    __publicField(this, "executionCount", 0);
    // Callback to handle tool results.
    __publicField(this, "onToolResult");
    // Callback to create a display for tool results.
    __publicField(this, "createToolDisplay");
    this.toolRegistry = toolRegistry;
    this.onToolResult = onToolResult;
    this.createToolDisplay = createToolDisplay;
  }
  /**
   * Executes a tool with logging and timing.
   * @param command The tool command to execute.
   * @param timeoutMs Timeout in milliseconds.
   * @param contextLabel Context label for logging.
   * @param debugLog Optional debug logging function.
   * @returns The result of the tool execution.
   */
  async executeToolWithLogging(command, timeoutMs, contextLabel, debugLog2) {
    const startTime = Date.now();
    if (debugLog2) debugLog2("Executing tool", { command }, contextLabel);
    const result = await this.executeToolWithTimeout(command, timeoutMs);
    const executionTime = Date.now() - startTime;
    if (debugLog2) debugLog2("Tool execution result", { command, result, executionTime }, contextLabel);
    return result;
  }
  /**
   * Executes a tool with a timeout.
   * @param command The tool command to execute.
   * @param timeoutMs Timeout in milliseconds.
   * @returns A promise resolving to the tool result.
   */
  async executeToolWithTimeout(command, timeoutMs) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_TIMEOUT} after ${timeoutMs}ms`));
      }, timeoutMs);
      this.toolRegistry.execute(command).then((result) => {
        clearTimeout(timeout);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  /**
   * Handles successful tool execution.
   * Adds result to toolResults, updates count, displays result, and triggers callback.
   * @param command The executed tool command.
   * @param result The result of execution.
   * @param toolResults Array to store results.
   */
  handleToolExecutionSuccess(command, result, toolResults) {
    toolResults.push({ command, result });
    this.executionCount++;
    this.createToolDisplay(command, result);
    this.onToolResult(result, command);
  }
  /**
   * Handles tool execution errors.
   * Logs error, creates error result, and processes as a success.
   * @param command The tool command.
   * @param error The error thrown.
   * @param toolResults Array to store results.
   * @param contextLabel Context label for logging.
   * @param debugLog Optional debug logging function.
   */
  handleToolExecutionError(command, error, toolResults, contextLabel, debugLog2) {
    if (debugLog2) debugLog2("Tool execution error", { command, error }, contextLabel);
    console.error(`ToolExecutor: Tool '${command.action}' failed with error:`, error);
    const errorResult = this.createErrorResult(command, error);
    this.handleToolExecutionSuccess(command, errorResult, toolResults);
  }
  /**
   * Creates a ToolResult object representing an error.
   * @param command The tool command.
   * @param error The error thrown.
   * @returns A ToolResult indicating failure.
   */
  createErrorResult(command, error) {
    return {
      success: false,
      error: `${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_FAILED}: ${error.message}`,
      requestId: command.requestId
    };
  }
  /**
   * Reruns a tool command and displays the result.
   * @param originalCommand The original tool command.
   * @param timeoutMs Timeout in milliseconds.
   */
  async rerunTool(originalCommand, timeoutMs) {
    try {
      const result = await this.executeToolWithTimeout(originalCommand, timeoutMs);
      this.createToolDisplay(originalCommand, result);
      this.onToolResult(result, originalCommand);
    } catch (error) {
      console.error(`${CONSTANTS.ERROR_MESSAGES.RERUN_FAILED} ${originalCommand.action}:`, error);
    }
  }
  /**
   * Gets the number of tool executions performed.
   * @returns The execution count.
   */
  getExecutionCount() {
    return this.executionCount;
  }
  /**
   * Resets the execution count to zero.
   */
  resetExecutionCount() {
    this.executionCount = 0;
  }
};

// src/components/agent/AgentResponseHandler/ReasoningProcessor.ts
var ReasoningProcessor = class {
  /**
   * Constructs a ReasoningProcessor with the given agent context.
   * @param context The agent context, including plugin settings.
   */
  constructor(context) {
    // Context containing plugin settings and environment.
    __publicField(this, "context");
    this.context = context;
  }
  /**
   * Processes an array of tool results for a chat message.
   * Extracts reasoning data if a "thought" tool result is present,
   * and collects all tool execution results with timestamps.
   *
   * @param toolResults Array of objects containing a ToolCommand and its ToolResult.
   * @returns An object containing optional reasoning data and an array of tool execution results.
   */
  processToolResultsForMessage(toolResults) {
    const toolExecutionResults = toolResults.map(({ command, result }) => ({
      command,
      result,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }));
    let reasoning;
    for (const { command, result } of toolResults) {
      if (command.action === "thought" && result.success && result.data) {
        reasoning = this.convertThoughtToolResultToReasoning(result.data);
        break;
      }
    }
    return {
      reasoning,
      toolExecutionResults
    };
  }
  /**
   * Converts the data from a "thought" tool result into ReasoningData.
   * Handles both structured and simple reasoning formats.
   *
   * @param thoughtData The data from the thought tool result.
   * @returns A ReasoningData object.
   */
  convertThoughtToolResultToReasoning(thoughtData) {
    var _a2;
    const reasoningId = this.generateReasoningId();
    const baseData = {
      id: reasoningId,
      timestamp: thoughtData.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
      isCollapsed: ((_a2 = this.context.plugin.settings.uiBehavior) == null ? void 0 : _a2.collapseOldReasoning) || false
    };
    if (thoughtData.reasoning === "structured" && thoughtData.steps) {
      return {
        ...baseData,
        type: "structured",
        problem: thoughtData.problem,
        steps: thoughtData.steps.map((step) => ({
          step: step.step,
          title: step.title,
          content: step.content
        })),
        depth: thoughtData.depth
      };
    } else {
      return {
        ...baseData,
        type: "simple",
        summary: thoughtData.thought || thoughtData.formattedThought
      };
    }
  }
  /**
   * Generates a unique identifier for a reasoning instance.
   * Combines the current timestamp and a random string.
   *
   * @returns A unique reasoning ID string.
   */
  generateReasoningId() {
    const timestamp2 = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `reasoning-${timestamp2}-${random}`;
  }
};

// src/components/agent/AgentResponseHandler/ToolLimitWarningUI.ts
var ToolLimitWarningUI = class {
  /**
   * Constructs the ToolLimitWarningUI with the given context.
   * @param context The agent context with tool limit and UI references.
   */
  constructor(context) {
    // Context containing plugin, execution state, and UI containers.
    __publicField(this, "context");
    this.context = context;
  }
  /**
   * Creates the warning UI element for when the tool execution limit is reached.
   * @returns The warning HTMLElement.
   */
  createToolLimitWarning() {
    const warning = document.createElement("div");
    warning.className = "tool-limit-warning";
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    const effectiveLimit = this.getEffectiveToolLimit();
    const executionCount = this.context.getExecutionCount();
    warning.innerHTML = this.createToolLimitWarningHTML(executionCount, effectiveLimit, agentSettings.maxToolCalls);
    this.attachToolLimitWarningHandlers(warning, agentSettings);
    return warning;
  }
  /**
   * Generates the HTML for the tool limit warning UI.
   * @param executionCount Number of tool executions used.
   * @param effectiveLimit The current effective tool limit.
   * @param maxToolCalls The default max tool calls from settings.
   * @returns HTML string for the warning.
   */
  createToolLimitWarningHTML(executionCount, effectiveLimit, maxToolCalls) {
    return `
            <div class="tool-limit-warning-text">
                <strong>\u26A0\uFE0F Tool execution limit reached</strong><br>
                Used ${executionCount}/${effectiveLimit} tool calls. 
                Choose how to proceed:
            </div>
            <div class="tool-limit-warning-actions">
                <div class="tool-limit-input-group">
                    <label for="additional-tools">Add more executions:</label>
                    <input type="number" id="additional-tools" min="1" max="${CONSTANTS.MAX_ADDITIONAL_TOOLS}" value="${maxToolCalls}" placeholder="5">
                    <button class="ai-chat-add-tools-button">Add & Continue</button>
                </div>
                <div class="tool-limit-button-group">
                    <button class="ai-chat-continue-button">Reset & Continue</button>
                    <span class="tool-limit-settings-link">Open Settings</span>
                </div>
            </div>
        `;
  }
  /**
   * Attaches event handlers for all warning UI actions.
   * @param warning The warning HTMLElement.
   * @param agentSettings The agent's settings object.
   */
  attachToolLimitWarningHandlers(warning, agentSettings) {
    this.attachSettingsHandler(warning);
    this.attachAddToolsHandler(warning, agentSettings);
    this.attachContinueHandler(warning);
  }
  /**
   * Attaches the handler for the "Open Settings" link.
   * @param warning The warning HTMLElement.
   */
  attachSettingsHandler(warning) {
    const settingsLink = warning.querySelector(".tool-limit-settings-link");
    if (settingsLink) {
      settingsLink.onclick = () => {
        this.context.app.setting.open();
        this.context.app.setting.openTabById(this.context.plugin.manifest.id);
      };
    }
  }
  /**
   * Attaches the handler for the "Add & Continue" button.
   * @param warning The warning HTMLElement.
   * @param agentSettings The agent's settings object.
   */
  attachAddToolsHandler(warning, agentSettings) {
    const addToolsButton = warning.querySelector(".ai-chat-add-tools-button");
    if (addToolsButton) {
      addToolsButton.onclick = () => {
        const input = warning.querySelector("#additional-tools");
        const additionalTools = parseInt(input.value) || agentSettings.maxToolCalls;
        if (additionalTools > 0) {
          this.context.addToolExecutions(additionalTools);
          this.removeWarningAndTriggerContinuation(warning, "continueTaskWithAdditionalTools", { additionalTools });
        }
      };
    }
  }
  /**
   * Attaches the handler for the "Reset & Continue" button.
   * @param warning The warning HTMLElement.
   */
  attachContinueHandler(warning) {
    const continueButton = warning.querySelector(".ai-chat-continue-button");
    if (continueButton) {
      continueButton.onclick = () => {
        this.context.resetExecutionCount();
        this.removeWarningAndTriggerContinuation(warning, "continueTask");
      };
    }
  }
  /**
   * Removes the warning UI and triggers a continuation event.
   * @param warning The warning HTMLElement.
   * @param eventType The event type to dispatch.
   * @param detail Optional event detail.
   */
  removeWarningAndTriggerContinuation(warning, eventType, detail) {
    warning.remove();
    this.hideToolContinuationContainerIfEmpty();
    const event = detail ? new CustomEvent(eventType, { detail }) : new CustomEvent(eventType);
    this.context.messagesContainer.dispatchEvent(event);
  }
  /**
   * Hides the tool continuation container if it is empty.
   */
  hideToolContinuationContainerIfEmpty() {
    if (this.context.toolContinuationContainer) {
      if (this.context.toolContinuationContainer.children.length === 0) {
        this.context.toolContinuationContainer.style.display = "none";
      }
    }
  }
  /**
   * Gets the current effective tool execution limit, considering temporary overrides.
   * @returns The effective tool limit.
   */
  getEffectiveToolLimit() {
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    return this.context.getTemporaryMaxToolCalls() || agentSettings.maxToolCalls;
  }
};

// src/components/agent/AgentResponseHandler/AgentResponseHandler.ts
var AgentResponseHandler = class {
  /**
   * Constructs a new AgentResponseHandler.
   * @param context AgentContext containing plugin, app, and callback references.
   */
  constructor(context) {
    this.context = context;
    // Command parser for extracting tool commands from responses
    __publicField(this, "commandParser");
    // Registry of available tools
    __publicField(this, "toolRegistry");
    // Number of tool executions in the current session
    __publicField(this, "executionCount", 0);
    // Temporary override for max tool calls (optional)
    __publicField(this, "temporaryMaxToolCalls");
    // Map of tool display IDs to ToolRichDisplay instances
    __publicField(this, "toolDisplays", /* @__PURE__ */ new Map());
    // Cache of tool markdown outputs by display ID
    __publicField(this, "toolMarkdownCache", /* @__PURE__ */ new Map());
    // Notification manager for task progress and completion
    __publicField(this, "notificationManager");
    // Formatter for tool results
    __publicField(this, "toolResultFormatter");
    // Executor for running tools
    __publicField(this, "toolExecutor");
    // Processor for reasoning data
    __publicField(this, "reasoningProcessor");
    // UI for tool limit warnings
    __publicField(this, "toolLimitWarningUI");
    this.debugLog("constructor called");
    this.commandParser = new CommandParser(this.context.plugin);
    this.toolRegistry = new ToolRegistry(this.context.plugin);
    this.notificationManager = new TaskNotificationManager(context);
    this.toolResultFormatter = new ToolResultFormatter();
    this.toolExecutor = new ToolExecutor(
      this.toolRegistry,
      (result, command) => this.context.onToolResult(result, command),
      (command, result) => this.createToolDisplay(command, result)
    );
    this.reasoningProcessor = new ReasoningProcessor(context);
    this.toolLimitWarningUI = new ToolLimitWarningUI(this);
    this.initializeTools();
  }
  /**
   * Returns the agent context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Logs debug messages if debug mode is enabled.
   * @param message The message to log.
   * @param data Optional data to log.
   * @param contextLabel Optional label for the log context.
   */
  debugLog(message, data, contextLabel = "AgentResponseHandler") {
    var _a2, _b;
    if (((_b = (_a2 = this.context.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b.debugMode) && typeof this.context.plugin.debugLog === "function") {
      this.context.plugin.debugLog("debug", `[${contextLabel}] ${message}`, data);
    }
  }
  /**
   * Initializes and registers all available tools.
   */
  initializeTools() {
    this.debugLog("initializeTools called");
    const tools = createToolInstances(this.context.app, this.context.plugin);
    for (const tool of tools) {
      this.toolRegistry.register(tool);
    }
  }
  /**
   * Processes a response string, parses tool commands, executes them if needed,
   * and returns processed text and tool results.
   * @param response The response string from the agent.
   * @param contextLabel Optional label for logging context.
   * @param chatHistory Optional chat history for deduplication.
   */
  async processResponse(response, contextLabel = "main", chatHistory) {
    this.debugLog("Processing response", { response }, contextLabel);
    if (!this.context.plugin.agentModeManager.isAgentModeEnabled()) {
      return this.createProcessResponseResult(response, [], false);
    }
    const { text, commands } = this.commandParser.parseResponse(response);
    if (commands.length === 0) {
      this.debugLog("No tool commands found in response", void 0, contextLabel);
      return this.createProcessResponseResult(text, [], false);
    }
    const commandsToExecute = chatHistory ? this.filterAlreadyExecutedCommands(commands, chatHistory, contextLabel) : commands;
    if (commandsToExecute.length === 0) {
      this.debugLog("All commands already executed, skipping", void 0, contextLabel);
      const existingResults = this.getExistingToolResults(commands, chatHistory || []);
      return this.createProcessResponseResult(text, existingResults, true);
    }
    const effectiveLimit = this.getEffectiveToolLimit();
    if (this.executionCount >= effectiveLimit) {
      this.debugLog("Tool execution limit reached", { executionCount: this.executionCount, effectiveLimit }, contextLabel);
      this.notificationManager.showTaskCompletionNotification(`Agent mode: Maximum tool calls (${effectiveLimit}) reached`, "warning");
      return this.createProcessResponseResult(
        text + `

*${effectiveLimit} [Tool execution limit reached]*`,
        [],
        true
      );
    }
    return await this.executeToolCommands(commandsToExecute, text, contextLabel);
  }
  /**
   * Helper to create the result object for processResponse.
   */
  createProcessResponseResult(text, toolResults, hasTools) {
    return {
      processedText: text,
      toolResults,
      hasTools
    };
  }
  /**
   * Executes a list of tool commands, respecting the tool execution limit.
   * @param commands Array of ToolCommand objects to execute.
   * @param text The processed text to return.
   * @param contextLabel Logging context label.
   */
  async executeToolCommands(commands, text, contextLabel) {
    var _a2;
    const toolResults = [];
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    const effectiveLimit = this.getEffectiveToolLimit();
    for (const command of commands) {
      try {
        const result = await this.toolExecutor.executeToolWithLogging(command, agentSettings.timeoutMs, contextLabel, this.debugLog.bind(this));
        toolResults.push({ command, result });
        this.executionCount++;
        this.createToolDisplay(command, result);
        this.context.onToolResult(result, command);
        if (command.action === "get_user_feedback" && result.success && ((_a2 = result.data) == null ? void 0 : _a2.status) === "pending") {
          this.debugLog("User feedback tool detected - pausing execution", { command, result }, contextLabel);
          const userResponse = await this.handlePendingUserFeedback(command, result);
          const completedResult = {
            success: true,
            data: {
              ...userResponse,
              requestId: result.data.requestId,
              status: "completed"
            }
          };
          toolResults[toolResults.length - 1] = { command, result: completedResult };
          this.updateToolDisplay(command, completedResult);
          this.context.onToolResult(completedResult, command);
        }
        if (this.executionCount >= effectiveLimit) {
          break;
        }
      } catch (error) {
        this.debugLog("Tool execution error", { command, error }, contextLabel);
        console.error(`AgentResponseHandler: Tool '${command.action}' failed with error:`, error);
        const errorResult = {
          success: false,
          error: `${CONSTANTS.ERROR_MESSAGES.TOOL_EXECUTION_FAILED}: ${error.message}`,
          requestId: command.requestId
        };
        toolResults.push({ command, result: errorResult });
        this.createToolDisplay(command, errorResult);
        this.context.onToolResult(errorResult, command);
      }
    }
    return this.createProcessResponseResult(text, toolResults, true);
  }
  /**
   * Returns the current execution count.
   */
  getExecutionCount() {
    return this.executionCount;
  }
  /**
   * Temporarily increases the max tool call limit by a given count.
   * @param count Number of additional executions allowed.
   */
  addToolExecutions(count) {
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    this.temporaryMaxToolCalls = (this.temporaryMaxToolCalls || agentSettings.maxToolCalls) + count;
  }
  /**
   * Resets the execution count and clears temporary limits and caches.
   */
  resetExecutionCount() {
    this.executionCount = 0;
    this.temporaryMaxToolCalls = void 0;
    this.toolDisplays.clear();
    this.toolMarkdownCache.clear();
  }
  /**
   * Returns the temporary max tool calls value, if set.
   */
  getTemporaryMaxToolCalls() {
    return this.temporaryMaxToolCalls;
  }
  /**
   * Returns the list of available tools.
   */
  getAvailableTools() {
    return this.toolRegistry.getAvailableTools();
  }
  /**
   * Returns a copy of the current tool displays map.
   */
  getToolDisplays() {
    return new Map(this.toolDisplays);
  }
  /**
   * Clears all tool displays and markdown caches.
   */
  clearToolDisplays() {
    this.toolDisplays.clear();
    this.toolMarkdownCache.clear();
  }
  /**
   * Returns an array of all tool markdown outputs.
   */
  getToolMarkdown() {
    return Array.from(this.toolMarkdownCache.values());
  }
  /**
   * Returns a single string combining all tool markdown outputs.
   */
  getCombinedToolMarkdown() {
    return this.getToolMarkdown().join("\n");
  }
  /**
   * Returns stats about tool executions and limits.
   */
  getExecutionStats() {
    const effectiveLimit = this.getEffectiveToolLimit();
    return {
      executionCount: this.executionCount,
      maxToolCalls: effectiveLimit,
      remaining: Math.max(0, effectiveLimit - this.executionCount)
    };
  }
  /**
   * Creates and stores a ToolRichDisplay for a tool command/result.
   * @param command The tool command.
   * @param result The tool result.
   */
  createToolDisplay(command, result) {
    const displayId = this.generateDisplayId(command);
    const toolDisplay = new ToolRichDisplay({
      command,
      result,
      onRerun: () => this.rerunTool(command),
      onCopy: () => this.copyToolResult(command, result)
    });
    this.toolDisplays.set(displayId, toolDisplay);
    this.toolMarkdownCache.set(displayId, toolDisplay.toMarkdown());
    if (this.context.onToolDisplay) {
      this.context.onToolDisplay(toolDisplay);
    }
    this.cacheToolMarkdown(command, result);
  }
  /**
   * Generates a unique display ID for a tool command.
   * @param command The tool command.
   */
  generateDisplayId(command) {
    return `${command.action}${CONSTANTS.TOOL_DISPLAY_ID_SEPARATOR}${command.requestId || Date.now()}`;
  }
  /**
   * Copies the formatted tool result to the clipboard.
   * @param command The tool command.
   * @param result The tool result.
   */
  async copyToolResult(command, result) {
    const displayText = this.toolResultFormatter.formatToolResult(command, result, { style: "copy" });
    try {
      await navigator.clipboard.writeText(displayText);
    } catch (error) {
      console.error(CONSTANTS.ERROR_MESSAGES.COPY_FAILED, error);
    }
  }
  /**
   * Caches the markdown representation of a tool command/result.
   * @param command The tool command.
   * @param result The tool result.
   */
  cacheToolMarkdown(command, result) {
    const cacheKey = `${command.action}-${command.requestId}`;
    const statusText = result.success ? "SUCCESS" : "ERROR";
    const resultData = result.success ? stringifyJson(result.data) : result.error;
    const markdown = `### TOOL EXECUTION: ${command.action}
**Status:** ${statusText}

**Parameters:**
\`\`\`json
${stringifyJson(command.parameters)}
\`\`\`

**Result:**
\`\`\`json
${resultData}
\`\`\`
`;
    this.toolMarkdownCache.set(cacheKey, markdown);
  }
  /**
   * Reruns a tool command and updates the display/result.
   * @param originalCommand The original tool command to rerun.
   */
  async rerunTool(originalCommand) {
    try {
      const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
      const result = await this.toolExecutor.executeToolWithLogging(originalCommand, agentSettings.timeoutMs, "rerun", this.debugLog.bind(this));
      this.createToolDisplay(originalCommand, result);
      this.context.onToolResult(result, originalCommand);
    } catch (error) {
      console.error(`${CONSTANTS.ERROR_MESSAGES.RERUN_FAILED} ${originalCommand.action}:`, error);
    }
  }
  /**
   * Returns the effective tool execution limit (temporary or default).
   */
  getEffectiveToolLimit() {
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    return this.temporaryMaxToolCalls || agentSettings.maxToolCalls;
  }
  /**
   * Filters out tool commands that have already been executed, based on the chat history.
   * Only commands that have not been executed yet are returned.
   * 
   * @param commands - Array of ToolCommand objects to check.
   * @param chatHistory - The chat history array, containing previous messages and tool results.
   * @param contextLabel - A label for debugging/logging context.
   * @returns Array of ToolCommand objects that have not been executed yet.
   */
  filterAlreadyExecutedCommands(commands, chatHistory, contextLabel) {
    const filteredCommands = [];
    for (const command of commands) {
      const commandKey = this.generateCommandKey(command);
      const alreadyExecuted = this.isCommandInChatHistory(commandKey, chatHistory);
      if (alreadyExecuted) {
        if (this.context.plugin.settings.debugMode) {
          this.context.plugin.debugLog(
            "debug",
            `[AgentResponseHandler][${contextLabel}] Skipping already executed command`,
            { command, commandKey }
          );
        }
      } else {
        filteredCommands.push(command);
      }
    }
    return filteredCommands;
  }
  /**
   * Retrieves the existing tool results for the given commands from the chat history.
   * This is used to avoid re-executing commands and to provide their previous results.
   * 
   * @param commands - Array of ToolCommand objects to look up.
   * @param chatHistory - The chat history array, containing previous messages and tool results.
   * @returns Array of objects containing the command and its corresponding ToolResult.
   */
  getExistingToolResults(commands, chatHistory) {
    const existingResults = [];
    for (const command of commands) {
      const commandKey = this.generateCommandKey(command);
      const existingResult = this.findToolResultInChatHistory(commandKey, chatHistory);
      if (existingResult) {
        existingResults.push({ command, result: existingResult });
      }
    }
    return existingResults;
  }
  /**
   * Generates a unique key for a tool command based on action, parameters, and requestId.
   * @param command The tool command.
   */
  generateCommandKey(command) {
    const params = stringifyJson(command.parameters || {});
    return [
      command.action,
      params,
      command.requestId || "no-id"
    ].join(CONSTANTS.COMMAND_KEY_SEPARATOR);
  }
  /**
   * Checks if a command (by key) is present in the chat history.
   * @param commandKey The unique command key.
   * @param chatHistory The chat history array.
   */
  isCommandInChatHistory(commandKey, chatHistory) {
    for (const message of chatHistory) {
      if (message.sender === "assistant" && message.toolResults) {
        for (const toolResult of message.toolResults) {
          const existingKey = this.generateCommandKey(toolResult.command);
          if (existingKey === commandKey) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Finds the tool result for a command key in the chat history.
   * @param commandKey The unique command key.
   * @param chatHistory The chat history array.
   */
  findToolResultInChatHistory(commandKey, chatHistory) {
    for (const message of chatHistory) {
      if (message.sender === "assistant" && message.toolResults) {
        for (const toolResult of message.toolResults) {
          const existingKey = this.generateCommandKey(toolResult.command);
          if (existingKey === commandKey) {
            return toolResult.result;
          }
        }
      }
    }
    return null;
  }
  /**
   * Returns true if the tool execution limit has been reached.
   */
  isToolLimitReached() {
    const effectiveLimit = this.getEffectiveToolLimit();
    return this.executionCount >= effectiveLimit;
  }
  /**
   * Creates a Message object for tool results, or null if none.
   * @param toolResults Array of tool command/result pairs.
   */
  createToolResultMessage(toolResults) {
    return this.toolResultFormatter.createToolResultMessage(toolResults);
  }
  /**
   * Hides any task progress notifications.
   */
  hideTaskProgress() {
    this.notificationManager.hideTaskProgress();
  }
  /**
   * Processes a response and returns UI-related data, including reasoning and task status.
   * @param response The response string.
   * @param contextLabel Optional context label.
   * @param chatHistory Optional chat history.
   */
  processResponseWithUI(response, contextLabel = "ui", chatHistory) {
    return (async () => {
      const result = await this.processResponse(response, contextLabel, chatHistory);
      let status = "completed";
      if (result.hasTools) {
        const hasPendingFeedback = result.toolResults.some(
          (tr) => {
            var _a2;
            return tr.command.action === "get_user_feedback" && tr.result.success && ((_a2 = tr.result.data) == null ? void 0 : _a2.status) === "pending";
          }
        );
        if (hasPendingFeedback) {
          status = "waiting_for_user";
        } else if (this.isToolLimitReached()) {
          status = "limit_reached";
        } else {
          status = "running";
        }
      }
      const taskStatus = this.createTaskStatus(status);
      const { reasoning } = this.reasoningProcessor.processToolResultsForMessage(result.toolResults);
      const shouldShowLimitWarning = this.isToolLimitReached() && result.hasTools;
      return {
        ...result,
        reasoning,
        taskStatus,
        shouldShowLimitWarning
      };
    })();
  }
  /**
   * Creates a TaskStatus object with the given status and current execution state.
   * @param status The task status
   * @returns TaskStatus object
   */
  createTaskStatus(status) {
    const agentSettings = this.context.plugin.agentModeManager.getAgentModeSettings();
    return {
      status,
      toolExecutionCount: this.executionCount,
      maxToolExecutions: this.getEffectiveToolLimit(),
      canContinue: status === "running" || status === "waiting_for_user",
      lastUpdateTime: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Shows a task completion notification.
   * @param message The message to display.
   * @param type Notification type ("success", "warning", etc).
   */
  showTaskCompletionNotification(message, type2 = "success") {
    this.notificationManager.showTaskCompletionNotification(message, type2);
  }
  /**
   * Creates a tool limit warning UI element.
   * @returns HTMLElement containing the tool limit warning interface
   */
  createToolLimitWarning() {
    return this.toolLimitWarningUI.createToolLimitWarning();
  }
  /**
   * Handles pending user feedback by setting up the async request and waiting for response.
   * @param command The get_user_feedback command
   * @param result The pending result from the tool
   * @returns Promise that resolves with the user response
   */
  async handlePendingUserFeedback(command, result) {
    const { GetUserFeedbackTool: GetUserFeedbackTool2 } = await Promise.resolve().then(() => (init_GetUserFeedback(), GetUserFeedback_exports));
    const timeout = result.data.timeout || 3e5;
    try {
      const userResponse = await GetUserFeedbackTool2.createPendingRequest(result.data.requestId, timeout);
      this.debugLog("User feedback received", { userResponse });
      return userResponse;
    } catch (error) {
      this.debugLog("User feedback timeout or error", { error });
      throw error;
    }
  }
  /**
   * Updates an existing tool display with a new result.
   * @param command The tool command
   * @param result The updated result
   */
  updateToolDisplay(command, result) {
    const displayId = this.generateDisplayId(command);
    const existingDisplay = this.toolDisplays.get(displayId);
    if (existingDisplay) {
      existingDisplay.updateResult(result);
      this.toolMarkdownCache.set(displayId, existingDisplay.toMarkdown());
    } else {
      this.createToolDisplay(command, result);
    }
  }
};

// src/utils/systemMessage.ts
function getSystemMessage(settings) {
  let systemMessage = settings.systemMessage;
  if (settings.includeTimeWithSystemMessage) {
    const now = /* @__PURE__ */ new Date();
    const currentDate = now.toISOString().split("T")[0];
    const timeZoneOffset = now.getTimezoneOffset();
    const offsetHours = Math.abs(Math.floor(timeZoneOffset / 60));
    const offsetMinutes = Math.abs(timeZoneOffset) % 60;
    const sign = timeZoneOffset > 0 ? "-" : "+";
    const currentTime = now.toLocaleTimeString();
    const timeZoneString = `UTC${sign}${offsetHours.toString().padStart(2, "0")}:${offsetMinutes.toString().padStart(2, "0")}`;
    systemMessage = `${systemMessage}

The current time is ${currentDate} ${currentTime} ${timeZoneString}.`;
  }
  return systemMessage;
}

// src/utils/noteUtils.ts
var import_obsidian20 = require("obsidian");

// src/utils/generalUtils.ts
var import_obsidian19 = require("obsidian");
init_logger();
function showNotice(message) {
  new import_obsidian19.Notice(message);
}
async function copyToClipboard3(text, successMsg = "Copied to clipboard", failMsg = "Failed to copy to clipboard") {
  try {
    await navigator.clipboard.writeText(text);
    showNotice(successMsg);
  } catch (error) {
    showNotice(failMsg);
    debugLog(true, "error", "Clipboard error:", error);
  }
}
function moveCursorAfterInsert(editor, startPos, insertText) {
  const lines = insertText.split("\n");
  if (lines.length === 1) {
    editor.setCursor({
      line: startPos.line,
      ch: startPos.ch + insertText.length
    });
  } else {
    editor.setCursor({
      line: startPos.line + lines.length - 1,
      ch: lines[lines.length - 1].length
    });
  }
}
function insertSeparator(editor, position, separator) {
  var _a2;
  const lineContent = (_a2 = editor.getLine(position.line)) != null ? _a2 : "";
  const prefix = lineContent.trim() !== "" ? "\n" : "";
  editor.replaceRange(`${prefix}
${separator}
`, position);
  return position.line + (prefix ? 1 : 0) + 2;
}
function findFile(app, filePath) {
  let file = app.vault.getAbstractFileByPath(filePath) || app.vault.getAbstractFileByPath(`${filePath}.md`);
  if (!file) {
    const allFiles = app.vault.getFiles();
    file = allFiles.find(
      (f) => f.name === filePath || f.name === `${filePath}.md` || f.basename.toLowerCase() === filePath.toLowerCase() || f.path === filePath || f.path === `${filePath}.md`
    ) || null;
  }
  return file;
}
function extractContentUnderHeader(content, headerText) {
  const lines = content.split("\n");
  let foundHeader = false;
  let extractedContent = [];
  let headerLevel = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const headerMatch = line.match(/^(#+)\s+(.*?)$/);
    if (headerMatch) {
      const currentHeaderLevel = headerMatch[1].length;
      const currentHeaderText = headerMatch[2].trim();
      if (foundHeader) {
        if (currentHeaderLevel <= headerLevel) {
          break;
        }
      } else if (currentHeaderText.toLowerCase() === headerText.toLowerCase()) {
        foundHeader = true;
        headerLevel = currentHeaderLevel;
        extractedContent.push(line);
        continue;
      }
    }
    if (foundHeader) {
      extractedContent.push(line);
    }
  }
  return extractedContent.join("\n");
}

// src/utils/noteUtils.ts
init_typeGuards();
async function processObsidianLinks(content, app, settings, visitedNotes = /* @__PURE__ */ new Set(), currentDepth = 0) {
  var _a2;
  if (!settings.enableObsidianLinks) return content;
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let processedContent = content;
  while ((match = linkRegex.exec(content)) !== null) {
    if (match && match[0] && match[1]) {
      const parts = match[1].split("|");
      const filePath = parts[0].trim();
      try {
        let file = findFile(app, filePath);
        const headerMatch = filePath.match(/(.*?)#(.*)/);
        let extractedContent = "";
        if (file && isTFile(file)) {
          if (visitedNotes.has(file.path)) {
            extractedContent = "[Recursive link omitted: already included]";
          } else {
            visitedNotes.add(file.path);
            const noteContent = await app.vault.cachedRead(file);
            if (headerMatch) {
              extractedContent = extractContentUnderHeader(noteContent, headerMatch[2].trim());
            } else {
              extractedContent = noteContent;
            }
            if (settings.expandLinkedNotesRecursively && currentDepth < ((_a2 = settings.maxLinkExpansionDepth) != null ? _a2 : 2)) {
              extractedContent = await processObsidianLinks(extractedContent, app, settings, visitedNotes, currentDepth + 1);
            }
          }
          processedContent = processedContent.replace(
            match[0],
            `${match[0]}

---
Note Name: ${filePath}
Content:
${extractedContent}
---
`
          );
        } else {
          new import_obsidian20.Notice(`File not found: ${filePath}. Ensure the file name and path are correct.`);
        }
      } catch (error) {
        new import_obsidian20.Notice(`Error processing link for ${filePath}: ${error.message}`);
      }
    }
  }
  return processedContent;
}
async function processContextNotes(contextNotesText, app) {
  const linkRegex = /\[\[(.*?)\]\]/g;
  let match;
  let contextContent = "";
  while ((match = linkRegex.exec(contextNotesText)) !== null) {
    if (match && match[1]) {
      const originalLink = match[0];
      const [fileAndHeader, alias] = match[1].split("|").map((s) => s.trim());
      const headerMatch = fileAndHeader.match(/(.*?)#(.*)/);
      const baseFileName = headerMatch ? headerMatch[1].trim() : fileAndHeader;
      const headerName = headerMatch ? headerMatch[2].trim() : null;
      try {
        let file = findFile(app, baseFileName);
        if (file && isTFile(file)) {
          const noteContent = await app.vault.cachedRead(file);
          contextContent += `---
Attached: ${originalLink}

`;
          if (headerName) {
            const headerContent = extractContentUnderHeader(noteContent, headerName);
            contextContent += headerContent;
          } else {
            contextContent += noteContent;
          }
          contextContent += "\n\n";
        } else {
          contextContent += `Note not found: ${originalLink}

`;
        }
      } catch (error) {
        contextContent += `Error processing note ${originalLink}: ${error.message}

`;
      }
    }
  }
  return contextContent;
}
async function processMessages(messages, app, settings) {
  const processedMessages = [];
  if (settings.enableContextNotes && settings.contextNotes) {
    const contextContent = await processContextNotes(settings.contextNotes, app);
    if (contextContent) {
      if (messages.length > 0 && messages[0].role === "system") {
        processedMessages.push({
          role: "system",
          content: `${messages[0].content}

Here is additional context:
${contextContent}`
        });
        messages = messages.slice(1);
      } else {
        processedMessages.push({
          role: "system",
          content: `Here is context for our conversation:
${contextContent}`
        });
      }
    }
  }
  for (const message of messages) {
    const processedContent = await processObsidianLinks(message.content, app, settings, /* @__PURE__ */ new Set());
    processedMessages.push({
      role: message.role,
      content: processedContent
    });
  }
  return processedMessages;
}

// src/utils/recently-opened-files.ts
init_logger();
var _RecentlyOpenedFilesManager = class _RecentlyOpenedFilesManager {
  constructor(app) {
    __publicField(this, "app");
    __publicField(this, "listenerRef", null);
    __publicField(this, "FILENAME", "recently-opened-files.json");
    __publicField(this, "MAX_FILES", 100);
    this.app = app;
    this.setupFileListener();
  }
  static getInstance(app) {
    if (!_RecentlyOpenedFilesManager.instance) {
      if (!app) {
        throw new Error("App instance required for first initialization");
      }
      _RecentlyOpenedFilesManager.instance = new _RecentlyOpenedFilesManager(app);
    }
    return _RecentlyOpenedFilesManager.instance;
  }
  setupFileListener() {
    if (this.listenerRef) {
      return;
    }
    this.listenerRef = this.app.workspace.on("file-open", (file) => {
      if (file) {
        this.recordFileOpened(file);
      }
    });
  }
  getFilePath() {
    return `${this.app.vault.configDir}/${this.FILENAME}`;
  }
  async recordFileOpened(file, debugMode = false) {
    const filePath = this.getFilePath();
    let data = {
      recentFiles: [],
      omittedPaths: [],
      omittedTags: [],
      updateOn: "file-open",
      omitBookmarks: false,
      maxLength: null
    };
    try {
      if (await this.app.vault.adapter.exists(filePath)) {
        const raw = await this.app.vault.adapter.read(filePath);
        const parsed = JSON.parse(raw);
        if (this.isValidDataJson(parsed)) {
          data = parsed;
        }
      }
    } catch (e) {
      debugLog(debugMode, "warn", "[recently-opened-files] Failed to read existing records", e);
    }
    data.recentFiles = data.recentFiles.filter((r) => r.path !== file.path);
    data.recentFiles.unshift({
      path: file.path,
      basename: file.basename
    });
    if (data.recentFiles.length > this.MAX_FILES) {
      data.recentFiles = data.recentFiles.slice(0, this.MAX_FILES);
    }
    try {
      await this.app.vault.adapter.write(filePath, JSON.stringify(data, null, 2));
    } catch (e) {
      debugLog(debugMode, "error", "[recently-opened-files] Failed to write records", e);
    }
  }
  isValidDataJson(data) {
    return typeof data === "object" && data !== null && Array.isArray(data.recentFiles) && Array.isArray(data.omittedPaths) && Array.isArray(data.omittedTags) && typeof data.updateOn === "string" && typeof data.omitBookmarks === "boolean" && (typeof data.maxLength === "number" || data.maxLength === null);
  }
  async getRecentlyOpenedFiles() {
    const pluginFiles = await this.getRecentFilesFromPlugin();
    if (pluginFiles.length > 0) {
      return pluginFiles;
    }
    return this.getRecentFilesFromOwnFile();
  }
  async getRecentFilesFromPlugin() {
    const pluginId = "recent-files-obsidian";
    const pluginDataPath = `${this.app.vault.configDir}/plugins/${pluginId}/data.json`;
    try {
      if (await this.app.vault.adapter.exists(pluginDataPath)) {
        const raw = await this.app.vault.adapter.read(pluginDataPath);
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed.recentFiles)) {
          await this.syncWithOwnFile(parsed.recentFiles);
          return parsed.recentFiles.map((f) => ({
            path: f.path,
            basename: f.basename
          }));
        }
      }
    } catch (e) {
      debugLog(true, "warn", "[recently-opened-files] Failed to read recent-files-obsidian plugin data", e);
    }
    return [];
  }
  async syncWithOwnFile(pluginFiles) {
    const filePath = this.getFilePath();
    let data = {
      recentFiles: [],
      omittedPaths: [],
      omittedTags: [],
      updateOn: "file-open",
      omitBookmarks: false,
      maxLength: null
    };
    try {
      if (await this.app.vault.adapter.exists(filePath)) {
        const raw = await this.app.vault.adapter.read(filePath);
        const parsed = JSON.parse(raw);
        if (this.isValidDataJson(parsed)) {
          data = parsed;
        }
      }
    } catch (e) {
    }
    const seen = new Set(data.recentFiles.map((f) => f.path));
    for (const file of pluginFiles) {
      if (!seen.has(file.path)) {
        data.recentFiles.push({
          path: file.path,
          basename: file.basename
        });
      }
    }
    if (data.recentFiles.length > this.MAX_FILES) {
      data.recentFiles = data.recentFiles.slice(0, this.MAX_FILES);
    }
    try {
      await this.app.vault.adapter.write(filePath, JSON.stringify(data, null, 2));
    } catch (e) {
    }
  }
  async getRecentFilesFromOwnFile() {
    const filePath = this.getFilePath();
    try {
      if (await this.app.vault.adapter.exists(filePath)) {
        const raw = await this.app.vault.adapter.read(filePath);
        const parsed = JSON.parse(raw);
        if (this.isValidDataJson(parsed)) {
          return parsed.recentFiles;
        }
      }
    } catch (e) {
      debugLog(true, "warn", "[recently-opened-files] Failed to read own file", e);
    }
    return [];
  }
  destroy() {
    if (this.listenerRef) {
      this.app.workspace.offref(this.listenerRef);
      this.listenerRef = null;
    }
  }
};
__publicField(_RecentlyOpenedFilesManager, "instance");
var RecentlyOpenedFilesManager = _RecentlyOpenedFilesManager;
async function getRecentlyOpenedFiles(app) {
  const manager = RecentlyOpenedFilesManager.getInstance(app);
  return manager.getRecentlyOpenedFiles();
}

// src/utils/contextBuilder.ts
async function buildContextMessages({
  app,
  plugin,
  includeCurrentNote = true,
  includeContextNotes = true,
  debug: debug2 = false,
  forceNoCurrentNote = false
}) {
  var _a2;
  const messages = [
    { role: "system", content: getSystemMessage(plugin.settings) }
  ];
  const recentlyOpenedFiles = await getRecentlyOpenedFiles(app);
  if (recentlyOpenedFiles.length > 0) {
    messages[0].content += `

Recently Opened Files:
${recentlyOpenedFiles.slice(0, 5).map((f) => f.path).join("\n")}`;
  }
  if (includeContextNotes && plugin.settings.enableContextNotes && plugin.settings.contextNotes) {
    const contextContent = await processContextNotes(plugin.settings.contextNotes, app);
    messages[0].content += `

Context Notes:
${contextContent}`;
  }
  if (!forceNoCurrentNote && includeCurrentNote && plugin.settings.referenceCurrentNote) {
    const currentFile = app.workspace.getActiveFile();
    if (currentFile) {
      const currentNoteContent = await app.vault.cachedRead(currentFile);
      messages.push({
        role: "system",
        content: `Here is the content of the current note (${currentFile.path}):

${currentNoteContent}`
      });
    }
  }
  if (debug2 || plugin.settings.debugMode) {
    (_a2 = plugin.debugLog) == null ? void 0 : _a2.call(plugin, "debug", "[contextBuilder] Building context messages", {
      enableContextNotes: plugin.settings.enableContextNotes,
      contextNotes: plugin.settings.contextNotes,
      referenceCurrentNote: plugin.settings.referenceCurrentNote
    });
  }
  return messages;
}

// src/components/chat/MessageRegenerator.ts
var import_obsidian24 = require("obsidian");

// src/components/chat/ResponseStreamer.ts
var import_obsidian23 = require("obsidian");
init_aiDispatcher();
init_MessageRenderer();

// src/components/agent/TaskContinuation.ts
var import_obsidian21 = require("obsidian");
var TaskContinuation = class {
  /**
   * @param plugin The main plugin instance (for settings and logging)
   * @param agentResponseHandler Handler for agent responses and tool execution
   * @param messagesContainer The container element for chat messages
   * @param component Optional Obsidian component for Markdown rendering context
   */
  constructor(plugin, agentResponseHandler, messagesContainer, component) {
    this.plugin = plugin;
    this.agentResponseHandler = agentResponseHandler;
    this.messagesContainer = messagesContainer;
    this.component = component;
  }
  /**
   * Continues task execution until the task is finished or a limit is reached.
   * Iteratively processes tool results and agent responses.
   * @param messages The conversation history/messages
   * @param container The chat message container element
   * @param initialResponseContent The initial assistant response content
   * @param currentContent The current content to display
   * @param initialToolResults Initial tool results to process
   * @param chatHistory Optional chat history for context
   * @returns An object with the final content and a flag if the tool limit was reached
   */
  async continueTaskUntilFinished(messages, container, initialResponseContent, currentContent, initialToolResults, chatHistory) {
    var _a2, _b, _c, _d, _e;
    let responseContent = currentContent;
    let maxIterations = (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxIterations) != null ? _b : 10;
    let iteration = 0;
    let limitReachedDuringContinuation = false;
    let allToolResults = [...initialToolResults];
    let isFinished = this.checkIfTaskFinished(allToolResults);
    if ((_c = this.agentResponseHandler) == null ? void 0 : _c.isToolLimitReached()) {
      return {
        content: responseContent + "\n\n*[Tool execution limit reached - task continuation stopped]*",
        limitReachedDuringContinuation: true
      };
    }
    if (this.plugin.settings.debugMode) {
      this.plugin.debugLog("debug", "[TaskContinuation] continueTaskUntilFinished", {
        initialResponseContent,
        currentContent,
        initialToolResults,
        maxIterations
      });
    }
    while (!isFinished && iteration < maxIterations) {
      iteration++;
      if ((_d = this.agentResponseHandler) == null ? void 0 : _d.isToolLimitReached()) {
        responseContent += "\n\n*[Tool execution limit reached during continuation]*";
        limitReachedDuringContinuation = true;
        break;
      }
      const toolResultMessage = (_e = this.agentResponseHandler) == null ? void 0 : _e.createToolResultMessage(allToolResults);
      if (toolResultMessage) {
        const continuationMessages = [
          ...messages,
          { role: "assistant", content: initialResponseContent },
          toolResultMessage
        ];
        const continuationContent = await this.getContinuationResponse(continuationMessages, container);
        if (continuationContent.trim()) {
          let processingResult;
          if (this.agentResponseHandler) {
            processingResult = await this.agentResponseHandler.processResponse(continuationContent, "task-continuation", chatHistory);
            if (processingResult.toolResults && processingResult.toolResults.length > 0) {
              allToolResults = [...allToolResults, ...processingResult.toolResults];
            }
          }
          const continuationResult = await this.processContinuation(
            continuationContent,
            responseContent,
            container,
            allToolResults,
            chatHistory,
            processingResult
          );
          responseContent = continuationResult.responseContent;
          isFinished = continuationResult.isFinished;
          initialResponseContent = continuationContent;
        } else {
          isFinished = true;
        }
      } else {
        isFinished = true;
      }
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Iteration", {
          iteration,
          isFinished,
          toolResults: allToolResults
        });
      }
    }
    if (iteration >= maxIterations) {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Maximum iterations reached", { iteration });
      }
      responseContent += "\n\n*[Task continuation reached maximum iterations - stopping to prevent infinite loop]*";
    }
    return { content: responseContent, limitReachedDuringContinuation };
  }
  /**
   * Processes the agent's continuation response and updates the UI.
   * Handles both tool-based and plain responses.
   * @param continuationContent The agent's response content
   * @param responseContent The current response content
   * @param container The chat message container element
   * @param initialToolResults Tool results so far
   * @param chatHistory Optional chat history
   * @param processingResult Optional pre-processed agent result
   * @returns Object with updated response content and finished flag
   */
  async processContinuation(continuationContent, responseContent, container, initialToolResults, chatHistory, processingResult) {
    let continuationResult;
    if (processingResult) {
      continuationResult = processingResult;
    } else if (this.agentResponseHandler) {
      continuationResult = await this.agentResponseHandler.processResponse(continuationContent, "main", chatHistory);
    } else {
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateContainerContent(container, updatedContent);
      return { responseContent: updatedContent, isFinished: true };
    }
    if (continuationResult.hasTools) {
      const cleanContinuationContent = continuationResult.processedText;
      const isFinished = this.checkIfTaskFinished(continuationResult.toolResults);
      const allToolResults = initialToolResults;
      const updatedContent = responseContent + "\n\n" + cleanContinuationContent;
      const enhancedMessageData = this.createEnhancedMessageData(
        updatedContent,
        continuationResult,
        allToolResults
      );
      this.updateContainerWithMessageData(container, enhancedMessageData, updatedContent);
      return { responseContent: updatedContent, isFinished };
    } else {
      let isFinished = false;
      try {
        const parsed = JSON.parse(continuationContent);
        if (parsed && parsed.finished === true) {
          isFinished = true;
        }
      } catch (e) {
        if (initialToolResults.length > 0) {
          isFinished = this.checkIfTaskFinished(initialToolResults);
        }
      }
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateContainerContent(container, updatedContent);
      return { responseContent: updatedContent, isFinished };
    }
  }
  /**
   * Updates the chat container with new Markdown-rendered content.
   * @param container The chat message container element
   * @param content The new content to render
   */
  async updateContainerContent(container, content) {
    container.dataset.rawContent = content;
    const contentEl = container.querySelector(".message-content");
    if (contentEl) {
      contentEl.empty();
      await import_obsidian21.MarkdownRenderer.render(
        this.plugin.app,
        content,
        contentEl,
        "",
        this.component || null
      );
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
  }
  /**
   * Checks if any tool results indicate the task is finished.
   * Looks for a 'finished' flag or a 'thought' tool with nextTool 'finished'.
   * @param toolResults Array of tool command/result pairs
   * @returns True if the task is finished, false otherwise
   */
  checkIfTaskFinished(toolResults) {
    return toolResults.some(({ command, result }) => {
      if (command.finished === true) {
        return true;
      }
      if (command.action === "thought" && result.success && result.data) {
        return result.data.nextTool === "finished" || result.data.finished === true;
      }
      return false;
    });
  }
  /**
   * Gets the agent's continuation response after tool execution.
   * Calls the provider's getCompletion method and streams the result.
   * @param messages The conversation history/messages
   * @param container The chat message container element
   * @returns The agent's response content as a string
   */
  async getContinuationResponse(messages, container) {
    var _a2;
    try {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] getContinuationResponse", { messages });
      }
      if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
        return "*[Tool execution limit reached - no continuation response]*";
      }
      const { AIDispatcher: AIDispatcher2 } = await Promise.resolve().then(() => (init_aiDispatcher(), aiDispatcher_exports));
      const aiDispatcher = new AIDispatcher2(this.plugin.app.vault, this.plugin);
      let continuationContent = "";
      await aiDispatcher.getCompletion(
        messages,
        {
          temperature: this.plugin.settings.temperature,
          streamCallback: async (chunk) => {
            continuationContent += chunk;
          }
        }
      );
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Continuation response received", { continuationContent });
      }
      return continuationContent;
    } catch (error) {
      if (this.plugin.settings.debugMode) {
        this.plugin.debugLog("debug", "[TaskContinuation] Error getting continuation response", { error });
      }
      console.error("TaskContinuation: Error getting continuation response:", error);
      if (error.name !== "AbortError") {
        return `*[Error getting continuation: ${error.message}]*`;
      }
      return "";
    }
  }
  /**
   * Creates an enhanced message data structure for UI or logging.
   * Includes reasoning, task status, and tool results.
   * @param content The message content
   * @param agentResult The agent's result object
   * @param toolResults Optional array of tool results
   * @returns Message object with additional metadata
   */
  createEnhancedMessageData(content, agentResult, toolResults) {
    const messageData = {
      role: "assistant",
      content,
      reasoning: agentResult.reasoning,
      taskStatus: agentResult.taskStatus
    };
    if (toolResults) {
      messageData.toolResults = toolResults.map(({ command, result }) => ({
        command,
        result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
    return messageData;
  }
  /**
   * Updates the chat container with enhanced message data and raw content.
   * @param container The chat message container element
   * @param messageData The message data object to store
   * @param rawContent The raw content string
   */
  updateContainerWithMessageData(container, messageData, rawContent) {
    container.dataset.messageData = JSON.stringify(messageData);
    container.dataset.rawContent = rawContent;
  }
};

// src/components/chat/ResponseStreamer.ts
var ResponseStreamer = class {
  /**
   * @param plugin The main plugin instance (for settings, logging, etc.)
   * @param agentResponseHandler Handler for agent responses and tool execution (null if agent mode is off)
   * @param messagesContainer The container element for chat messages
   * @param activeStream The current AbortController for streaming (shared reference)
   * @param component Optional parent component for Markdown rendering context
   */
  constructor(plugin, agentResponseHandler, messagesContainer, activeStream, component) {
    this.plugin = plugin;
    this.agentResponseHandler = agentResponseHandler;
    this.messagesContainer = messagesContainer;
    this.activeStream = activeStream;
    this.component = component;
    __publicField(this, "messageRenderer");
    this.messageRenderer = new MessageRenderer(plugin.app);
  }
  /**
   * Streams AI assistant response with optional agent processing.
   * Handles agent mode integration, tool execution, and task continuation.
   * @param messages The conversation history/messages to send to the provider
   * @param container The message container element to update with the streamed response
   * @param originalTimestamp Optional timestamp for history update
   * @param originalContent Optional original content for history update
   * @param chatHistory Optional chat history for context
   * @returns Promise resolving to the final response content string
   */
  async streamAssistantResponse(messages, container, originalTimestamp, originalContent, chatHistory) {
    var _a2;
    this.plugin.debugLog("info", "[ResponseStreamer] streamAssistantResponse called", { messages, originalTimestamp });
    let responseContent = "";
    this.activeStream = new AbortController();
    await this.addAgentSystemPrompt(messages);
    try {
      const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
      await aiDispatcher.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        streamCallback: async (chunk) => {
          responseContent += chunk;
          await this.updateMessageContent(container, responseContent);
        },
        abortController: this.activeStream || void 0
      });
      if (this.plugin.agentModeManager.isAgentModeEnabled() && this.agentResponseHandler) {
        responseContent = await this.processAgentResponse(responseContent, container, messages, "streamer-main", chatHistory);
      }
      return responseContent;
    } catch (error) {
      if (error.name !== "AbortError") {
        throw error;
      }
      return "";
    } finally {
      (_a2 = this.agentResponseHandler) == null ? void 0 : _a2.hideTaskProgress();
    }
  }
  /**
   * Adds agent system prompt to messages if agent mode is enabled.
   * Prepends the agent prompt to the existing system message or adds a new one.
   * @param messages The message array to modify
   */
  async addAgentSystemPrompt(messages) {
    this.plugin.debugLog("debug", "[ResponseStreamer] addAgentSystemPrompt called", { messages });
    if (!this.plugin.agentModeManager.isAgentModeEnabled()) return;
    const { buildAgentSystemPrompt: buildAgentSystemPrompt2 } = await Promise.resolve().then(() => (init_promptConstants(), promptConstants_exports));
    const agentPrompt = buildAgentSystemPrompt2(
      this.plugin.settings.enabledTools,
      this.plugin.settings.customAgentSystemMessage
    );
    const systemMessageIndex = messages.findIndex((msg) => msg.role === "system");
    if (systemMessageIndex !== -1) {
      const originalContent = messages[systemMessageIndex].content;
      messages[systemMessageIndex].content = agentPrompt + "\n\n" + originalContent;
    } else {
      messages.unshift({
        role: "system",
        content: agentPrompt
      });
    }
  }
  /**
   * Updates message content in the UI with markdown rendering.
   * @param container The message DOM element
   * @param content The new content string
   */
  async updateMessageContent(container, content) {
    const contentEl = container.querySelector(".message-content");
    if (!contentEl) return;
    this.updateContainerDataset(container, content);
    contentEl.empty();
    await import_obsidian23.MarkdownRenderer.render(
      this.plugin.app,
      content,
      contentEl,
      "",
      this.component || null
    );
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  /**
   * Processes agent response and handles tool execution or reasoning.
   * Calls the AgentResponseHandler to parse and execute tools.
   * @param responseContent The raw response content from the AI
   * @param container The message DOM element
   * @param messages The message history
   * @param contextLabel Label for the processing context
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the final content after processing
   */
  async processAgentResponse(responseContent, container, messages, contextLabel = "streamer", chatHistory) {
    if (!this.agentResponseHandler) {
      return responseContent;
    }
    try {
      const agentResult = await this.agentResponseHandler.processResponseWithUI(responseContent, contextLabel, chatHistory);
      return agentResult.hasTools ? await this.handleToolExecution(agentResult, container, responseContent, messages, chatHistory) : await this.handleNonToolResponse(agentResult, container, responseContent, messages, chatHistory);
    } catch (error) {
      console.error("ResponseStreamer: Error processing agent response:", error);
      return responseContent;
    }
  }
  /**
   * Handles responses that include tool execution.
   * Updates the message with rich tool displays and handles task completion/continuation.
   * @param agentResult The result from AgentResponseHandler
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param messages The message history
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the final content after handling
   */
  async handleToolExecution(agentResult, container, responseContent, messages, chatHistory) {
    const finalContent = agentResult.processedText;
    const enhancedMessageData = this.createEnhancedMessageData(
      finalContent,
      agentResult,
      agentResult.toolResults
    );
    this.updateContainerWithMessageData(container, enhancedMessageData, finalContent);
    return this.handleTaskCompletion(agentResult, finalContent, responseContent, messages, container, chatHistory);
  }
  /**
   * Handles responses without tool execution but potentially with reasoning.
   * Updates the message with reasoning display and checks for reasoning continuation.
   * @param agentResult The result from AgentResponseHandler
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param messages The message history
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the final content after handling
   */
  async handleNonToolResponse(agentResult, container, responseContent, messages, chatHistory) {
    if (agentResult.reasoning) {
      const enhancedMessageData = this.createEnhancedMessageData(responseContent, agentResult);
      this.updateContainerWithMessageData(container, enhancedMessageData, responseContent);
    }
    if (this.isReasoningStep(responseContent)) {
      return await this.handleReasoningContinuation(responseContent, messages, container, chatHistory);
    }
    return responseContent;
  }
  /**
   * Creates enhanced message data structure including reasoning, task status, and tool results.
   * @param content The main message content
   * @param agentResult The agent's processing result
   * @param toolResults Optional array of tool execution results
   * @returns Message object with additional metadata
   */
  createEnhancedMessageData(content, agentResult, toolResults) {
    const messageData = {
      role: "assistant",
      content,
      reasoning: agentResult.reasoning,
      taskStatus: agentResult.taskStatus
    };
    if (toolResults) {
      messageData.toolResults = toolResults.map(({ command, result }) => ({
        command,
        result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
    return messageData;
  }
  /**
   * Updates container with enhanced message data and re-renders using MessageRenderer.
   * @param container The message DOM element
   * @param messageData The enhanced message data
   * @param rawContent The raw content string
   */
  updateContainerWithMessageData(container, messageData, rawContent) {
    container.dataset.messageData = JSON.stringify(messageData);
    container.dataset.rawContent = rawContent;
    this.messageRenderer.updateMessageWithEnhancedData(container, messageData);
  }
  /**
   * DRY helper: Updates container dataset values for rawContent and messageData.
   * @param container The message DOM element
   * @param rawContent The raw content string
   * @param messageData Optional enhanced message data
   */
  updateContainerDataset(container, rawContent, messageData) {
    container.dataset.rawContent = rawContent;
    if (messageData) {
      container.dataset.messageData = JSON.stringify(messageData);
    }
  }
  /**
   * Checks if response content indicates a reasoning step (heuristic based on thought tool JSON).
   * @param responseContent The response content string
   * @returns True if it seems like a reasoning step, false otherwise
   */
  isReasoningStep(responseContent) {
    return responseContent.includes('"action"') && responseContent.includes('"thought"');
  }
  /**
   * Handles task completion, continuation, and tool limit management.
   * Determines if the task is finished, if continuation is needed, or if limits are reached.
   * @param agentResult The result from AgentResponseHandler
   * @param finalContent The processed content (without tool JSON)
   * @param responseContent The raw response content
   * @param messages The message history
   * @param container The message DOM element
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the final content after handling
   */
  async handleTaskCompletion(agentResult, finalContent, responseContent, messages, container, chatHistory) {
    if (agentResult.shouldShowLimitWarning) {
      return this.handleToolLimitReached(messages, container, responseContent, finalContent, agentResult.toolResults, chatHistory);
    }
    if (agentResult.taskStatus.status === "completed") {
      this.agentResponseHandler.showTaskCompletionNotification(
        `Task completed successfully! Used ${agentResult.taskStatus.toolExecutionCount} tools.`,
        "success"
      );
      return finalContent;
    }
    return await this.continueTaskIfPossible(
      agentResult,
      messages,
      container,
      responseContent,
      finalContent,
      chatHistory
    );
  }
  /**
   * Handles tool limit reached scenario.
   * Displays a warning and sets up event listeners for user-driven continuation.
   * @param messages The message history
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param finalContent The processed content
   * @param toolResults Tool results from the last step
   * @param chatHistory Optional chat history
   * @returns The final content with the warning appended
   */
  handleToolLimitReached(messages, container, responseContent, finalContent, toolResults, chatHistory) {
    const warning = this.agentResponseHandler.createToolLimitWarning();
    const targetContainer = this.agentResponseHandler.getContext().toolContinuationContainer || this.messagesContainer;
    targetContainer.appendChild(warning);
    if (this.agentResponseHandler.getContext().toolContinuationContainer) {
      this.agentResponseHandler.getContext().toolContinuationContainer.style.display = "block";
    }
    this.setupContinuationEventListeners(messages, container, responseContent, finalContent, toolResults, chatHistory);
    this.agentResponseHandler.showTaskCompletionNotification(
      "Tool execution limit reached. Choose how to continue above.",
      "warning"
    );
    return finalContent;
  }
  /**
   * Sets up event listeners on the messages container for task continuation actions.
   * @param messages The message history
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param finalContent The processed content
   * @param toolResults Tool results from the last step
   * @param chatHistory Optional chat history
   */
  setupContinuationEventListeners(messages, container, responseContent, finalContent, toolResults, chatHistory) {
    const continuationParams = {
      messages,
      container,
      responseContent,
      finalContent,
      toolResults,
      chatHistory
    };
    this.messagesContainer.addEventListener("continueTask", () => {
      this.executeContinuation(continuationParams);
    });
    this.messagesContainer.addEventListener("continueTaskWithAdditionalTools", (event) => {
      this.executeContinuation({
        ...continuationParams,
        additionalTools: event.detail.additionalTools
      });
    });
  }
  /**
   * Continues task if no limits are reached and the task is not completed.
   * Creates a TaskContinuation instance and runs the continuation loop.
   * @param agentResult The result from AgentResponseHandler
   * @param messages The message history
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param finalContent The processed content
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the final content after continuation
   */
  async continueTaskIfPossible(agentResult, messages, container, responseContent, finalContent, chatHistory) {
    var _a2;
    if (agentResult.shouldShowLimitWarning || ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached())) {
      return finalContent;
    }
    const taskContinuation = this.createTaskContinuation();
    const continuationResult = await taskContinuation.continueTaskUntilFinished(
      messages,
      container,
      responseContent,
      finalContent,
      agentResult.toolResults,
      chatHistory || []
    );
    if (continuationResult.limitReachedDuringContinuation) {
      this.handleToolLimitReached(
        messages,
        container,
        responseContent,
        continuationResult.content,
        agentResult.toolResults,
        chatHistory
      );
    }
    return continuationResult.content;
  }
  /**
   * Creates a TaskContinuation instance.
   */
  createTaskContinuation() {
    return new TaskContinuation(
      this.plugin,
      this.agentResponseHandler,
      this.messagesContainer,
      this.component
    );
  }
  /**
   * Handles reasoning continuation when AI response contains reasoning steps.
   * Adds a system message to prompt the agent to continue with execution.
   * @param responseContent The raw response content (containing reasoning)
   * @param messages The message history
   * @param container The message DOM element
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the updated content after continuation
   */
  async handleReasoningContinuation(responseContent, messages, container, chatHistory) {
    var _a2;
    if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
      return responseContent + "\n\n*[Tool execution limit reached - reasoning continuation stopped]*";
    }
    messages.push(
      { role: "assistant", content: responseContent },
      { role: "system", content: "Please continue with the actual task execution based on your reasoning." }
    );
    const continuationContent = await this.getContinuationResponse(messages, container);
    if (continuationContent.trim()) {
      const updatedContent = responseContent + "\n\n" + continuationContent;
      await this.updateMessageContent(container, updatedContent);
      return updatedContent;
    }
    return responseContent;
  }
  /**
   * Gets continuation response after tool execution with error handling.
   * Used internally for task continuation loops.
   * @param messages The message history for the continuation request
   * @param container The message DOM element
   * @returns Promise resolving to the continuation response content string
   */
  async getContinuationResponse(messages, container) {
    var _a2;
    try {
      if ((_a2 = this.agentResponseHandler) == null ? void 0 : _a2.isToolLimitReached()) {
        return "*[Tool execution limit reached - no continuation response]*";
      }
      const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
      let continuationContent = "";
      await aiDispatcher.getCompletion(messages, {
        temperature: this.plugin.settings.temperature,
        streamCallback: async (chunk) => {
          continuationContent += chunk;
        },
        abortController: this.activeStream || void 0
      });
      return continuationContent;
    } catch (error) {
      console.error("ResponseStreamer: Error getting continuation response:", error);
      return error.name !== "AbortError" ? `*[Error getting continuation: ${error.message}]*` : "";
    }
  }
  /**
   * Executes task continuation with proper setup and error handling.
   * Called when the user triggers continuation from the UI after a limit is reached.
   * @param params ContinuationParams
   */
  async executeContinuation(params) {
    if (!this.agentResponseHandler) return;
    const { messages, container, responseContent, finalContent, toolResults, additionalTools, chatHistory } = params;
    if (additionalTools) {
    } else {
      this.agentResponseHandler.resetExecutionCount();
    }
    const continueMessage = this.createContinuationMessage(additionalTools);
    await this.addContinuationNotice(continueMessage);
    messages.push({ role: "assistant", content: finalContent }, continueMessage);
    const newBotMessage = await this.createNewBotMessage();
    const continuationResult = await this.executeTaskContinuation(
      messages,
      newBotMessage.getElement(),
      responseContent,
      toolResults,
      chatHistory
    );
    if (continuationResult.limitReachedDuringContinuation) {
      this.handleToolLimitReached(
        messages,
        newBotMessage.getElement(),
        responseContent,
        continuationResult.content,
        toolResults,
        chatHistory
      );
    }
    newBotMessage.setContent(continuationResult.content);
  }
  /**
   * Creates continuation message based on type (reset limit vs add tools).
   * @param additionalTools Optional number of additional tools
   * @returns Message object for the continuation notice
   */
  createContinuationMessage(additionalTools) {
    const content = additionalTools ? `Added ${additionalTools} additional tool executions. Continuing with the task...` : "Tool execution limit was reset. Continuing with the task...";
    return { role: "system", content };
  }
  /**
   * Adds continuation notice to chat UI.
   * @param continueMessage The message object for the notice
   */
  async addContinuationNotice(continueMessage) {
    const { BotMessage: BotMessage2 } = await Promise.resolve().then(() => (init_BotMessage(), BotMessage_exports));
    const continuationNotice = new BotMessage2(this.plugin.app, this.plugin, continueMessage.content);
    const element = continuationNotice.getElement();
    element.style.opacity = "0.8";
    element.style.fontStyle = "italic";
    this.messagesContainer.appendChild(element);
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  /**
   * Creates new bot message for continuation response.
   * @returns Promise resolving to the new BotMessage instance
   */
  async createNewBotMessage() {
    const { BotMessage: BotMessage2 } = await Promise.resolve().then(() => (init_BotMessage(), BotMessage_exports));
    const newBotMessage = new BotMessage2(this.plugin.app, this.plugin, "");
    this.messagesContainer.appendChild(newBotMessage.getElement());
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    return newBotMessage;
  }
  /**
   * Executes task continuation logic using TaskContinuation.
   * @param messages The message history
   * @param container The message DOM element
   * @param responseContent The raw response content
   * @param toolResults Tool results from the last step
   * @param chatHistory Optional chat history
   * @returns Promise resolving to the result from TaskContinuation
   */
  async executeTaskContinuation(messages, container, responseContent, toolResults, chatHistory) {
    const taskContinuation = this.createTaskContinuation();
    return await taskContinuation.continueTaskUntilFinished(
      messages,
      container,
      responseContent,
      "",
      toolResults,
      chatHistory || []
    );
  }
};

// src/components/chat/MessageRegenerator.ts
var MessageRegenerator = class {
  /**
   * @param plugin The plugin instance
   * @param messagesContainer The chat messages container element
   * @param inputContainer The chat input container element (for disabling input during regeneration)
   * @param chatHistoryManager The chat history manager instance
   * @param agentResponseHandler The agent response handler (for agent mode)
   * @param activeStream The current AbortController for streaming (shared reference)
   * @param component Optional parent component for Markdown rendering context
   */
  constructor(plugin, messagesContainer, inputContainer, chatHistoryManager, agentResponseHandler, activeStream, component) {
    this.plugin = plugin;
    this.messagesContainer = messagesContainer;
    this.inputContainer = inputContainer;
    this.chatHistoryManager = chatHistoryManager;
    this.agentResponseHandler = agentResponseHandler;
    this.activeStream = activeStream;
    this.component = component;
    __publicField(this, "responseStreamer");
    this.responseStreamer = new ResponseStreamer(
      plugin,
      agentResponseHandler,
      messagesContainer,
      activeStream,
      component
    );
  }
  /**
   * Regenerates an assistant response for a given message element.
   * Finds the correct user/assistant message pair, builds the context, and streams a new response.
   * @param messageEl The message element to regenerate (user or assistant)
   * @param buildContextMessages Function to build the initial context messages (system/context notes/etc.)
   */
  async regenerateResponse(messageEl, buildContextMessages2) {
    const textarea = this.inputContainer.querySelector("textarea");
    if (textarea) textarea.disabled = true;
    const allMessages = Array.from(this.messagesContainer.querySelectorAll(".ai-chat-message"));
    const currentIndex = allMessages.indexOf(messageEl);
    const isUserClicked = messageEl.classList.contains("user");
    let targetIndex = -1;
    if (isUserClicked) {
      for (let i = currentIndex + 1; i < allMessages.length; i++) {
        if (allMessages[i].classList.contains("assistant")) {
          targetIndex = i;
          break;
        }
        if (allMessages[i].classList.contains("user")) {
          break;
        }
      }
    } else {
      targetIndex = currentIndex;
    }
    let userMsgIndex = currentIndex;
    if (!isUserClicked) {
      userMsgIndex = currentIndex - 1;
      while (userMsgIndex >= 0 && !allMessages[userMsgIndex].classList.contains("user")) {
        userMsgIndex--;
      }
    }
    const messages = await buildContextMessages2();
    for (let i = 0; i <= userMsgIndex; i++) {
      const el = allMessages[i];
      const role = el.classList.contains("user") ? "user" : "assistant";
      const content = el.dataset.rawContent || "";
      messages.push({ role, content });
    }
    let originalTimestamp = (/* @__PURE__ */ new Date()).toISOString();
    let originalContent = "";
    let insertAfterNode = null;
    if (targetIndex !== -1) {
      const targetEl = allMessages[targetIndex];
      originalTimestamp = targetEl.dataset.timestamp || originalTimestamp;
      originalContent = targetEl.dataset.rawContent || "";
      insertAfterNode = targetEl.previousElementSibling;
      targetEl.remove();
    } else if (isUserClicked) {
      insertAfterNode = messageEl;
    } else {
      insertAfterNode = null;
    }
    const assistantContainer = await createMessageElement(
      this.plugin.app,
      "assistant",
      "",
      this.chatHistoryManager,
      this.plugin,
      (el) => this.regenerateResponse(el, buildContextMessages2),
      this.component || null
    );
    assistantContainer.dataset.timestamp = originalTimestamp;
    if (insertAfterNode && insertAfterNode.nextSibling) {
      this.messagesContainer.insertBefore(assistantContainer, insertAfterNode.nextSibling);
    } else {
      this.messagesContainer.appendChild(assistantContainer);
    }
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    try {
      await this.responseStreamer.streamAssistantResponse(
        messages,
        assistantContainer,
        originalTimestamp,
        originalContent
      );
    } catch (error) {
      if (error.name !== "AbortError") {
        new import_obsidian24.Notice(`Error: ${error.message}`);
        assistantContainer.remove();
      }
    } finally {
      if (textarea) {
        textarea.disabled = false;
        textarea.focus();
      }
      this.activeStream = null;
    }
  }
};

// src/chat.ts
init_MessageRenderer();
init_objectPool();

// src/utils/domBatcher.ts
var DOMBatcher = class {
  constructor() {
    __publicField(this, "operations", []);
    __publicField(this, "scheduledFlush", false);
  }
  /**
   * Add an element to be inserted in the next batch
   */
  addElement(element, parent, insertBefore) {
    this.operations.push({ element, parent, insertBefore });
    this.scheduleFlush();
  }
  /**
   * Add multiple elements to be inserted in the next batch
   */
  addElements(operations) {
    this.operations.push(...operations);
    this.scheduleFlush();
  }
  /**
   * Schedule a flush operation using requestAnimationFrame for optimal timing
   */
  scheduleFlush() {
    if (!this.scheduledFlush) {
      this.scheduledFlush = true;
      requestAnimationFrame(() => {
        this.flush();
        this.scheduledFlush = false;
      });
    }
  }
  /**
   * Immediately flush all pending operations
   */
  flush() {
    if (this.operations.length === 0) return;
    const operationsByParent = /* @__PURE__ */ new Map();
    for (const operation of this.operations) {
      if (!operationsByParent.has(operation.parent)) {
        operationsByParent.set(operation.parent, []);
      }
      operationsByParent.get(operation.parent).push(operation);
    }
    for (const [parent, parentOperations] of operationsByParent) {
      this.flushForParent(parent, parentOperations);
    }
    this.operations.length = 0;
  }
  /**
   * Flush operations for a specific parent using DocumentFragment
   */
  flushForParent(parent, operations) {
    const appendOperations = [];
    const insertOperations = [];
    for (const operation of operations) {
      if (operation.insertBefore) {
        insertOperations.push(operation);
      } else {
        appendOperations.push(operation);
      }
    }
    if (appendOperations.length > 0) {
      const fragment = document.createDocumentFragment();
      for (const operation of appendOperations) {
        fragment.appendChild(operation.element);
      }
      parent.appendChild(fragment);
    }
    for (const operation of insertOperations) {
      parent.insertBefore(operation.element, operation.insertBefore);
    }
  }
  /**
   * Get the number of pending operations
   */
  getPendingCount() {
    return this.operations.length;
  }
  /**
   * Clear all pending operations without executing them
   */
  clear() {
    this.operations.length = 0;
  }
};
var globalDOMBatcher = new DOMBatcher();

// src/chat.ts
init_errorHandler();
init_asyncOptimizer();
var VIEW_TYPE_CHAT = "chat-view";
var ChatView = class extends import_obsidian25.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "chatHistoryManager");
    __publicField(this, "messagesContainer");
    __publicField(this, "inputContainer");
    __publicField(this, "activeStream", null);
    __publicField(this, "referenceNoteIndicator");
    __publicField(this, "modelNameDisplay");
    __publicField(this, "agentResponseHandler", null);
    __publicField(this, "messageRegenerator", null);
    __publicField(this, "responseStreamer", null);
    __publicField(this, "messageRenderer");
    __publicField(this, "messagePool");
    __publicField(this, "domCache");
    __publicField(this, "arrayManager");
    __publicField(this, "cachedMessageElements", []);
    __publicField(this, "lastScrollHeight", 0);
    __publicField(this, "domElementCache", {});
    __publicField(this, "eventListeners", []);
    __publicField(this, "domBatcher");
    // Priority 2 Optimization: Async optimization
    __publicField(this, "scrollDebouncer");
    __publicField(this, "updateDebouncer");
    this.plugin = plugin;
    this.chatHistoryManager = new ChatHistoryManager(this.app.vault, this.plugin.manifest.id, "chat-history.json");
    this.messageRenderer = new MessageRenderer(this.app);
    this.messagePool = MessageContextPool.getInstance();
    this.domCache = new WeakCache();
    this.arrayManager = PreAllocatedArrays.getInstance();
    this.domBatcher = new DOMBatcher();
    this.scrollDebouncer = AsyncOptimizerFactory.createInputDebouncer();
    this.updateDebouncer = AsyncOptimizerFactory.createInputDebouncer();
  }
  addEventListenerWithCleanup(element, event, handler) {
    element.addEventListener(event, handler);
    this.eventListeners.push({ element, event, handler });
  }
  cacheUIElements(ui) {
    this.domElementCache.textarea = ui.textarea;
    this.domElementCache.sendButton = ui.sendButton;
    this.domElementCache.stopButton = ui.stopButton;
    this.domElementCache.copyAllButton = ui.copyAllButton;
    this.domElementCache.clearButton = ui.clearButton;
    this.domElementCache.settingsButton = ui.settingsButton;
    this.domElementCache.helpButton = ui.helpButton;
    this.domElementCache.saveNoteButton = ui.saveNoteButton;
    this.domElementCache.referenceNoteButton = ui.referenceNoteButton;
    this.domElementCache.agentModeButton = ui.agentModeButton;
    this.domElementCache.toolContinuationContainer = ui.toolContinuationContainer;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    const { contentEl } = this;
    this.prepareChatView(contentEl);
    const loadedHistory = await this.loadChatHistory();
    const ui = createChatUI(this.app, contentEl);
    this.initializeUIElements(ui);
    this.setupEventHandlers(ui);
    this.setupAgentResponseHandler();
    this.setupResponseStreamerAndRegenerator();
    this.setupAgentModeButton();
    this.setupSendAndStopButtons();
    this.setupInputHandler(ui);
    await this.loadAndRenderHistory(loadedHistory);
    this.updateReferenceNoteIndicator();
    this.registerWorkspaceAndSettingsEvents();
  }
  prepareChatView(contentEl) {
    contentEl.empty();
    contentEl.addClass("ai-chat-view");
  }
  async loadChatHistory() {
    return await withErrorHandling(
      () => this.chatHistoryManager.getHistory(),
      "ChatView",
      "loadChatHistory",
      { fallbackMessage: "Failed to load chat history" }
    ) || [];
  }
  initializeUIElements(ui) {
    this.messagesContainer = ui.messagesContainer;
    this.inputContainer = ui.inputContainer;
    this.referenceNoteIndicator = ui.referenceNoteIndicator;
    this.modelNameDisplay = ui.modelNameDisplay;
    this.cacheUIElements(ui);
    this.updateReferenceNoteIndicator();
    this.updateModelNameDisplay();
  }
  setupEventHandlers(ui) {
    this.addEventListenerWithCleanup(this.domElementCache.copyAllButton, "click", handleCopyAll(this.messagesContainer, this.plugin));
    this.addEventListenerWithCleanup(this.domElementCache.clearButton, "click", handleClearChat(this.messagesContainer, this.chatHistoryManager));
    this.addEventListenerWithCleanup(this.domElementCache.settingsButton, "click", handleSettings(this.app, this.plugin));
    this.addEventListenerWithCleanup(this.domElementCache.helpButton, "click", handleHelp(this.app));
    this.addEventListenerWithCleanup(this.domElementCache.referenceNoteButton, "click", () => {
      this.plugin.settings.referenceCurrentNote = !this.plugin.settings.referenceCurrentNote;
      this.plugin.saveSettings();
      this.updateReferenceNoteIndicator();
    });
    this.addEventListenerWithCleanup(this.domElementCache.saveNoteButton, "click", handleSaveNote(this.messagesContainer, this.plugin, this.app, this.agentResponseHandler));
  }
  setupAgentResponseHandler() {
    this.agentResponseHandler = new AgentResponseHandler({
      app: this.app,
      plugin: this.plugin,
      messagesContainer: this.messagesContainer,
      toolContinuationContainer: this.domElementCache.toolContinuationContainer,
      onToolResult: (toolResult, command) => {
        if (toolResult.success) {
          this.plugin.debugLog("info", `[chat.ts] Tool ${command.action} completed successfully`, toolResult.data);
        } else {
          this.plugin.debugLog("error", `[chat.ts] Tool ${command.action} failed:`, toolResult.error);
        }
      },
      onToolDisplay: (display) => {
        const toolWrapper = document.createElement("div");
        toolWrapper.className = "real-time-tool-display";
        toolWrapper.appendChild(display.getElement());
        const tempContainer = this.messagesContainer.querySelector(".ai-chat-message.assistant:last-child");
        if (tempContainer) {
          const messageContent = tempContainer.querySelector(".message-content");
          if (messageContent) {
            messageContent.appendChild(toolWrapper);
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
          }
        }
      }
    });
  }
  setupResponseStreamerAndRegenerator() {
    this.responseStreamer = new ResponseStreamer(
      this.plugin,
      this.agentResponseHandler,
      this.messagesContainer,
      this.activeStream,
      this
    );
    this.messageRegenerator = new MessageRegenerator(
      this.plugin,
      this.messagesContainer,
      this.inputContainer,
      this.chatHistoryManager,
      this.agentResponseHandler,
      this.activeStream
    );
  }
  setupAgentModeButton() {
    this.addEventListenerWithCleanup(this.domElementCache.agentModeButton, "click", async () => {
      const isCurrentlyEnabled = this.plugin.agentModeManager.isAgentModeEnabled();
      await this.plugin.agentModeManager.setAgentModeEnabled(!isCurrentlyEnabled);
      const agentButton2 = this.domElementCache.agentModeButton;
      if (this.plugin.agentModeManager.isAgentModeEnabled()) {
        agentButton2.classList.add("active");
        agentButton2.setAttribute("title", "Agent Mode: ON - AI can use tools");
        new import_obsidian25.Notice("Agent Mode enabled - AI can now use tools");
        if (this.agentResponseHandler) {
          this.agentResponseHandler.resetExecutionCount();
        }
      } else {
        agentButton2.classList.remove("active");
        agentButton2.setAttribute("title", "Agent Mode: OFF - Regular chat");
        new import_obsidian25.Notice("Agent Mode disabled");
      }
    });
    const agentButton = this.domElementCache.agentModeButton;
    if (this.plugin.agentModeManager.isAgentModeEnabled()) {
      agentButton.classList.add("active");
      agentButton.setAttribute("title", "Agent Mode: ON - AI can use tools");
    } else {
      agentButton.classList.remove("active");
      agentButton.setAttribute("title", "Agent Mode: OFF - Regular chat");
    }
  }
  setupSendAndStopButtons() {
    const textarea = this.domElementCache.textarea;
    const sendButton = this.domElementCache.sendButton;
    const stopButton = this.domElementCache.stopButton;
    const sendMessage = async () => {
      var _a2;
      const content = textarea.value.trim();
      if (!content) return;
      if (this.agentResponseHandler) {
        this.agentResponseHandler.resetExecutionCount();
      }
      textarea.disabled = true;
      sendButton.classList.add("hidden");
      stopButton.classList.remove("hidden");
      const userMessageEl = await createMessageElement(this.app, "user", content, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this);
      this.messagesContainer.appendChild(userMessageEl);
      this.debouncedScrollToBottom();
      textarea.value = "";
      await withErrorHandling(
        () => this.chatHistoryManager.addMessage({
          timestamp: userMessageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          sender: "user",
          role: "user",
          content
        }),
        "ChatView",
        "saveUserMessage",
        { fallbackMessage: "Failed to save user message" }
      );
      try {
        const messages = await this.buildContextMessages();
        this.addVisibleMessagesToContext(messages);
        const tempContainer = document.createElement("div");
        tempContainer.addClass("ai-chat-message", "assistant");
        tempContainer.createDiv("message-content");
        this.messagesContainer.appendChild(tempContainer);
        this.debouncedScrollToBottom();
        const responseContent = await this.streamAssistantResponse(messages, tempContainer);
        let enhancedMessageData = void 0;
        this.plugin.debugLog("debug", "[chat.ts] tempContainer.dataset.messageData exists:", !!tempContainer.dataset.messageData);
        if (tempContainer.dataset.messageData) {
          try {
            enhancedMessageData = JSON.parse(tempContainer.dataset.messageData);
            this.plugin.debugLog("debug", "[chat.ts] enhancedMessageData parsed, toolResults count:", ((_a2 = enhancedMessageData.toolResults) == null ? void 0 : _a2.length) || 0);
          } catch (e) {
            this.plugin.debugLog("warn", "[chat.ts] Failed to parse enhanced message data:", e);
          }
        }
        this.plugin.debugLog("debug", "[chat.ts] responseContent length:", responseContent.length, "trimmed length:", responseContent.trim().length);
        tempContainer.remove();
        if (responseContent.trim() !== "" || enhancedMessageData && enhancedMessageData.toolResults && enhancedMessageData.toolResults.length > 0) {
          const messageEl = await createMessageElement(
            this.app,
            "assistant",
            responseContent,
            this.chatHistoryManager,
            this.plugin,
            (el) => this.regenerateResponse(el),
            this,
            enhancedMessageData
          );
          this.messagesContainer.appendChild(messageEl);
          this.plugin.debugLog("debug", "[chat.ts] About to save message to history with toolResults:", !!(enhancedMessageData == null ? void 0 : enhancedMessageData.toolResults));
          await this.chatHistoryManager.addMessage({
            timestamp: messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            sender: "assistant",
            content: responseContent,
            ...enhancedMessageData && {
              toolResults: enhancedMessageData.toolResults,
              reasoning: enhancedMessageData.reasoning,
              taskStatus: enhancedMessageData.taskStatus
            }
          });
          this.plugin.debugLog("debug", "[chat.ts] Message saved to history successfully");
        } else {
          this.plugin.debugLog("debug", "[chat.ts] responseContent is empty and no toolResults, not saving message");
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          handleChatError(error, "sendMessage", {
            messageLength: content.length,
            agentMode: this.plugin.agentModeManager.isAgentModeEnabled()
          });
          await createMessageElement(this.app, "assistant", `Error: ${error.message}`, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this);
        }
      } finally {
        textarea.disabled = false;
        textarea.focus();
        stopButton.classList.add("hidden");
        sendButton.classList.remove("hidden");
        this.activeStream = null;
      }
    };
    this.addEventListenerWithCleanup(sendButton, "click", sendMessage);
    this.addEventListenerWithCleanup(stopButton, "click", () => {
      const myPlugin = this.plugin;
      if (myPlugin.stopAllAIStreams && typeof myPlugin.stopAllAIStreams === "function") {
        myPlugin.stopAllAIStreams();
      }
      if (this.activeStream) {
        this.activeStream.abort();
        this.activeStream = null;
      }
      textarea.disabled = false;
      textarea.focus();
      stopButton.classList.add("hidden");
      sendButton.classList.remove("hidden");
    });
  }
  setupInputHandler(ui) {
    const textarea = this.domElementCache.textarea;
    const sendButton = this.domElementCache.sendButton;
    const stopButton = this.domElementCache.stopButton;
    Promise.resolve().then(() => (init_inputHandler(), inputHandler_exports)).then(({ setupInputHandler: setupInputHandler2 }) => {
      setupInputHandler2(
        textarea,
        this.messagesContainer,
        async () => sendButton.click(),
        async (cmd) => {
          switch (cmd) {
            case "/clear":
              ui.clearButton.click();
              break;
            case "/copy":
              ui.copyAllButton.click();
              break;
            case "/save":
              ui.saveNoteButton.click();
              break;
            case "/settings":
              ui.settingsButton.click();
              break;
            case "/help":
              ui.helpButton.click();
              break;
            case "/ref":
              ui.referenceNoteButton.click();
              break;
          }
        },
        this.app,
        this.plugin,
        sendButton,
        stopButton
      );
    });
  }
  async loadAndRenderHistory(loadedHistory) {
    if (loadedHistory.length > 0) {
      this.messagesContainer.empty();
      const file = this.app.workspace.getActiveFile();
      if (file) {
        await loadChatYamlAndApplySettings({
          app: this.app,
          plugin: this.plugin,
          settings: this.plugin.settings,
          file
        });
      }
      await renderChatHistory({
        messagesContainer: this.messagesContainer,
        loadedHistory,
        chatHistoryManager: this.chatHistoryManager,
        plugin: this.plugin,
        regenerateResponse: (el) => this.regenerateResponse(el),
        scrollToBottom: true
      });
    }
  }
  registerWorkspaceAndSettingsEvents() {
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.updateReferenceNoteIndicator();
    }));
    this.plugin.onSettingsChange(() => {
      this.updateReferenceNoteIndicator();
      this.updateModelNameDisplay();
    });
  }
  async addMessage(role, content, isError = false, enhancedData) {
    const messageEl = await createMessageElement(this.app, role, content, this.chatHistoryManager, this.plugin, (el) => this.regenerateResponse(el), this, enhancedData ? { role, content, ...enhancedData } : void 0);
    const uiTimestamp = messageEl.dataset.timestamp || (/* @__PURE__ */ new Date()).toISOString();
    this.messagesContainer.appendChild(messageEl);
    this.debouncedScrollToBottom();
    await withErrorHandling(
      () => this.chatHistoryManager.addMessage({
        timestamp: uiTimestamp,
        sender: role,
        role,
        content,
        ...enhancedData || {}
      }),
      "ChatView",
      "addMessage",
      { fallbackMessage: "Failed to save chat message" }
    );
  }
  async onClose() {
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
    this.cleanupEventListeners();
    this.cleanupMemoryResources();
  }
  cleanupEventListeners() {
    for (const { element, event, handler } of this.eventListeners) {
      element.removeEventListener(event, handler);
    }
    this.eventListeners.length = 0;
  }
  cleanupMemoryResources() {
    this.cachedMessageElements.length = 0;
    this.lastScrollHeight = 0;
    this.domElementCache = {};
    if (this.domBatcher) {
      this.domBatcher.clear();
    }
  }
  async regenerateResponse(messageEl) {
    if (this.messageRegenerator) {
      await this.messageRegenerator.regenerateResponse(messageEl, () => this.buildContextMessages());
    }
  }
  updateReferenceNoteIndicator() {
    this.updateDebouncer.debounce(async () => {
      const currentFile = this.app.workspace.getActiveFile();
      const isReferenceEnabled = this.plugin.settings.referenceCurrentNote;
      const button = this.referenceNoteIndicator.previousElementSibling;
      if (isReferenceEnabled && currentFile) {
        this.referenceNoteIndicator.setText(`\u{1F4DD} Referencing: ${currentFile.basename}`);
        this.referenceNoteIndicator.style.display = "block";
        if (button && button.getAttribute("aria-label") === "Toggle referencing current note") {
          button.setText("\u{1F4DD}");
          button.classList.add("active");
        }
      } else {
        this.referenceNoteIndicator.style.display = "none";
        if (button && button.getAttribute("aria-label") === "Toggle referencing current note") {
          button.setText("\u{1F4DD}");
          button.classList.remove("active");
        }
      }
    });
  }
  updateModelNameDisplay() {
    if (!this.modelNameDisplay) return;
    let modelName = "Unknown Model";
    const settings = this.plugin.settings;
    if (settings.selectedModel && settings.availableModels) {
      const found = settings.availableModels.find((m) => m.id === settings.selectedModel);
      if (found) modelName = found.name;
      else modelName = settings.selectedModel;
    } else if (settings.selectedModel) {
      modelName = settings.selectedModel;
    }
    this.modelNameDisplay.textContent = `Model: ${modelName}`;
  }
  async buildContextMessages() {
    return await buildContextMessages({ app: this.app, plugin: this.plugin });
  }
  addVisibleMessagesToContext(messages) {
    const currentScrollHeight = this.messagesContainer.scrollHeight;
    let messageElements;
    if (this.lastScrollHeight === currentScrollHeight && this.cachedMessageElements.length > 0) {
      messageElements = this.cachedMessageElements;
    } else {
      messageElements = this.messagesContainer.querySelectorAll(".ai-chat-message");
      this.cachedMessageElements = Array.from(messageElements);
      this.lastScrollHeight = currentScrollHeight;
    }
    for (let i = 0; i < messageElements.length; i++) {
      const el = messageElements[i];
      const role = el.classList.contains("user") ? "user" : "assistant";
      const contentEl = el.querySelector(".message-content");
      const content = (contentEl == null ? void 0 : contentEl.textContent) || "";
      const messageObj = this.messagePool.acquireMessage();
      messageObj.role = role;
      messageObj.content = content;
      messages.push(messageObj);
    }
  }
  async streamAssistantResponse(messages, container, originalTimestamp, originalContent) {
    if (!this.responseStreamer) {
      throw new Error("ResponseStreamer not initialized");
    }
    const chatHistory = await this.chatHistoryManager.getHistory();
    const responseContent = await this.responseStreamer.streamAssistantResponse(
      messages,
      container,
      originalTimestamp,
      originalContent,
      chatHistory
    );
    if (originalTimestamp && responseContent.trim() !== "") {
      let messageData = void 0;
      if (container.dataset.messageData) {
        try {
          messageData = JSON.parse(container.dataset.messageData);
        } catch (e) {
        }
      }
      await this.chatHistoryManager.updateMessage(
        originalTimestamp,
        "assistant",
        originalContent || "",
        responseContent,
        messageData
      );
    }
    return responseContent;
  }
  clearMessages() {
    this.messagesContainer.empty();
    if (this.agentResponseHandler) {
      this.agentResponseHandler.resetExecutionCount();
    }
  }
  scrollMessagesToBottom() {
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  stopActiveStream() {
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
    const myPlugin = this.plugin;
    if (myPlugin.aiDispatcher && typeof myPlugin.aiDispatcher.abortAllStreams === "function") {
      myPlugin.aiDispatcher.abortAllStreams();
    }
  }
  hasActiveStream() {
    if (this.activeStream !== null) {
      return true;
    }
    const myPlugin = this.plugin;
    if (myPlugin.aiDispatcher && typeof myPlugin.aiDispatcher.hasActiveStreams === "function") {
      return myPlugin.aiDispatcher.hasActiveStreams();
    }
    return false;
  }
  /**
   * Priority 2 Optimization: Debounced scroll to bottom
   */
  debouncedScrollToBottom() {
    this.scrollDebouncer.debounce(async () => {
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    });
  }
  /**
   * Priority 2 Optimization: Batch DOM updates for better performance
   */
  batchDOMUpdates(elements, parent) {
    const operations = elements.map((element) => ({
      element,
      parent
    }));
    this.domBatcher.addElements(operations);
  }
};

// src/components/commands/viewCommands.ts
var VIEW_TYPE_MODEL_SETTINGS = "model-settings-view";
function registerViewCommands(plugin) {
  registerCommand(
    plugin,
    {
      id: "show-ai-settings",
      name: "Show AI Settings",
      callback: () => activateView(plugin.app, VIEW_TYPE_MODEL_SETTINGS)
    },
    "file-sliders",
    // Icon ID for the command palette
    "Open AI Settings"
    // Display name in the command palette
  );
  registerCommand(
    plugin,
    {
      id: "show-ai-chat",
      name: "Show AI Chat",
      callback: () => activateView(plugin.app, VIEW_TYPE_CHAT)
    },
    "message-square",
    // Icon ID for the command palette
    "Open AI Chat"
    // Display name in the command palette
  );
}

// src/utils/CollapsibleSection.ts
var CollapsibleSectionRenderer = class {
  /**
   * Creates a collapsible section with a header that can be toggled.
   * The expanded/collapsed state is persisted in plugin settings.
   * 
   * @param containerEl The parent container element to append the section to.
   * @param title The title of the collapsible section.
   * @param contentCallback Callback to populate the section content (receives the content element).
   * @param plugin The plugin instance (for settings and saving state).
   * @param settingsType The key in MyPluginSettings where expand/collapse state is stored.
   */
  static createCollapsibleSection(containerEl, title, contentCallback, plugin, settingsType) {
    var _a2;
    plugin.settings[settingsType] = plugin.settings[settingsType] || {};
    let isExpanded = (_a2 = (plugin.settings[settingsType] || {})[title]) != null ? _a2 : false;
    const collapsibleContainer = containerEl.createEl("div");
    collapsibleContainer.addClass("ai-collapsible-section");
    const headerEl = collapsibleContainer.createEl("div");
    headerEl.addClass("ai-collapsible-header");
    const arrow = headerEl.createEl("span");
    arrow.addClass("ai-collapsible-arrow");
    arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
    const titleSpan = headerEl.createEl("span");
    titleSpan.textContent = title;
    const contentEl = collapsibleContainer.createEl("div");
    contentEl.addClass("ai-collapsible-content");
    contentEl.style.display = isExpanded ? "block" : "none";
    headerEl.addEventListener("click", async () => {
      isExpanded = !isExpanded;
      contentEl.style.display = isExpanded ? "block" : "none";
      arrow.textContent = isExpanded ? "\u25BC" : "\u25B6";
      (plugin.settings[settingsType] || {})[title] = isExpanded;
      await plugin.saveSettings();
    });
    const result = contentCallback(contentEl);
    if (result instanceof Promise) {
      result.catch((error) => console.error("Error in collapsible section:", error));
    }
  }
};

// src/settings/SettingTab.ts
init_logger();

// src/settings/components/SettingCreators.ts
var import_obsidian26 = require("obsidian");
var SettingCreators = class {
  /**
   * @param plugin The plugin instance, used for saving settings.
   * @param reRenderCallback A callback function to re-render the settings tab/modal.
   */
  constructor(plugin, reRenderCallback) {
    __publicField(this, "plugin");
    __publicField(this, "reRenderCallback");
    this.plugin = plugin;
    this.reRenderCallback = reRenderCallback;
  }
  /**
   * Creates a text input setting (either single-line or multi-line).
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param placeholder The placeholder text for the input.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   * @param options Additional options for the text input (e.g., trim, undefinedIfEmpty, isTextArea).
   */
  createTextSetting(containerEl, name, desc, placeholder, getValue, setValue, options) {
    new import_obsidian26.Setting(containerEl).setName(name).setDesc(desc).then((setting) => {
      const textInputOptions = {
        trim: options == null ? void 0 : options.trim,
        undefinedIfEmpty: options == null ? void 0 : options.undefinedIfEmpty
      };
      if (options == null ? void 0 : options.isTextArea) {
        setting.addTextArea((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      } else {
        setting.addText((text) => this.configureTextInput(text, placeholder, getValue, setValue, textInputOptions));
      }
    });
  }
  /**
   * Configures a text input (either single-line or multi-line).
   * Handles value processing (trimming, setting to undefined if empty) and saving on blur.
   * @param textComponent The TextComponent or TextAreaComponent to configure.
   * @param placeholder The placeholder text.
   * @param getValue A function to get the current value.
   * @param setValue A function to set the new value.
   * @param options Additional options for processing the input value (e.g., trim, undefinedIfEmpty).
   */
  configureTextInput(textComponent, placeholder, getValue, setValue, options) {
    var _a2;
    textComponent.setPlaceholder(placeholder).setValue((_a2 = getValue()) != null ? _a2 : "").onChange((value) => {
      let processedValue = value;
      if ((options == null ? void 0 : options.trim) && processedValue) {
        processedValue = processedValue.trim();
      }
      if ((options == null ? void 0 : options.undefinedIfEmpty) && processedValue === "") {
        processedValue = void 0;
      }
      this.updateSettingValueOnly(setValue, processedValue);
    });
    textComponent.inputEl.addEventListener("blur", async () => {
      await this.plugin.saveSettings();
      this.reRenderCallback();
    });
  }
  /**
   * Helper method to update setting value without triggering a full save to disk immediately.
   * This is useful for inputs where changes are frequent (e.g., textareas) and saving should be debounced or on blur.
   * @param setValue The function to call to update the setting's value.
   * @param value The new value for the setting.
   */
  updateSettingValueOnly(setValue, value) {
    const originalSaveSettings = this.plugin.saveSettings;
    this.plugin.saveSettings = async () => {
    };
    try {
      setValue(value);
    } catch (e) {
      console.warn("Error updating setting value:", e);
    } finally {
      this.plugin.saveSettings = originalSaveSettings;
    }
  }
  /**
   * Creates a dropdown setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param options A record of option values to display names.
   * @param getValue A function to get the current value of the setting.
   * @param setValue A function to set the new value of the setting.
   */
  createDropdownSetting(containerEl, name, desc, options, getValue, setValue) {
    new import_obsidian26.Setting(containerEl).setName(name).setDesc(desc).addDropdown((drop) => {
      Object.entries(options).forEach(([key, display]) => drop.addOption(key, display));
      drop.setValue(getValue());
      drop.onChange(async (value) => {
        await setValue(value);
        this.reRenderCallback();
      });
    });
  }
  /**
   * Creates a toggle (checkbox) setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param getValue A function to get the current boolean value.
   * @param setValue A function to set the new boolean value.
   * @param onChangeCallback An optional callback to run after the value changes and settings are saved.
   */
  createToggleSetting(containerEl, name, desc, getValue, setValue, onChangeCallback) {
    new import_obsidian26.Setting(containerEl).setName(name).setDesc(desc).addToggle((toggle) => toggle.setValue(getValue()).onChange(async (value) => {
      await setValue(value);
      if (onChangeCallback) {
        onChangeCallback();
      }
      this.reRenderCallback();
    }));
  }
  /**
   * Creates a slider setting.
   * @param containerEl The HTML element to append the setting to.
   * @param name The name of the setting.
   * @param desc The description of the setting.
   * @param limits An object defining min, max, and step for the slider.
   * @param getValue A function to get the current numeric value.
   * @param setValue A function to set the new numeric value.
   */
  createSliderSetting(containerEl, name, desc, limits, getValue, setValue) {
    new import_obsidian26.Setting(containerEl).setName(name).setDesc(desc).addSlider((slider) => {
      slider.setLimits(limits.min, limits.max, limits.step).setValue(getValue()).setDynamicTooltip().onChange(async (value) => {
        await setValue(value);
        this.reRenderCallback();
      });
    });
  }
};

// src/settings/sections/GeneralSettingsSection.ts
var import_obsidian27 = require("obsidian");
var GeneralSettingsSection = class {
  /**
   * @param plugin The main plugin instance.
   * @param settingCreators An instance of SettingCreators for consistent UI element creation.
   */
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  /**
   * Renders the General Settings sections (Plugin Behavior, Date & Time, Debug) into the provided container element.
   * @param containerEl The HTML element to render the sections into.
   */
  async render(containerEl) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Plugin Behavior",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Auto-Open Model Settings",
          "Automatically open the AI model settings panel when the plugin loads.",
          () => this.plugin.settings.autoOpenModelSettings,
          async (value) => {
            this.plugin.settings.autoOpenModelSettings = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Date & Time Settings",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Include Time with System Message",
          "Add the current time along with the date to the system message",
          () => this.plugin.settings.includeTimeWithSystemMessage,
          async (value) => {
            this.plugin.settings.includeTimeWithSystemMessage = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Debug Settings",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Debug Mode",
          "Enable verbose logging and debug UI features",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.debugMode) != null ? _a2 : false;
          },
          async (value) => {
            this.plugin.settings.debugMode = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "AI Call Log Management",
      (sectionEl) => {
        new import_obsidian27.Setting(sectionEl).setName("Clear AI Call Logs").setDesc("Delete all AI call log files from the plugin's ai-calls folder.").addButton((btn) => {
          btn.setButtonText("Clear Logs").setCta().onClick(async () => {
            const { clearAICallLogs: clearAICallLogs2 } = await Promise.resolve().then(() => (init_clearAICallLogs(), clearAICallLogs_exports));
            const pluginFolder = __dirname;
            const deleted = await clearAICallLogs2(pluginFolder, "ai-calls");
            new window.Notice(`Cleared ${deleted} AI call log file(s).`);
          });
        });
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
};

// src/settings/sections/AIModelConfigurationSection.ts
var import_obsidian28 = require("obsidian");
init_aiDispatcher();
init_validationUtils();
var AIModelConfigurationSection = class {
  /**
   * @param plugin The main plugin instance.
   * @param settingCreators An instance of SettingCreators for consistent UI element creation.
   */
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  /**
   * Renders the AI Model Configuration section into the provided container element.
   * @param containerEl The HTML element to render the section into.
   */
  async render(containerEl) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "API Keys & Providers",
      async (sectionEl) => {
        CollapsibleSectionRenderer.createCollapsibleSection(
          sectionEl,
          "OpenAI Configuration",
          async (subSectionEl) => {
            this.settingCreators.createTextSetting(
              subSectionEl,
              "OpenAI API Key",
              "Enter your OpenAI API key",
              "Enter your API key",
              () => this.plugin.settings.openaiSettings.apiKey,
              async (value) => {
                if (value && !isValidOpenAIApiKey(value)) {
                  new import_obsidian28.Notice("Invalid OpenAI API Key format. Please check your key.");
                  return;
                }
                this.plugin.settings.openaiSettings.apiKey = value != null ? value : "";
                await this.plugin.saveSettings();
              }
            );
            this.settingCreators.createTextSetting(
              sectionEl,
              "OpenAI Base URL",
              "Custom base URL for OpenAI API (optional, leave empty for default)",
              "https://api.openai.com/v1",
              () => this.plugin.settings.openaiSettings.baseUrl || "",
              async (value) => {
                this.plugin.settings.openaiSettings.baseUrl = value;
                await this.plugin.saveSettings();
              },
              { trim: true, undefinedIfEmpty: true }
            );
            this.renderProviderTestSection(sectionEl, "openai", "OpenAI");
          },
          this.plugin,
          "providerConfigExpanded"
        );
        CollapsibleSectionRenderer.createCollapsibleSection(
          containerEl,
          "Anthropic Configuration",
          async (sectionEl2) => {
            this.settingCreators.createTextSetting(
              sectionEl2,
              "Anthropic API Key",
              "Enter your Anthropic API key",
              "Enter your API key",
              () => this.plugin.settings.anthropicSettings.apiKey,
              async (value) => {
                if (value && !isValidAnthropicApiKey(value)) {
                  new import_obsidian28.Notice("Invalid Anthropic API Key format. Please check your key.");
                  return;
                }
                this.plugin.settings.anthropicSettings.apiKey = value != null ? value : "";
                await this.plugin.saveSettings();
              }
            );
            this.renderProviderTestSection(sectionEl2, "anthropic", "Anthropic");
          },
          this.plugin,
          "providerConfigExpanded"
        );
        CollapsibleSectionRenderer.createCollapsibleSection(
          containerEl,
          "Google Gemini Configuration",
          async (sectionEl2) => {
            this.settingCreators.createTextSetting(
              sectionEl2,
              "Google API Key",
              "Enter your Google API key",
              "Enter your API key",
              () => this.plugin.settings.geminiSettings.apiKey,
              async (value) => {
                if (value && !isValidGoogleApiKey(value)) {
                  new import_obsidian28.Notice("Invalid Google API Key format. Please check your key.");
                  return;
                }
                this.plugin.settings.geminiSettings.apiKey = value != null ? value : "";
                await this.plugin.saveSettings();
              }
            );
            this.renderProviderTestSection(sectionEl2, "gemini", "Google Gemini");
          },
          this.plugin,
          "providerConfigExpanded"
        );
        CollapsibleSectionRenderer.createCollapsibleSection(
          containerEl,
          "Ollama Configuration",
          async (sectionEl2) => {
            this.settingCreators.createTextSetting(
              sectionEl2,
              "Ollama Server URL",
              "Enter your Ollama server URL (default: http://localhost:11434)",
              "http://localhost:11434",
              () => this.plugin.settings.ollamaSettings.serverUrl,
              async (value) => {
                if (value && !isValidUrl(value)) {
                  new import_obsidian28.Notice("Invalid Ollama Server URL format. Please enter a valid URL.");
                  return;
                }
                this.plugin.settings.ollamaSettings.serverUrl = value != null ? value : "";
                await this.plugin.saveSettings();
              }
            );
            sectionEl2.createEl("div", {
              cls: "setting-item-description",
              text: "To use Ollama:"
            });
            const steps = sectionEl2.createEl("ol");
            steps.createEl("li", { text: "Install Ollama from https://ollama.ai" });
            steps.createEl("li", { text: "Start the Ollama server" });
            steps.createEl("li", { text: 'Pull models using "ollama pull model-name"' });
            steps.createEl("li", { text: "Test connection to see available models" });
            this.renderProviderTestSection(sectionEl2, "ollama", "Ollama");
          },
          this.plugin,
          "providerConfigExpanded"
        );
      },
      this.plugin,
      "providerConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Default AI Model Settings",
      async (sectionEl) => {
        await this.renderAIModelSettings(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Model Management",
      async (sectionEl) => {
        sectionEl.createEl("h4", { text: "Available Models" });
        await this.renderAvailableModelsSection(sectionEl);
        sectionEl.createEl("h4", { text: "Model Setting Presets" });
        this.renderModelSettingPresets(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
  /**
   * Renders the provider connection test section.
   * Allows users to test their API key and fetch available models for a given provider.
   * @param containerEl The HTML element to append the section to.
   * @param provider The ID of the provider (e.g., 'openai', 'anthropic').
   * @param displayName The display name of the provider (e.g., 'OpenAI', 'Anthropic').
   */
  renderProviderTestSection(containerEl, provider, displayName) {
    const settings = this.plugin.settings[`${provider}Settings`];
    new import_obsidian28.Setting(containerEl).setName("Test Connection").setDesc(`Verify your API key and fetch available models for ${displayName}`).addButton((button) => button.setButtonText("Test").onClick(async () => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
        const result = await aiDispatcher.testConnection(provider);
        if (result.success && result.models) {
          settings.availableModels = result.models;
          settings.lastTestResult = {
            timestamp: Date.now(),
            success: true,
            message: result.message
          };
          await this.plugin.saveSettings();
          this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
          await this.plugin.saveSettings();
          new import_obsidian28.Notice(result.message);
        } else {
          settings.lastTestResult = {
            timestamp: Date.now(),
            success: false,
            message: result.message
          };
          new import_obsidian28.Notice(result.message);
        }
      } catch (error) {
        new import_obsidian28.Notice(`Error: ${error.message}`);
      } finally {
        button.setButtonText("Test");
        button.setDisabled(false);
      }
    }));
    if (settings.lastTestResult) {
      const date = new Date(settings.lastTestResult.timestamp);
      containerEl.createEl("div", {
        text: `Last test: ${date.toLocaleString()} - ${settings.lastTestResult.message}`,
        cls: settings.lastTestResult.success ? "success" : "error"
      });
    }
    if (settings.availableModels && settings.availableModels.length > 0) {
      containerEl.createEl("div", {
        text: `Available models: ${settings.availableModels.map((m) => m.name || m.id).join(", ")}`,
        cls: "setting-item-description"
      });
    }
  }
  /**
   * Renders the AI Model Settings section.
   * This includes system message, streaming, temperature, and model selection.
   * @param containerEl The HTML element to append the section to.
   */
  async renderAIModelSettings(containerEl) {
    if (this.plugin.settings.modelSettingPresets && this.plugin.settings.modelSettingPresets.length > 0) {
      const presetContainer = containerEl.createDiv();
      presetContainer.addClass("model-preset-buttons");
      presetContainer.createEl("div", { text: "Quick Presets:", cls: "setting-item-name" });
      this.plugin.settings.modelSettingPresets.forEach((preset, idx) => {
        const btn = presetContainer.createEl("button", { text: preset.name });
        btn.style.marginRight = "0.5em";
        btn.onclick = async () => {
          if (preset.selectedModel !== void 0) this.plugin.settings.selectedModel = preset.selectedModel;
          if (preset.systemMessage !== void 0) this.plugin.settings.systemMessage = preset.systemMessage;
          if (preset.temperature !== void 0) this.plugin.settings.temperature = preset.temperature;
          if (preset.enableStreaming !== void 0) this.plugin.settings.enableStreaming = preset.enableStreaming;
          await this.plugin.saveSettings();
          new import_obsidian28.Notice(`Applied preset: ${preset.name}`);
        };
      });
    }
    new import_obsidian28.Setting(containerEl).setName("System Message").setDesc("Set the system message for the AI").addTextArea((text) => {
      text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange((value) => {
        this.plugin.settings.systemMessage = value;
      });
      text.inputEl.addEventListener("blur", async () => {
        await this.plugin.saveSettings();
      });
      return text;
    });
    new import_obsidian28.Setting(containerEl).setName("Enable Streaming").setDesc("Enable or disable streaming for completions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableStreaming).onChange(async (value) => {
      this.plugin.settings.enableStreaming = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian28.Setting(containerEl).setName("Temperature").setDesc("Set the randomness of the model's output (0-1)").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian28.Setting(containerEl).setName("Refresh Available Models").setDesc("Test connections to all configured providers and refresh available models").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
      button.setButtonText("Refreshing...");
      button.setDisabled(true);
      try {
        await this.refreshAllAvailableModels();
        new import_obsidian28.Notice("Successfully refreshed available models");
      } catch (error) {
        new import_obsidian28.Notice(`Error refreshing models: ${error.message}`);
      } finally {
        button.setButtonText("Refresh Models");
        button.setDisabled(false);
      }
    }));
    await this.renderUnifiedModelDropdown(containerEl);
  }
  /**
   * Renders the unified model selection dropdown.
   * This dropdown allows users to select from all available models across all configured providers.
   * @param containerEl The HTML element to append the dropdown to.
   */
  async renderUnifiedModelDropdown(containerEl) {
    if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
      const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
      this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
      await this.plugin.saveSettings();
    }
    new import_obsidian28.Setting(containerEl).setName("Selected Model").setDesc("Choose from all available models across all configured providers").addDropdown((dropdown) => {
      if (!this.plugin.settings.availableModels || this.plugin.settings.availableModels.length === 0) {
        dropdown.addOption("", "No models available - configure providers above");
      } else {
        dropdown.addOption("", "Select a model...");
        const modelsByProvider = {};
        const enabledModels = this.plugin.settings.enabledModels || {};
        const filteredModels = this.plugin.settings.availableModels.filter((model) => enabledModels[model.id] !== false);
        filteredModels.forEach((model) => {
          if (!modelsByProvider[model.provider]) {
            modelsByProvider[model.provider] = [];
          }
          modelsByProvider[model.provider].push(model);
        });
        Object.entries(modelsByProvider).forEach(([provider, models]) => {
          models.forEach((model) => {
            dropdown.addOption(model.id, model.name);
          });
        });
      }
      dropdown.setValue(this.plugin.settings.selectedModel || "").onChange(async (value) => {
        this.plugin.settings.selectedModel = value;
        if (value) {
          const [provider] = value.split(":", 2);
          this.plugin.settings.provider = provider;
        }
        await this.plugin.saveSettings();
      });
    });
    if (this.plugin.settings.selectedModel && this.plugin.settings.availableModels) {
      const selectedModel = this.plugin.settings.availableModels.find(
        (model) => model.id === this.plugin.settings.selectedModel
      );
      if (selectedModel) {
        const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
        infoEl.setText(`Currently using: ${selectedModel.name}`);
      }
    }
  }
  /**
   * Refreshes available models from all configured providers using the dispatcher.
   * This function uses the dispatcher to refresh models from all providers.
   */
  async refreshAllAvailableModels() {
    const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
    try {
      await aiDispatcher.refreshAllProviderModels();
      this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
      await this.plugin.saveSettings();
    } catch (error) {
      console.error("Error refreshing all available models:", error);
    }
  }
  /**
   * Renders the Available Models section in the Model Management settings.
   * This section displays all models available from configured providers and allows
   * enabling/disabling models and deleting local copies of models.
   * @param containerEl The HTML element to append the section to.
   */
  async renderAvailableModelsSection(containerEl) {
    const availableModels = this.plugin.settings.availableModels || [];
    if (availableModels.length === 0) {
      containerEl.createEl("div", { text: "No models available. Configure providers and refresh to load models.", cls: "setting-item-description" });
      return;
    }
    const table = containerEl.createEl("table");
    const thead = table.createEl("thead");
    const tbody = table.createEl("tbody");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Model" });
    headerRow.createEl("th", { text: "Provider" });
    headerRow.createEl("th", { text: "Enabled" });
    headerRow.createEl("th", { text: "Actions" });
    for (const model of availableModels) {
      const row = tbody.createEl("tr");
      row.createEl("td", { text: model.name });
      row.createEl("td", { text: model.provider });
      const enabledToggle = new import_obsidian28.Setting(row.createEl("td")).setName("").setDesc("Enable or disable this model").addToggle((toggle) => {
        var _a2;
        return toggle.setValue(((_a2 = this.plugin.settings.enabledModels) == null ? void 0 : _a2[model.id]) !== false).onChange(async (value) => {
          const enabledModels = this.plugin.settings.enabledModels || {};
          enabledModels[model.id] = value ? true : false;
          this.plugin.settings.enabledModels = enabledModels;
          await this.plugin.saveSettings();
        });
      });
      const actionsCell = row.createEl("td");
      new import_obsidian28.Setting(actionsCell).setName("").setDesc("Delete local copy of this model").addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        const confirmed = confirm(`Are you sure you want to delete the local copy of the model "${model.name}"?`);
        if (confirmed) {
          try {
            await this.plugin.app.vault.adapter.remove(`ai-models/${model.id}.json`);
            const aiDispatcher = new AIDispatcher(this.plugin.app.vault, this.plugin);
            this.plugin.settings.availableModels = await aiDispatcher.getAllUnifiedModels();
            await this.plugin.saveSettings();
            new import_obsidian28.Notice(`Deleted model "${model.name}"`);
            containerEl.empty();
            await this.renderAvailableModelsSection(containerEl);
          } catch (error) {
            new import_obsidian28.Notice(`Error deleting model: ${error.message}`);
          }
        }
      })).addButton((button) => button.setButtonText("Re-download").onClick(async () => {
        const confirmed = confirm(`Are you sure you want to re-download the model "${model.name}"?`);
        if (confirmed) {
          try {
            new import_obsidian28.Notice(`Re-download feature is not yet implemented. Please pull the model again using the provider settings.`);
          } catch (error) {
            new import_obsidian28.Notice(`Error re-downloading model: ${error.message}`);
          }
        }
      }));
    }
  }
  /**
   * Renders the Model Setting Presets section.
   * This section allows users to create, edit, and delete model setting presets.
   * @param containerEl The HTML element to append the section to.
   */
  renderModelSettingPresets(containerEl) {
    containerEl.createEl("div", {
      text: "Presets let you save and quickly apply common model settings (model, temperature, system message, etc). You can add, edit, or remove presets here. In the AI Model Settings panel, you will see buttons for each preset above the model selection. Clicking a preset button will instantly apply those settings. This is useful for switching between different model configurations with one click.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const presetList = this.plugin.settings.modelSettingPresets || [];
    presetList.forEach((preset, idx) => {
      new import_obsidian28.Setting(containerEl).setName("Preset Name").setDesc("Edit the name of this preset").addText((text) => {
        text.setPlaceholder("Preset Name").setValue(preset.name).onChange((value) => {
          preset.name = value != null ? value : "";
        });
        text.inputEl.addEventListener("blur", async () => {
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian28.Setting(containerEl).setName("Model ID (provider:model)").setDesc("Edit the model for this preset").addText((text) => {
        text.setPlaceholder("Model ID (provider:model)").setValue(preset.selectedModel || "").onChange((value) => {
          preset.selectedModel = value != null ? value : "";
        });
        text.inputEl.addEventListener("blur", async () => {
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian28.Setting(containerEl).setName("System Message").setDesc("Edit the system message for this preset").addTextArea((text) => {
        text.setPlaceholder("System message").setValue(preset.systemMessage || "").onChange((value) => {
          preset.systemMessage = value != null ? value : "";
        });
        text.inputEl.addEventListener("blur", async () => {
          await this.plugin.saveSettings();
        });
      });
      this.settingCreators.createSliderSetting(containerEl, "Temperature", "", { min: 0, max: 1, step: 0.1 }, () => {
        var _a2;
        return (_a2 = preset.temperature) != null ? _a2 : 0.7;
      }, async (value) => {
        preset.temperature = value;
        await this.plugin.saveSettings();
      });
      this.settingCreators.createToggleSetting(containerEl, "Enable Streaming", "", () => {
        var _a2;
        return (_a2 = preset.enableStreaming) != null ? _a2 : true;
      }, async (value) => {
        preset.enableStreaming = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian28.Setting(containerEl).addExtraButton(
        (btn) => btn.setIcon("cross").setTooltip("Delete").onClick(async () => {
          var _a2;
          (_a2 = this.plugin.settings.modelSettingPresets) == null ? void 0 : _a2.splice(idx, 1);
          await this.plugin.saveSettings();
        })
      );
    });
    new import_obsidian28.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Add Preset").setCta().onClick(async () => {
        if (!this.plugin.settings.modelSettingPresets) this.plugin.settings.modelSettingPresets = [];
        this.plugin.settings.modelSettingPresets.push(JSON.parse(JSON.stringify({
          name: `Preset ${this.plugin.settings.modelSettingPresets.length + 1}`,
          selectedModel: this.plugin.settings.selectedModel,
          systemMessage: this.plugin.settings.systemMessage,
          temperature: this.plugin.settings.temperature,
          enableStreaming: this.plugin.settings.enableStreaming
        })));
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/settings/sections/AgentSettingsSection.ts
init_toolcollect();
init_promptConstants();
var AgentSettingsSection = class {
  /**
   * @param app The Obsidian App instance.
   * @param plugin The main plugin instance.
   * @param settingCreators An instance of SettingCreators for consistent UI element creation.
   */
  constructor(app, plugin, settingCreators) {
    __publicField(this, "app");
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.app = app;
    this.plugin = plugin;
    this.settingCreators = settingCreators;
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("debug", "[AgentSettingsSection] constructor called");
    }
  }
  /**
   * Renders the Agent Mode settings section into the provided container element.
   * @param containerEl The HTML element to render the section into.
   */
  async render(containerEl) {
    if (this.plugin && typeof this.plugin.debugLog === "function") {
      this.plugin.debugLog("info", "[AgentSettingsSection] render called");
    }
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Mode Settings",
      (sectionEl) => {
        sectionEl.createEl("div", {
          text: "Agent Mode allows the AI to use tools like file creation, reading, and modification. Configure the limits and behavior for tool usage.",
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em;" }
        });
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Enable Agent Mode by Default",
          "Start new conversations with Agent Mode enabled.",
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.enabled) != null ? _b : false;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
            }
            this.plugin.settings.agentMode.enabled = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createSliderSetting(
          sectionEl,
          "Max Tool Calls per Conversation",
          "Maximum number of tools the AI can use in a single conversation to prevent runaway execution.",
          { min: 1, max: 50, step: 1 },
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxToolCalls) != null ? _b : 10;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
            }
            this.plugin.settings.agentMode.maxToolCalls = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createSliderSetting(
          sectionEl,
          "Tool Execution Timeout (seconds)",
          "Maximum time to wait for each tool to complete before timing out.",
          { min: 5, max: 300, step: 5 },
          () => {
            var _a2, _b;
            return ((_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.timeoutMs) != null ? _b : 3e4) / 1e3;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
            }
            this.plugin.settings.agentMode.timeoutMs = value * 1e3;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createSliderSetting(
          sectionEl,
          "Max Iterations per Task Continuation",
          "Maximum number of times the agent can iterate in a single task continuation to prevent infinite loops.",
          { min: 1, max: 20, step: 1 },
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.agentMode) == null ? void 0 : _a2.maxIterations) != null ? _b : 10;
          },
          async (value) => {
            if (!this.plugin.settings.agentMode) {
              this.plugin.settings.agentMode = { enabled: false, maxToolCalls: 10, timeoutMs: 3e4, maxIterations: 10 };
            }
            this.plugin.settings.agentMode.maxIterations = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent System Message",
      (sectionEl) => {
        sectionEl.createEl("div", {
          text: "Customize the system message used when Agent Mode is enabled. Use {{TOOL_DESCRIPTIONS}} to include the available tools list.",
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 0.5em;" }
        });
        const agentMessageContainer = sectionEl.createDiv("agent-message-container");
        agentMessageContainer.style.display = "flex";
        agentMessageContainer.style.gap = "0.5em";
        agentMessageContainer.style.alignItems = "flex-start";
        agentMessageContainer.style.marginBottom = "1em";
        const textareaContainer = agentMessageContainer.createDiv();
        textareaContainer.style.flex = "1";
        const textarea = textareaContainer.createEl("textarea");
        textarea.rows = 8;
        textarea.style.width = "100%";
        textarea.style.minHeight = "120px";
        textarea.style.fontFamily = "monospace";
        textarea.style.fontSize = "0.9em";
        textarea.placeholder = "Enter custom agent system message template...";
        textarea.value = this.plugin.settings.customAgentSystemMessage || "";
        const buttonContainer = agentMessageContainer.createDiv();
        buttonContainer.style.display = "flex";
        buttonContainer.style.flexDirection = "column";
        buttonContainer.style.gap = "0.25em";
        const resetButton = buttonContainer.createEl("button", { text: "Reset to Default" });
        resetButton.style.padding = "0.25em 0.5em";
        resetButton.style.fontSize = "0.8em";
        resetButton.addEventListener("click", async () => {
          textarea.value = AGENT_SYSTEM_PROMPT_TEMPLATE;
          this.plugin.settings.customAgentSystemMessage = AGENT_SYSTEM_PROMPT_TEMPLATE;
          await this.plugin.saveSettings();
        });
        const clearButton = buttonContainer.createEl("button", { text: "Use Default" });
        clearButton.style.padding = "0.25em 0.5em";
        clearButton.style.fontSize = "0.8em";
        clearButton.addEventListener("click", async () => {
          textarea.value = "";
          this.plugin.settings.customAgentSystemMessage = void 0;
          await this.plugin.saveSettings();
        });
        textarea.addEventListener("input", async () => {
          const value = textarea.value.trim();
          this.plugin.settings.customAgentSystemMessage = value || void 0;
          await this.plugin.saveSettings();
        });
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Tools",
      (sectionEl) => {
        this.renderToolToggles(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
  /**
   * Renders the Tool Enable/Disable section.
   * Allows users to enable or disable individual tools available to the agent.
   * @param containerEl The HTML element to append the section to.
   */
  renderToolToggles(containerEl) {
    containerEl.createEl("div", {
      text: "Enable or disable individual agent tools. Disabled tools will not be available to the agent or appear in the system prompt.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 0.5em;" }
    });
    const tools = createToolInstances(this.app, this.plugin);
    if (!this.plugin.settings.enabledTools) {
      this.plugin.settings.enabledTools = {};
    }
    tools.forEach((tool) => {
      if (!tool) {
        console.error("[AI Assistant] Settings: Encountered an undefined tool object in tools array!");
        return;
      }
      if (typeof tool.name === "undefined") {
        console.error("[AI Assistant] Settings: CRITICAL - Tool object has undefined name:", tool);
      }
      if (tool.name === "thought") {
        if (!this.plugin.settings.enabledTools) {
          this.plugin.settings.enabledTools = {};
        }
        this.plugin.settings.enabledTools["thought"] = true;
        return;
      }
      this.settingCreators.createToggleSetting(
        containerEl,
        `${tool.name} (${tool.description})`,
        `Enable or disable the "${tool.name}" tool.`,
        () => {
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to get toggle state for tool with undefined name!");
            return false;
          }
          return !!this.plugin.settings.enabledTools && this.plugin.settings.enabledTools[tool.name] !== false;
        },
        async (value) => {
          if (typeof tool.name === "undefined") {
            console.error("[AI Assistant] Settings: CRITICAL - Trying to set toggle state for tool with undefined name! Skipping save.");
            return;
          }
          if (!this.plugin.settings.enabledTools) {
            this.plugin.settings.enabledTools = {};
          }
          this.plugin.settings.enabledTools[tool.name] = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
};

// src/settings/sections/ContentNoteHandlingSection.ts
var import_obsidian29 = require("obsidian");
var ContentNoteHandlingSection = class {
  /**
   * @param plugin The main plugin instance.
   * @param settingCreators An instance of SettingCreators for consistent UI element creation.
   */
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  /**
   * Renders the Content & Note Handling settings sections into the provided container element.
   * This includes chat customization, note reference settings, data handling, and YAML attribute generators.
   * @param containerEl The HTML element to render the sections into.
   */
  async render(containerEl) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Chat Customization",
      (sectionEl) => {
        this.settingCreators.createTextSetting(
          sectionEl,
          "Chat Separator",
          "The string used to separate chat messages.",
          "----",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatSeparator) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatSeparator = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createTextSetting(
          sectionEl,
          "Chat Start String",
          "The string that indicates where to start taking the note for context.",
          "===START===",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatStartString) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatStartString = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createTextSetting(
          sectionEl,
          "Chat End String",
          "The string that indicates where to end taking the note for context.",
          "===END===",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatEndString) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatEndString = value != null ? value : "";
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createTextSetting(
          sectionEl,
          "Title Prompt",
          "The prompt used for generating note titles.",
          "You are a title generator...",
          () => this.plugin.settings.titlePrompt,
          async (value) => {
            this.plugin.settings.titlePrompt = value != null ? value : "";
            await this.plugin.saveSettings();
          },
          { isTextArea: true }
        );
        this.settingCreators.createDropdownSetting(
          sectionEl,
          "Title Output Mode",
          "Choose what to do with the generated note title.",
          { "clipboard": "Copy to clipboard", "replace-filename": "Replace note filename", "metadata": "Insert into metadata" },
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.titleOutputMode) != null ? _a2 : "clipboard";
          },
          async (value) => {
            this.plugin.settings.titleOutputMode = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createDropdownSetting(
          sectionEl,
          "Summary Output Mode",
          "Choose what to do with the generated note summary.",
          { "clipboard": "Copy to clipboard", "metadata": "Insert into metadata" },
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.summaryOutputMode) != null ? _a2 : "clipboard";
          },
          async (value) => {
            this.plugin.settings.summaryOutputMode = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Note Reference Settings",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Enable Obsidian Links",
          "Read Obsidian links in messages using [[filename]] syntax",
          () => this.plugin.settings.enableObsidianLinks,
          async (value) => {
            this.plugin.settings.enableObsidianLinks = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Enable Context Notes",
          "Attach specified note content to chat messages",
          () => this.plugin.settings.enableContextNotes,
          async (value) => {
            this.plugin.settings.enableContextNotes = value;
            await this.plugin.saveSettings();
          }
        );
        const contextNotesContainer = sectionEl.createDiv("context-notes-container");
        contextNotesContainer.style.marginBottom = "24px";
        new import_obsidian29.Setting(contextNotesContainer).setName("Context Notes").setDesc("Notes to attach as context (supports [[filename]] and [[another note#header]] syntax)").addTextArea((text) => {
          text.setPlaceholder("[[Note Name]]\n[[Another Note#Header]]").setValue(this.plugin.settings.contextNotes || "").onChange((value) => {
            this.plugin.settings.contextNotes = value;
          });
          text.inputEl.addEventListener("blur", async () => {
            await this.plugin.saveSettings();
          });
          text.inputEl.rows = 4;
          text.inputEl.style.width = "100%";
        });
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Data Handling",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Expand Linked Notes Recursively",
          "If enabled, when fetching a note, also fetch and expand links within that note recursively (prevents infinite loops).",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.expandLinkedNotesRecursively) != null ? _a2 : false;
          },
          async (value) => {
            this.plugin.settings.expandLinkedNotesRecursively = value;
            await this.plugin.saveSettings();
          }
        );
        if (this.plugin.settings.expandLinkedNotesRecursively) {
          this.settingCreators.createSliderSetting(
            sectionEl,
            "Max Link Expansion Depth",
            "Maximum depth for recursively expanding linked notes (1-3).",
            { min: 1, max: 3, step: 1 },
            () => {
              var _a2;
              return (_a2 = this.plugin.settings.maxLinkExpansionDepth) != null ? _a2 : 2;
            },
            async (value) => {
              this.plugin.settings.maxLinkExpansionDepth = value;
              await this.plugin.saveSettings();
            }
          );
        }
        this.settingCreators.createTextSetting(
          sectionEl,
          "Chat Note Folder",
          "Folder to save exported chat notes (relative to vault root, leave blank for root)",
          "e.g. AI Chats",
          () => {
            var _a2;
            return (_a2 = this.plugin.settings.chatNoteFolder) != null ? _a2 : "";
          },
          async (value) => {
            this.plugin.settings.chatNoteFolder = value != null ? value : "";
            await this.plugin.saveSettings();
          },
          { trim: true }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "YAML Attribute Generators",
      (sectionEl) => {
        this.renderYamlAttributeGenerators(sectionEl);
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
  /**
   * Renders the YAML Attribute Generators section.
   * This section allows users to define custom YAML attributes that can be generated by the AI
   * and inserted into notes.
   * @param containerEl The HTML element to append the section to.
   */
  renderYamlAttributeGenerators(containerEl) {
    var _a2;
    containerEl.createEl("div", {
      text: "Configure custom YAML attribute generators. Each entry will create a command to generate and insert/update a YAML field in your notes.",
      cls: "setting-item-description",
      attr: { style: "margin-bottom: 1em;" }
    });
    const yamlGens = (_a2 = this.plugin.settings.yamlAttributeGenerators) != null ? _a2 : [];
    yamlGens.forEach((gen, idx) => {
      const autoCommandName = gen.attributeName ? `Generate YAML: ${gen.attributeName}` : `YAML Generator #${idx + 1}`;
      const genContainer = containerEl.createDiv({ cls: "yaml-generator-container" });
      genContainer.style.border = "1px solid var(--background-modifier-border)";
      genContainer.style.borderRadius = "6px";
      genContainer.style.padding = "1em";
      genContainer.style.marginBottom = "1em";
      genContainer.createEl("h4", { text: autoCommandName });
      new import_obsidian29.Setting(genContainer).setName("YAML Attribute Name").setDesc("The YAML field name to insert/update").addText((text) => {
        text.setPlaceholder("YAML Attribute Name").setValue(gen.attributeName).onChange((value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].attributeName = value != null ? value : "";
            this.plugin.settings.yamlAttributeGenerators[idx].commandName = value ? `Generate YAML: ${value}` : "";
          }
        });
        text.inputEl.addEventListener("blur", async () => {
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian29.Setting(genContainer).setName("Prompt for LLM").setDesc("The prompt to send to the AI for generating the YAML value").addTextArea((text) => {
        text.setPlaceholder("Prompt for LLM").setValue(gen.prompt).onChange((value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].prompt = value != null ? value : "";
          }
        });
        text.inputEl.addEventListener("blur", async () => {
          await this.plugin.saveSettings();
        });
        text.inputEl.rows = 3;
        text.inputEl.style.width = "100%";
      });
      new import_obsidian29.Setting(genContainer).setName("Output Mode").setDesc("Where to put the generated YAML attribute").addDropdown((drop) => {
        drop.addOption("clipboard", "Copy to clipboard");
        drop.addOption("metadata", "Insert into metadata");
        drop.setValue(gen.outputMode);
        drop.onChange(async (value) => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators[idx].outputMode = value;
            await this.plugin.saveSettings();
          }
        });
      });
      new import_obsidian29.Setting(genContainer).addExtraButton((btn) => {
        btn.setIcon("cross").setTooltip("Delete this YAML generator").onClick(async () => {
          if (this.plugin.settings.yamlAttributeGenerators) {
            this.plugin.settings.yamlAttributeGenerators.splice(idx, 1);
            await this.plugin.saveSettings();
          }
        });
      });
    });
    new import_obsidian29.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add YAML Attribute Generator").setCta().onClick(async () => {
        if (!this.plugin.settings.yamlAttributeGenerators) this.plugin.settings.yamlAttributeGenerators = [];
        this.plugin.settings.yamlAttributeGenerators.push(JSON.parse(JSON.stringify({
          attributeName: "",
          prompt: "",
          outputMode: "metadata",
          commandName: "New YAML Generator"
        })));
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/settings/sections/BackupManagementSection.ts
var import_obsidian30 = require("obsidian");

// src/settings/components/DialogHelpers.ts
var DialogHelpers = class {
  /**
   * Shows a confirmation dialog to the user.
   * This is a custom modal implementation, not using Obsidian's built-in Modal class directly.
   * @param title The title of the confirmation dialog.
   * @param message The message to display in the dialog.
   * @returns A Promise that resolves to true if the user confirms, false otherwise.
   */
  static showConfirmationDialog(title, message) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "ai-assistant-modal";
      const content = modal.createDiv();
      content.className = "ai-assistant-modal-content";
      content.createEl("h3", { text: title });
      content.createEl("p", { text: message });
      const buttonContainer = content.createDiv();
      buttonContainer.className = "ai-assistant-modal-buttons";
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(false);
      };
      const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" });
      confirmBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(true);
      };
      document.body.appendChild(modal);
      modal.onclick = (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          resolve(false);
        }
      };
    });
  }
};

// src/settings/sections/BackupManagementSection.ts
init_typeGuards();
var BackupManagementSection = class {
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  /**
   * Render both Backup and Trash Management sections
   */
  async render(containerEl) {
    await this.renderBackupManagement(containerEl);
    await this.renderTrashManagement(containerEl);
  }
  /**
   * Render the Backup Management section
   */
  async renderBackupManagement(containerEl) {
    this.renderSectionHeader(
      containerEl,
      "Backup Management",
      "Manage backups created when files are modified by AI tools. Backups are stored in the plugin data folder, not in your vault.",
      async (sectionEl) => {
        const backupManager = this.plugin.backupManager;
        const [totalBackups, totalSize, backupFiles] = await Promise.all([
          backupManager.getTotalBackupCount(),
          backupManager.getTotalBackupSize(),
          backupManager.getAllBackupFiles()
        ]);
        const sizeInKB = Math.round(totalSize / 1024);
        sectionEl.createEl("div", {
          text: `Total backups: ${totalBackups} (${sizeInKB} KB)`,
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em; font-weight: bold;" }
        });
        this.renderBackupActions(sectionEl, backupFiles.length > 0, async () => {
          await this.renderBackupManagement(containerEl);
        }, async () => {
          const confirmed = await DialogHelpers.showConfirmationDialog(
            "Delete All Backups",
            `Are you sure you want to delete ALL ${totalBackups} backups for ALL files? This action cannot be undone and will permanently remove all backup data.`
          );
          if (confirmed) {
            try {
              await backupManager.deleteAllBackups();
              new import_obsidian30.Notice("Deleted all backups successfully");
              await this.renderBackupManagement(containerEl);
            } catch (error) {
              new import_obsidian30.Notice(`Error deleting all backups: ${error.message}`);
            }
          }
        });
        if (backupFiles.length === 0) {
          sectionEl.createEl("div", {
            text: "No backups found.",
            cls: "setting-item-description"
          });
          return;
        }
        CollapsibleSectionRenderer.createCollapsibleSection(
          containerEl,
          "Backup Files List",
          (backupListEl) => {
            this.renderBackupFilesList(backupListEl, backupFiles, backupManager);
          },
          this.plugin,
          "backupManagementExpanded"
        );
      }
    );
  }
  /**
   * Render header and description for a section using CollapsibleSectionRenderer
   */
  renderSectionHeader(containerEl, title, description, contentCallback) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      title,
      (sectionEl) => {
        sectionEl.createEl("div", {
          text: description,
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em;" }
        });
        const result = contentCallback(sectionEl);
        if (result instanceof Promise) {
          result.catch((error) => console.error("Error in collapsible section:", error));
        }
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
  /**
   * Render action buttons for backup management
   */
  renderBackupActions(containerEl, hasBackups, onRefresh, onDeleteAll) {
    const actionsContainer = containerEl.createDiv({ attr: { style: "margin-bottom: 1em;" } });
    const refreshButton = actionsContainer.createEl("button", {
      text: "Refresh Backup List",
      cls: "mod-cta"
    });
    refreshButton.style.marginRight = "0.5em";
    refreshButton.onclick = onRefresh;
    if (hasBackups) {
      const deleteAllBtn = actionsContainer.createEl("button", {
        text: "Delete All Backups",
        cls: "mod-warning"
      });
      deleteAllBtn.onclick = onDeleteAll;
    }
  }
  /**
   * Render the list of backup files and their actions
   */
  async renderBackupFilesList(containerEl, backupFiles, backupManager) {
    for (const filePath of backupFiles) {
      const backups = await backupManager.getBackupsForFile(filePath);
      if (backups.length === 0) continue;
      const fileSection = containerEl.createDiv({ cls: "backup-file-section" });
      fileSection.createEl("h4", { text: filePath, cls: "backup-file-path" });
      const backupList = fileSection.createDiv({ cls: "backup-list" });
      backups.forEach((backup) => {
        const backupItem = backupList.createDiv({ cls: "backup-item" });
        const backupInfo = backupItem.createDiv({ cls: "backup-info" });
        const sizeKB = backup.fileSize ? Math.round(backup.fileSize / 1024) : 0;
        const fileType = backup.isBinary ? "Binary" : "Text";
        backupInfo.createEl("span", {
          text: `${backup.readableTimestamp} (${sizeKB} KB, ${fileType})`,
          cls: "backup-timestamp"
        });
        const backupActions = backupItem.createDiv({ cls: "backup-actions" });
        this.renderBackupActionButtons(backupActions, backup, filePath, backupManager, containerEl, backupFiles);
      });
      this.renderDeleteAllBackupsForFileButton(fileSection, filePath, backups.length, backupManager, containerEl, backupFiles);
    }
  }
  /**
   * Render action buttons for each backup
   */
  renderBackupActionButtons(backupActions, backup, filePath, backupManager, containerEl, backupFiles) {
    const restoreBtn = backupActions.createEl("button", {
      text: "Restore",
      cls: "mod-cta"
    });
    restoreBtn.onclick = async () => {
      const confirmed = await DialogHelpers.showConfirmationDialog(
        "Restore Backup",
        `Are you sure you want to restore the backup from ${backup.readableTimestamp}? This will overwrite the current file content.`
      );
      if (confirmed) {
        try {
          const result = await backupManager.restoreBackup(backup);
          if (result.success) {
            new import_obsidian30.Notice(`Successfully restored backup for ${filePath}`);
          } else {
            new import_obsidian30.Notice(`Failed to restore backup: ${result.error}`);
          }
        } catch (error) {
          new import_obsidian30.Notice(`Error restoring backup: ${error.message}`);
        }
      }
    };
    const deleteBtn = backupActions.createEl("button", {
      text: "Delete",
      cls: "mod-warning"
    });
    deleteBtn.onclick = async () => {
      const confirmed = await DialogHelpers.showConfirmationDialog(
        "Delete Backup",
        `Are you sure you want to delete the backup from ${backup.readableTimestamp}?`
      );
      if (confirmed) {
        try {
          await backupManager.deleteSpecificBackup(filePath, backup.timestamp);
          new import_obsidian30.Notice(`Deleted backup for ${filePath}`);
          containerEl.empty();
          await this.renderBackupFilesList(containerEl, backupFiles, backupManager);
        } catch (error) {
          new import_obsidian30.Notice(`Error deleting backup: ${error.message}`);
        }
      }
    };
    if (!backup.isBinary && backup.content) {
      const previewBtn = backupActions.createEl("button", {
        text: "Preview",
        cls: "mod-muted"
      });
      previewBtn.onclick = () => {
        const preview = backup.content.substring(0, 200);
        const truncated = backup.content.length > 200 ? "..." : "";
        new import_obsidian30.Notice(`Preview: ${preview}${truncated}`, 1e4);
      };
    } else if (backup.isBinary) {
      const infoBtn = backupActions.createEl("button", {
        text: "File Info",
        cls: "mod-muted"
      });
      infoBtn.onclick = () => {
        const sizeKB = backup.fileSize ? Math.round(backup.fileSize / 1024) : 0;
        new import_obsidian30.Notice(`Binary file backup: ${sizeKB} KB
Stored at: ${backup.backupFilePath || "Unknown location"}`, 5e3);
      };
    }
  }
  /**
   * Render delete all backups for a file button
   */
  renderDeleteAllBackupsForFileButton(fileSection, filePath, backupCount, backupManager, containerEl, backupFiles) {
    const deleteAllBtn = fileSection.createEl("button", {
      text: `Delete All Backups for ${filePath}`,
      cls: "mod-warning"
    });
    deleteAllBtn.onclick = async () => {
      const confirmed = await DialogHelpers.showConfirmationDialog(
        "Delete All Backups",
        `Are you sure you want to delete all ${backupCount} backups for ${filePath}?`
      );
      if (confirmed) {
        try {
          await backupManager.deleteBackupsForFile(filePath);
          new import_obsidian30.Notice(`Deleted all backups for ${filePath}`);
          containerEl.empty();
          await this.renderBackupFilesList(containerEl, backupFiles, backupManager);
        } catch (error) {
          new import_obsidian30.Notice(`Error deleting backups: ${error.message}`);
        }
      }
    };
  }
  /**
   * Render the Trash Management section
   */
  async renderTrashManagement(containerEl) {
    containerEl.createEl("div", { attr: { style: "margin-top: 2em; border-top: 1px solid var(--background-modifier-border); padding-top: 1em;" } });
    this.renderSectionHeader(
      containerEl,
      "Trash Management",
      "Manage files and folders moved to the .trash folder. Files in trash can be restored or permanently deleted.",
      async (sectionEl) => {
        const trashPath = ".trash";
        let trashFolder = this.plugin.app.vault.getAbstractFileByPath(trashPath);
        let trashItems = [];
        let fallbackUsed = false;
        if (!trashFolder) {
          fallbackUsed = true;
          try {
            const adapter = this.plugin.app.vault.adapter;
            if (await adapter.exists(trashPath)) {
              const files = await adapter.list(trashPath);
              trashItems = [
                ...files.files.map((f) => ({ name: f.substring(f.lastIndexOf("/") + 1), isFolder: false })),
                ...files.folders.map((f) => ({ name: f.substring(f.lastIndexOf("/") + 1), isFolder: true }))
              ];
            } else {
              sectionEl.createEl("div", {
                text: "No trash folder found. Trash folder will be created automatically when files are deleted with soft delete.",
                cls: "setting-item-description"
              });
              return;
            }
          } catch (e) {
            sectionEl.createEl("div", {
              text: "Error reading trash folder from file system.",
              cls: "setting-item-description"
            });
            return;
          }
        } else if (trashFolder instanceof import_obsidian30.TFolder) {
          trashItems = trashFolder.children.map((item) => ({
            name: item.name,
            isFolder: item instanceof import_obsidian30.TFolder,
            size: isTFile(item) && item.stat ? item.stat.size : void 0
          }));
        } else {
          sectionEl.createEl("div", {
            text: "Error: .trash exists but is not a folder.",
            cls: "setting-item-description"
          });
          return;
        }
        const fileCount = trashItems.filter((item) => !item.isFolder).length;
        const folderCount = trashItems.filter((item) => item.isFolder).length;
        sectionEl.createEl("div", {
          text: `Trash contains: ${fileCount} files, ${folderCount} folders${fallbackUsed ? " (filesystem fallback)" : ""}`,
          cls: "setting-item-description",
          attr: { style: "margin-bottom: 1em; font-weight: bold;" }
        });
        this.renderTrashActions(sectionEl, trashItems.length > 0, async () => {
          await this.renderTrashManagement(containerEl);
        }, async () => {
          const confirmed = await DialogHelpers.showConfirmationDialog(
            "Empty Trash",
            `Are you sure you want to permanently delete all ${trashItems.length} items in trash? This cannot be undone.`
          );
          if (confirmed) {
            try {
              const adapter = this.plugin.app.vault.adapter;
              for (const item of trashItems) {
                const fullPath = `${trashPath}/${item.name}`;
                if (item.isFolder) {
                  await adapter.rmdir(fullPath, true);
                } else {
                  await adapter.remove(fullPath);
                }
              }
              new import_obsidian30.Notice(`Emptied trash - permanently deleted ${trashItems.length} items`);
              await this.renderTrashManagement(containerEl);
            } catch (error) {
              new import_obsidian30.Notice(`Error emptying trash: ${error.message}`);
            }
          }
        });
        if (trashItems.length === 0) {
          sectionEl.createEl("div", {
            text: "Trash is empty.",
            cls: "setting-item-description"
          });
          return;
        }
        this.renderTrashList(sectionEl, trashItems, fallbackUsed);
      }
    );
  }
  /**
   * Render action buttons for trash management
   */
  renderTrashActions(containerEl, hasTrash, onRefresh, onEmpty) {
    const actionsContainer = containerEl.createDiv({ attr: { style: "margin-bottom: 1em;" } });
    const refreshBtn = actionsContainer.createEl("button", {
      text: "Refresh Trash",
      cls: "mod-cta"
    });
    refreshBtn.style.marginRight = "0.5em";
    refreshBtn.onclick = onRefresh;
    if (hasTrash) {
      const emptyTrashBtn = actionsContainer.createEl("button", {
        text: "Empty Trash",
        cls: "mod-warning"
      });
      emptyTrashBtn.style.marginRight = "0.5em";
      emptyTrashBtn.onclick = onEmpty;
    }
  }
  /**
   * Render the list of trash items and their actions
   */
  renderTrashList(containerEl, trashItems, fallbackUsed) {
    const trashList = containerEl.createDiv({ cls: "trash-list" });
    const maxItems = 20;
    for (const item of trashItems.slice(0, maxItems)) {
      const trashItem = trashList.createDiv({ cls: "trash-item", attr: { style: "margin-bottom: 0.5em; padding: 0.5em; border: 1px solid var(--background-modifier-border); border-radius: 4px;" } });
      const itemInfo = trashItem.createDiv({ cls: "trash-item-info" });
      const icon = item.isFolder ? "\u{1F4C1}" : "\u{1F4C4}";
      const size = !item.isFolder && item.size ? ` (${Math.round(item.size / 1024)} KB)` : "";
      itemInfo.createEl("span", {
        text: `${icon} ${item.name}${size}`,
        cls: "trash-item-name"
      });
      const itemActions = trashItem.createDiv({ cls: "trash-item-actions", attr: { style: "margin-top: 0.5em;" } });
      if (!fallbackUsed) {
        this.renderRestoreTrashButton(itemActions, item.name, item.isFolder, containerEl);
      }
      this.renderDeleteTrashButton(itemActions, item.name, item.isFolder, containerEl);
    }
    if (trashItems.length > maxItems) {
      containerEl.createEl("div", {
        text: `... and ${trashItems.length - maxItems} more items. Empty trash to remove all items.`,
        cls: "setting-item-description",
        attr: { style: "margin-top: 1em; font-style: italic;" }
      });
    }
  }
  /**
   * Render restore button for trash item
   */
  renderRestoreTrashButton(itemActions, name, isFolder, containerEl) {
    const restoreBtn = itemActions.createEl("button", {
      text: "Restore",
      cls: "mod-cta"
    });
    restoreBtn.style.marginRight = "0.5em";
    restoreBtn.onclick = async () => {
      const confirmed = await DialogHelpers.showConfirmationDialog(
        "Restore Item",
        `Restore "${name}" to vault root? If an item with the same name exists, it will be overwritten.`
      );
      if (confirmed) {
        try {
          const trashFolderObj = this.plugin.app.vault.getAbstractFileByPath(".trash");
          if (trashFolderObj instanceof import_obsidian30.TFolder) {
            const fileObj = trashFolderObj.children.find((child) => child.name === name);
            if (fileObj) {
              const newPath = name;
              await this.plugin.app.fileManager.renameFile(fileObj, newPath);
              new import_obsidian30.Notice(`Restored "${name}" to vault root`);
              await this.renderTrashManagement(containerEl.parentElement);
            }
          }
        } catch (error) {
          new import_obsidian30.Notice(`Error restoring item: ${error.message}`);
        }
      }
    };
  }
  /**
   * Render delete button for trash item
   */
  renderDeleteTrashButton(itemActions, name, isFolder, containerEl) {
    const deleteBtn = itemActions.createEl("button", {
      text: "Delete Permanently",
      cls: "mod-warning"
    });
    deleteBtn.onclick = async () => {
      const confirmed = await DialogHelpers.showConfirmationDialog(
        "Delete Permanently",
        `Permanently delete "${name}"? This cannot be undone.`
      );
      if (confirmed) {
        try {
          const adapter = this.plugin.app.vault.adapter;
          const fullPath = `.trash/${name}`;
          if (isFolder) {
            await adapter.rmdir(fullPath, true);
          } else {
            await adapter.remove(fullPath);
          }
          new import_obsidian30.Notice(`Permanently deleted "${name}"`);
          await this.renderTrashManagement(containerEl.parentElement);
        } catch (error) {
          new import_obsidian30.Notice(`Error deleting item: ${error.message}`);
        }
      }
    };
  }
};

// src/settings/sections/ChatHistorySettingsSection.ts
var ChatHistorySettingsSection = class {
  /**
   * @param plugin The main plugin instance.
   * @param settingCreators An instance of SettingCreators for consistent UI element creation.
   */
  constructor(plugin, settingCreators) {
    __publicField(this, "plugin");
    __publicField(this, "settingCreators");
    this.plugin = plugin;
    this.settingCreators = settingCreators;
  }
  /**
   * Renders the Chat History & Sessions and UI Behavior settings sections into the provided container element.
   * @param containerEl The HTML element to render the sections into.
   */
  async render(containerEl) {
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Chat History & Sessions",
      (sectionEl) => {
        this.settingCreators.createSliderSetting(
          sectionEl,
          "Max Chat Sessions",
          "Maximum number of chat sessions to keep in history.",
          { min: 1, max: 50, step: 1 },
          () => this.plugin.settings.maxSessions,
          async (value) => {
            this.plugin.settings.maxSessions = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Auto-Save Sessions",
          "Automatically save chat sessions as you use them.",
          () => this.plugin.settings.autoSaveSessions,
          async (value) => {
            this.plugin.settings.autoSaveSessions = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "UI Behavior",
      (sectionEl) => {
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Collapse Old Reasoning",
          "Automatically collapse reasoning sections in older messages to keep the UI clean",
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.collapseOldReasoning) != null ? _b : true;
          },
          async (value) => {
            if (!this.plugin.settings.uiBehavior) {
              this.plugin.settings.uiBehavior = {};
            }
            this.plugin.settings.uiBehavior.collapseOldReasoning = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Show Completion Notifications",
          "Show notifications when AI responses are completed",
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.showCompletionNotifications) != null ? _b : true;
          },
          async (value) => {
            if (!this.plugin.settings.uiBehavior) {
              this.plugin.settings.uiBehavior = {};
            }
            this.plugin.settings.uiBehavior.showCompletionNotifications = value;
            await this.plugin.saveSettings();
          }
        );
        this.settingCreators.createToggleSetting(
          sectionEl,
          "Include Reasoning in Exports",
          "Include reasoning sections when copying or exporting chat content",
          () => {
            var _a2, _b;
            return (_b = (_a2 = this.plugin.settings.uiBehavior) == null ? void 0 : _a2.includeReasoningInExports) != null ? _b : true;
          },
          async (value) => {
            if (!this.plugin.settings.uiBehavior) {
              this.plugin.settings.uiBehavior = {};
            }
            this.plugin.settings.uiBehavior.includeReasoningInExports = value;
            await this.plugin.saveSettings();
          }
        );
      },
      this.plugin,
      "generalSectionsExpanded"
    );
  }
};

// src/settings/SettingTab.ts
init_promptConstants();
var MyPluginSettingTab = class extends import_obsidian31.PluginSettingTab {
  /**
   * Constructs the settings tab and initializes all settings sections.
   *
   * @param app - The Obsidian app instance.
   * @param plugin - The plugin instance.
   */
  constructor(app, plugin) {
    var _a2;
    super(app, plugin);
    /** Reference to the plugin instance. */
    __publicField(this, "plugin");
    /** Helper for creating settings UI elements. */
    __publicField(this, "settingCreators");
    // Section managers for each logical group of settings
    /** General plugin settings section. */
    __publicField(this, "generalSettingsSection");
    /** AI model configuration section. */
    __publicField(this, "aiModelConfigurationSection");
    /** Agent settings section. */
    __publicField(this, "agentSettingsSection");
    /** Content and note handling section. */
    __publicField(this, "contentNoteHandlingSection");
    /** Backup and trash management section. */
    __publicField(this, "backupManagementSection");
    /** Chat history and UI section. */
    __publicField(this, "chatHistorySettingsSection");
    /** Listener for settings changes, used to refresh the UI when settings are updated elsewhere. */
    __publicField(this, "settingsChangeListener", null);
    /** Flag to track if settings changes are coming from the UI to prevent unnecessary re-renders. */
    __publicField(this, "isUpdatingFromUI", false);
    this.plugin = plugin;
    debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "debug", "[MyPluginSettingTab] constructor called");
    this.settingCreators = new SettingCreators(this.plugin, () => this.display());
    this.generalSettingsSection = new GeneralSettingsSection(this.plugin, this.settingCreators);
    this.aiModelConfigurationSection = new AIModelConfigurationSection(this.plugin, this.settingCreators);
    this.agentSettingsSection = new AgentSettingsSection(this.app, this.plugin, this.settingCreators);
    this.contentNoteHandlingSection = new ContentNoteHandlingSection(this.plugin, this.settingCreators);
    this.backupManagementSection = new BackupManagementSection(this.plugin, this.settingCreators);
    this.chatHistorySettingsSection = new ChatHistorySettingsSection(this.plugin, this.settingCreators);
    this.settingsChangeListener = () => {
      if (this.containerEl.isConnected && !this.isUpdatingFromUI) {
        this.display();
      }
    };
    this.plugin.onSettingsChange(this.settingsChangeListener);
  }
  /**
   * Called when the settings tab is hidden.
   * Cleans up the settings change listener to avoid memory leaks.
   */
  hide() {
    if (this.settingsChangeListener) {
      this.plugin.offSettingsChange(this.settingsChangeListener);
      this.settingsChangeListener = null;
    }
    super.hide();
  }
  /**
   * Renders the settings tab UI.
   *
   * This method orchestrates the rendering of all collapsible settings sections and the reset-to-defaults button.
   * It is called automatically when the tab is shown, and can be called to refresh the UI after changes.
   */
  display() {
    var _a2;
    const { containerEl } = this;
    containerEl.empty();
    debugLog((_a2 = this.plugin.settings.debugMode) != null ? _a2 : false, "info", "[MyPluginSettingTab] display called");
    containerEl.createEl("h2", { text: "AI Assistant Settings" });
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "General Settings",
      (sectionEl) => this.generalSettingsSection.render(sectionEl),
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "AI Model Configuration",
      (sectionEl) => this.aiModelConfigurationSection.render(sectionEl),
      this.plugin,
      "generalSectionsExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Agent Settings",
      (sectionEl) => this.agentSettingsSection.render(sectionEl),
      this.plugin,
      "agentConfigExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Content & Note Handling",
      (sectionEl) => this.contentNoteHandlingSection.render(sectionEl),
      this.plugin,
      "contentChatExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Chat History & UI",
      (sectionEl) => this.chatHistorySettingsSection.render(sectionEl),
      this.plugin,
      "dataHandlingExpanded"
    );
    CollapsibleSectionRenderer.createCollapsibleSection(
      containerEl,
      "Backup & Trash Management",
      (sectionEl) => this.backupManagementSection.render(sectionEl),
      this.plugin,
      "backupManagementExpanded"
    );
    new import_obsidian31.Setting(containerEl).setName("Reset All Settings to Default").setDesc("Reset all plugin settings (except API keys) to their original default values.").addButton((button) => button.setButtonText("Reset").onClick(async () => {
      const { DEFAULT_SETTINGS: DEFAULT_SETTINGS2 } = await Promise.resolve().then(() => (init_types(), types_exports));
      const preservedApiKeys = {
        openai: this.plugin.settings.openaiSettings.apiKey,
        anthropic: this.plugin.settings.anthropicSettings.apiKey,
        gemini: this.plugin.settings.geminiSettings.apiKey
      };
      this.plugin.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS2));
      this.plugin.settings.openaiSettings.apiKey = preservedApiKeys.openai;
      this.plugin.settings.anthropicSettings.apiKey = preservedApiKeys.anthropic;
      this.plugin.settings.geminiSettings.apiKey = preservedApiKeys.gemini;
      this.plugin.settings.titlePrompt = DEFAULT_TITLE_PROMPT;
      await this.plugin.saveSettings();
      this.display();
      setTimeout(() => {
        activateView(this.plugin.app, VIEW_TYPE_MODEL_SETTINGS);
      }, 100);
      new import_obsidian31.Notice("All settings (except API keys) reset to default.");
    }));
  }
  /**
   * Saves settings from the UI without triggering a re-render of the settings tab.
   * This prevents the issue where typing in input fields causes focus loss due to UI refresh.
   */
  async saveSettingsFromUI() {
    this.isUpdatingFromUI = true;
    try {
      await this.plugin.saveSettings();
    } finally {
      setTimeout(() => {
        this.isUpdatingFromUI = false;
      }, 50);
    }
  }
};

// src/components/ModelSettingsView.ts
var import_obsidian32 = require("obsidian");
var VIEW_TYPE_MODEL_SETTINGS2 = "model-settings-view";
var ModelSettingsView = class extends import_obsidian32.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "_onSettingsChange", () => {
      this.onOpen();
    });
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MODEL_SETTINGS2;
  }
  getDisplayText() {
    return "AI Model Settings";
  }
  getIcon() {
    return "file-sliders";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.plugin.offSettingsChange(this._onSettingsChange);
    this.plugin.onSettingsChange(this._onSettingsChange);
    const settingsSections = new (await Promise.resolve().then(() => (init_SettingsSections(), SettingsSections_exports))).SettingsSections(this.plugin);
    await settingsSections.renderAllSettings(contentEl, { onRefresh: () => this.onOpen() });
  }
  async onClose() {
    this.plugin.offSettingsChange(this._onSettingsChange);
    this.contentEl.empty();
  }
};

// src/main.ts
init_logger();

// src/components/agent/agentModeManager.ts
init_logger();
var AgentModeManager = class {
  /**
   * @param settings The plugin's settings object (mutable reference)
   * @param saveSettings Function to persist settings to disk
   * @param emitSettingsChange Function to notify listeners of settings changes
   * @param debugLog Logging function for debug/info/warn/error
   */
  constructor(settings, saveSettings, emitSettingsChange, debugLog2) {
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.emitSettingsChange = emitSettingsChange;
    this.debugLog = debugLog2;
  }
  /**
   * Returns the current agent mode settings, or defaults if not set.
   * @returns AgentModeSettings object
   */
  getAgentModeSettings() {
    return this.settings.agentMode || {
      enabled: false,
      maxToolCalls: 5,
      timeoutMs: 3e4,
      maxIterations: 10
    };
  }
  /**
   * Checks if agent mode is enabled.
   * @returns True if agent mode is enabled, false otherwise.
   */
  isAgentModeEnabled() {
    return this.getAgentModeSettings().enabled;
  }
  /**
   * Enables or disables agent mode, persists the change, and emits a settings change event.
   * Initializes agentMode settings if not present.
   * @param enabled True to enable agent mode, false to disable.
   */
  async setAgentModeEnabled(enabled) {
    var _a2, _b, _c;
    debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, "info", "[AgentModeManager] Initializing");
    if (!this.settings.agentMode) {
      this.settings.agentMode = {
        enabled: false,
        maxToolCalls: 5,
        timeoutMs: 3e4,
        maxIterations: 10
      };
      debugLog((_b = this.settings.debugMode) != null ? _b : false, "debug", "[AgentModeManager] Initialized agentMode settings");
    }
    this.settings.agentMode.enabled = enabled;
    await this.saveSettings();
    this.emitSettingsChange();
    debugLog((_c = this.settings.debugMode) != null ? _c : false, "info", "[AgentModeManager] Agent mode enabled state set", { enabled });
  }
};

// src/main.ts
init_BackupManager();
init_ToolRichDisplay();

// src/components/commands/aiStreamCommands.ts
init_pluginUtils();

// src/utils/parseSelection.ts
function parseSelection(selection, chatSeparator, chatBoundaryString) {
  let insideChat = !chatBoundaryString;
  const lines = selection.split("\n");
  let messages = [];
  let currentRole = "user";
  let currentContent = "";
  for (const line of lines) {
    if (chatBoundaryString && line.trim() === chatBoundaryString) {
      if (!insideChat && currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
        currentContent = "";
      }
      insideChat = !insideChat;
      continue;
    }
    if (!insideChat) continue;
    if (line.trim() === chatSeparator) {
      if (currentContent.trim()) {
        messages.push({ role: currentRole, content: currentContent.trim() });
      }
      currentRole = currentRole === "user" ? "assistant" : "user";
      currentContent = "";
    } else {
      currentContent += line + "\n";
    }
  }
  if (currentContent.trim()) {
    messages.push({ role: currentRole, content: currentContent.trim() });
  }
  return messages;
}

// src/utils/aiCompletionHandler.ts
init_logger();
init_aiDispatcher();
async function handleAICompletion(editor, settings, processMessages2, vault, plugin, activeStream, setActiveStream, app) {
  var _a2, _b, _c;
  let text;
  let insertPosition;
  if (editor.somethingSelected()) {
    text = editor.getSelection();
    insertPosition = editor.getCursor("to");
  } else {
    const currentLineNumber = editor.getCursor().line;
    let lines = [];
    for (let i = 0; i <= currentLineNumber; i++) {
      lines.push(editor.getLine(i));
    }
    const chatStartString = settings.chatStartString;
    if (chatStartString) {
      const startIdx = lines.findIndex((line) => line.trim() === chatStartString.trim());
      if (startIdx !== -1) {
        lines = lines.slice(startIdx + 1);
      }
    }
    text = lines.join("\n");
    insertPosition = { line: currentLineNumber + 1, ch: 0 };
  }
  const messages = parseSelection(text, settings.chatSeparator);
  if (messages.length === 0) {
    showNotice("No valid messages found in the selection.");
    return;
  }
  const sepLine = insertSeparator(editor, insertPosition, settings.chatSeparator);
  let currentPosition = { line: sepLine, ch: 0 };
  try {
    const myPlugin = plugin;
    const dispatcher = myPlugin.aiDispatcher || new AIDispatcher(vault, plugin);
    const contextMessages = await buildContextMessages({
      app: app || myPlugin.app,
      plugin: myPlugin,
      includeCurrentNote: false,
      includeContextNotes: true,
      forceNoCurrentNote: true
    });
    const processedMessages = await processMessages2([
      ...contextMessages,
      ...messages
    ]);
    let bufferedChunk = "";
    const flushBuffer = () => {
      if (bufferedChunk) {
        editor.replaceRange(bufferedChunk, currentPosition);
        currentPosition = editor.offsetToPos(
          editor.posToOffset(currentPosition) + bufferedChunk.length
        );
        bufferedChunk = "";
      }
    };
    await dispatcher.getCompletion(
      processedMessages,
      {
        temperature: settings.temperature,
        streamCallback: (chunk) => {
          bufferedChunk += chunk;
          setTimeout(flushBuffer, 100);
        }
        // Note: abortController is now managed internally by the dispatcher
      }
    );
    flushBuffer();
    const endLineContent = (_a2 = editor.getLine(currentPosition.line)) != null ? _a2 : "";
    const endPrefix = endLineContent.trim() !== "" ? "\n" : "";
    editor.replaceRange(`${endPrefix}
${settings.chatSeparator}

`, currentPosition);
    const newCursorPos = editor.offsetToPos(
      editor.posToOffset(currentPosition) + (endPrefix ? 1 : 0) + 1 + settings.chatSeparator.length + 1
    );
    editor.setCursor(newCursorPos);
  } catch (error) {
    showNotice(`Error: ${error.message}`);
    debugLog((_b = settings.debugMode) != null ? _b : false, "error", "AI Completion Error:", error);
    const errLineContent = (_c = editor.getLine(currentPosition.line)) != null ? _c : "";
    const errPrefix = errLineContent.trim() !== "" ? "\n" : "";
    editor.replaceRange(`Error: ${error.message}
${errPrefix}
${settings.chatSeparator}

`, currentPosition);
  }
}

// src/components/commands/aiStreamCommands.ts
function registerAIStreamCommands(plugin, settings, processMessages2, activeStream, setActiveStream) {
  registerCommand(
    plugin,
    {
      id: "ai-completion",
      name: "Get AI Completion",
      editorCallback: (editor) => {
        var _a2;
        return handleAICompletion(
          editor,
          settings,
          processMessages2,
          plugin.app.vault,
          { settings, saveSettings: (_a2 = plugin.saveSettings) == null ? void 0 : _a2.bind(plugin) },
          activeStream,
          setActiveStream,
          plugin.app
        );
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "end-ai-stream",
      name: "End AI Stream",
      callback: () => {
        const myPlugin = plugin;
        if (myPlugin.hasActiveAIStreams && myPlugin.hasActiveAIStreams()) {
          myPlugin.stopAllAIStreams();
          showNotice("All AI streams stopped");
        } else {
          if (activeStream.current) {
            activeStream.current.abort();
            activeStream.current = null;
            setActiveStream(null);
            showNotice("AI stream ended");
          } else {
            showNotice("No active AI stream to end");
          }
        }
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "debug-ai-streams",
      name: "Debug AI Streams",
      callback: () => {
        const myPlugin = plugin;
        let message = "AI Stream Debug Info:\n";
        message += `Legacy activeStream: ${activeStream.current ? "Active" : "None"}
`;
        if (myPlugin.aiDispatcher) {
          const streamCount = myPlugin.aiDispatcher.getActiveStreamCount();
          message += `AI Dispatcher streams: ${streamCount}
`;
          message += `Has active streams method: ${typeof myPlugin.aiDispatcher.hasActiveStreams}
`;
        } else {
          message += "AI Dispatcher: Not initialized\n";
        }
        message += `Plugin hasActiveAIStreams method: ${typeof myPlugin.hasActiveAIStreams}
`;
        message += `Plugin stopAllAIStreams method: ${typeof myPlugin.stopAllAIStreams}
`;
        if (myPlugin.hasActiveAIStreams) {
          message += `Has active AI streams: ${myPlugin.hasActiveAIStreams()}
`;
        }
        showNotice(message);
        console.log("[AI Assistant Debug]", message);
      }
    }
  );
}

// src/components/commands/noteCommands.ts
init_pluginUtils();
function registerNoteCommands(plugin, settings, activateChatViewAndLoadMessages) {
  registerCommand(
    plugin,
    {
      id: "copy-active-note-name",
      name: "Copy Active Note Name",
      callback: async () => {
        const activeFile = plugin.app.workspace.getActiveFile();
        if (activeFile) {
          const noteName = `[[${activeFile.basename}]]`;
          await copyToClipboard3(noteName, `Copied to clipboard: ${noteName}`, "Failed to copy to clipboard");
        } else {
          showNotice("No active note found");
        }
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "insert-chat-start-string",
      name: "Insert Chat Start String",
      editorCallback: (editor) => {
        var _a2;
        const chatStartString = (_a2 = settings.chatStartString) != null ? _a2 : "";
        if (!chatStartString) {
          showNotice("chatStartString is not set in settings.");
          return;
        }
        const cursor = editor.getCursor();
        editor.replaceRange(chatStartString, cursor);
        moveCursorAfterInsert(editor, cursor, chatStartString);
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "load-chat-note-into-chat",
      name: "Load Chat Note into Chat",
      callback: async () => {
        let file = plugin.app.workspace.getActiveFile();
        if (!file) {
          showNotice("No active note found. Please open a note to load as chat.");
          return;
        }
        let content = await plugin.app.vault.read(file);
        const messages = parseSelection(content, settings.chatSeparator);
        if (!messages.length) {
          showNotice("No chat messages found in the selected note.");
          return;
        }
        await activateChatViewAndLoadMessages(messages);
      }
    }
  );
}

// src/components/commands/generateNoteTitleCommand.ts
init_pluginUtils();
function registerGenerateNoteTitleCommand(plugin, settings, processMessages2) {
  registerCommand(
    plugin,
    {
      id: "generate-note-title",
      name: "Generate Note Title",
      callback: async () => {
        const { generateNoteTitle: generateNoteTitle2 } = await Promise.resolve().then(() => (init_YAMLHandler(), YAMLHandler_exports));
        await generateNoteTitle2(
          plugin.app,
          settings,
          processMessages2
        );
      }
    }
  );
}

// src/components/commands/contextCommands.ts
init_pluginUtils();
function registerContextCommands(plugin, settings) {
  registerCommand(
    plugin,
    {
      id: "clear-context-notes",
      name: "Clear Context Notes",
      callback: async () => {
        settings.contextNotes = "";
        await plugin.saveSettings();
        showNotice("Context Notes cleared");
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "copy-context-notes-to-clipboard",
      name: "Copy Context Notes to Clipboard",
      callback: async () => {
        if (!settings.contextNotes || settings.contextNotes.trim().length === 0) {
          showNotice("No context notes to copy");
          return;
        }
        try {
          await navigator.clipboard.writeText(settings.contextNotes);
          showNotice("Context notes copied to clipboard");
        } catch (error) {
          console.error("Failed to copy context notes to clipboard:", error);
          showNotice("Failed to copy context notes to clipboard");
        }
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "add-current-note-to-context",
      name: "Add Current Note to Context Notes",
      callback: async () => {
        const activeFile = plugin.app.workspace.getActiveFile();
        if (!activeFile) {
          showNotice("No active note to add to context");
          return;
        }
        const noteTitle = activeFile.basename;
        const wikiLink = `[[${noteTitle}]]`;
        if (settings.contextNotes && settings.contextNotes.includes(wikiLink)) {
          showNotice(`"${noteTitle}" is already in context notes`);
          return;
        }
        if (settings.contextNotes && settings.contextNotes.trim().length > 0) {
          settings.contextNotes += `
${wikiLink}`;
        } else {
          settings.contextNotes = wikiLink;
        }
        await plugin.saveSettings();
        showNotice(`Added "${noteTitle}" to context notes`);
      }
    }
  );
}

// src/components/commands/toggleCommands.ts
init_pluginUtils();
function registerToggleCommands(plugin, settings) {
  registerCommand(
    plugin,
    {
      id: "toggle-enable-obsidian-links",
      name: "Toggle Enable Obsidian Links",
      callback: async () => {
        settings.enableObsidianLinks = !settings.enableObsidianLinks;
        await plugin.saveSettings();
        const status = settings.enableObsidianLinks ? "enabled" : "disabled";
        showNotice(`Obsidian Links ${status}`);
      }
    }
  );
  registerCommand(
    plugin,
    {
      id: "toggle-enable-context-notes",
      name: "Toggle Enable Context Notes",
      callback: async () => {
        settings.enableContextNotes = !settings.enableContextNotes;
        await plugin.saveSettings();
        const status = settings.enableContextNotes ? "enabled" : "disabled";
        showNotice(`Context Notes ${status}`);
      }
    }
  );
}

// src/components/commands/commandRegistry.ts
init_YAMLHandler();
init_logger();
function registerAllCommands(plugin, settings, processMessages2, activateChatViewAndLoadMessages, activeStream, setActiveStream, yamlAttributeCommandIds) {
  registerViewCommands(plugin);
  registerAIStreamCommands(plugin, settings, processMessages2, activeStream, setActiveStream);
  registerNoteCommands(plugin, settings, activateChatViewAndLoadMessages);
  registerGenerateNoteTitleCommand(plugin, settings, processMessages2);
  registerContextCommands(plugin, settings);
  registerToggleCommands(plugin, settings);
  return registerYamlAttributeCommands(
    plugin,
    settings,
    processMessages2,
    yamlAttributeCommandIds,
    (level, ...args) => {
      var _a2;
      return debugLog((_a2 = settings.debugMode) != null ? _a2 : false, level, ...args);
    }
  );
}

// src/main.ts
init_YAMLHandler();
init_aiDispatcher();
init_objectPool();

// src/integration/priority3Integration.ts
var import_obsidian34 = require("obsidian");
init_dependencyInjection();
init_stateManager();
init_streamManager();
init_errorHandler();
init_lruCache();
init_asyncOptimizer();
var Priority3IntegrationManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    __publicField(this, "container");
    __publicField(this, "stateUnsubscribers", []);
    __publicField(this, "isInitialized", false);
    this.container = new DIContainer();
  }
  /**
   * Initialize all Priority 3 systems
   */
  async initialize() {
    if (this.isInitialized) {
      throw new Error("Priority 3 systems already initialized");
    }
    try {
      await this.setupDependencyInjection();
      await this.setupStateManagement();
      await this.setupStreamManagement();
      this.setupMonitoring();
      this.setupCleanup();
      this.isInitialized = true;
      console.log("Priority 3 optimizations initialized successfully");
    } catch (error) {
      errorHandler.handleError(error, {
        component: "Priority3IntegrationManager",
        operation: "initialize"
      });
      throw error;
    }
  }
  /**
   * Setup dependency injection container
   */
  async setupDependencyInjection() {
    this.container.registerSingleton("plugin", () => this.plugin);
    this.container.registerSingleton("stateManager", () => globalStateManager);
    this.container.registerSingleton("streamManager", () => globalStreamManager);
    this.container.registerSingleton("errorHandler", () => errorHandler);
    this.container.registerSingleton("asyncOptimizerFactory", () => AsyncOptimizerFactory);
    this.container.registerSingleton(
      "settingsCache",
      () => new LRUCache({ maxSize: 100, defaultTTL: 5 * 60 * 1e3 })
    );
    this.container.registerTransient("httpClient", () => {
      return {
        async fetch(url, options) {
          const throttler = AsyncOptimizerFactory.createAPIThrottler();
          return throttler.throttle(() => fetch(url, options));
        }
      };
    });
    this.container.registerScoped("chatSession", () => ({
      id: `session-${Date.now()}`,
      messages: [],
      startTime: Date.now(),
      dispose: () => console.log("Chat session disposed")
    }));
    ServiceLocator.initialize(this.container);
    console.log("Dependency injection system configured");
  }
  /**
   * Setup centralized state management
   */
  async setupStateManagement() {
    globalStateManager.setState("plugin.version", this.plugin.manifest.version, {
      persistent: true
    });
    globalStateManager.setState("plugin.initialized", false);
    globalStateManager.setState("plugin.performance", {
      startTime: Date.now(),
      memoryUsage: 0,
      operationCount: 0
    });
    globalStateManager.registerValidator("settings.apiKey", (value) => {
      return value && value.length > 10 ? true : "API key must be at least 10 characters";
    });
    globalStateManager.registerValidator("chat.maxMessages", (value) => {
      return value > 0 && value <= 1e3 ? true : "Max messages must be between 1 and 1000";
    });
    globalStateManager.registerTransformer("settings.theme", (value) => {
      return value.toLowerCase().trim();
    });
    StateUtils.createComputed(
      globalStateManager,
      ["plugin.performance.operationCount", "plugin.performance.startTime"],
      ([operations, startTime]) => {
        const duration = Date.now() - startTime;
        return duration > 0 ? operations / (duration / 1e3) : 0;
      },
      "plugin.performance.operationsPerSecond"
    );
    this.stateUnsubscribers.push(
      globalStateManager.subscribe("plugin.error", (error) => {
        if (error) {
          console.error("Plugin error state changed:", error);
          this.handleCriticalError(error);
        }
      }),
      globalStateManager.subscribe("plugin.performance.memoryUsage", (usage) => {
        if (typeof usage === "number" && usage > 100 * 1024 * 1024) {
          console.warn("High memory usage detected:", usage);
          this.handleHighMemoryUsage();
        }
      }),
      globalStateManager.subscribeAll((newValue, oldValue, path3) => {
        if (true) {
          console.log(`State changed: ${path3}`, { oldValue, newValue });
        }
      })
    );
    globalStateManager.setState("plugin.stateManagement.ready", true);
    console.log("State management system configured");
  }
  /**
   * Setup stream management
   */
  async setupStreamManagement() {
    globalStreamManager.registerTransformer("jsonParse", (chunk) => {
      try {
        return JSON.parse(chunk);
      } catch (e) {
        return chunk;
      }
    });
    globalStreamManager.registerTransformer("textDecode", (chunk) => {
      return new TextDecoder().decode(chunk);
    });
    globalStreamManager.registerTransformer("markdown", (text) => {
      return text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>");
    });
    globalStreamManager.registerFilter("nonEmpty", (chunk) => {
      return chunk !== null && chunk !== void 0 && chunk !== "";
    });
    globalStreamManager.registerFilter("validJson", (chunk) => {
      try {
        JSON.parse(chunk);
        return true;
      } catch (e) {
        return false;
      }
    });
    globalStreamManager.on("streamCreated", (id, state) => {
      globalStateManager.setState(`streams.${id}`, {
        status: state.status,
        createdAt: state.createdAt
      });
    });
    globalStreamManager.on("streamDestroyed", (id) => {
      globalStateManager.deleteState(`streams.${id}`);
    });
    console.log("Stream management system configured");
  }
  /**
   * Setup monitoring and metrics collection
   */
  setupMonitoring() {
    setInterval(() => {
      if (!this.isInitialized) return;
      try {
        const diStats = this.container.getStats();
        const stateStats = globalStateManager.getStats();
        const streamStats = globalStreamManager.getStats();
        globalStateManager.setState("plugin.performance.metrics", {
          timestamp: Date.now(),
          dependencyInjection: diStats,
          stateManagement: stateStats,
          streamManagement: streamStats,
          memoryUsage: this.estimateMemoryUsage()
        });
        this.checkPerformanceThresholds(diStats, stateStats, streamStats);
      } catch (error) {
        errorHandler.handleError(error, {
          component: "Priority3IntegrationManager",
          operation: "monitoring"
        });
      }
    }, 3e4);
    console.log("Monitoring system configured");
  }
  /**
   * Setup cleanup handlers
   */
  setupCleanup() {
    this.plugin.register(() => {
      this.dispose();
    });
    setInterval(() => {
      if (!this.isInitialized) return;
      try {
        const cleaned = globalStreamManager.cleanup(5 * 60 * 1e3);
        if (cleaned > 0) {
          console.log(`Cleaned up ${cleaned} old streams`);
        }
        const snapshots = globalStateManager.getSnapshots();
        if (snapshots.length > 20) {
          console.log(`Managing ${snapshots.length} state snapshots`);
        }
      } catch (error) {
        errorHandler.handleError(error, {
          component: "Priority3IntegrationManager",
          operation: "cleanup"
        });
      }
    }, 2 * 60 * 1e3);
    console.log("Cleanup handlers configured");
  }
  /**
   * Handle critical errors
   */
  handleCriticalError(error) {
    globalStateManager.createSnapshot();
    const activeStreams = globalStreamManager.getActiveStreams();
    for (const stream of activeStreams) {
      if (!stream.id.includes("critical")) {
        globalStreamManager.pauseStream(stream.id);
      }
    }
    console.error("Critical error handled:", error);
  }
  /**
   * Handle high memory usage
   */
  handleHighMemoryUsage() {
    globalStreamManager.cleanup(6e4);
    const settingsCache = ServiceLocator.resolve("settingsCache");
    settingsCache.clear();
    globalStateManager.createSnapshot();
    console.warn("High memory usage mitigation applied");
  }
  /**
   * Check performance thresholds
   */
  checkPerformanceThresholds(diStats, stateStats, streamStats) {
    const warnings = [];
    if (diStats.resolutionCount > 1e4) {
      warnings.push("High dependency resolution count");
    }
    if (stateStats.listeners > 1e3) {
      warnings.push("High number of state listeners");
    }
    if (stateStats.memoryUsage > 50 * 1024 * 1024) {
      warnings.push("High state memory usage");
    }
    if (streamStats.activeStreams > 50) {
      warnings.push("High number of active streams");
    }
    if (streamStats.averageThroughput < 1e3) {
      warnings.push("Low stream throughput");
    }
    if (warnings.length > 0) {
      globalStateManager.setState("plugin.performance.warnings", warnings);
      console.warn("Performance warnings:", warnings);
    }
  }
  /**
   * Estimate memory usage
   */
  estimateMemoryUsage() {
    try {
      const stateSize = JSON.stringify(globalStateManager.getFullState()).length;
      const containerSize = this.container.getStats().totalServices * 1e3;
      return stateSize + containerSize;
    } catch (e) {
      return 0;
    }
  }
  /**
   * Get integration status
   */
  getStatus() {
    return {
      initialized: this.isInitialized,
      services: this.container.getRegisteredServices(),
      stateKeys: globalStateManager.getStats().totalKeys,
      activeStreams: globalStreamManager.getStats().activeStreams,
      memoryUsage: this.estimateMemoryUsage()
    };
  }
  /**
   * Dispose all systems
   */
  dispose() {
    if (!this.isInitialized) return;
    try {
      this.stateUnsubscribers.forEach((unsub) => unsub());
      this.stateUnsubscribers = [];
      globalStreamManager.dispose();
      globalStateManager.dispose();
      this.container.dispose();
      this.isInitialized = false;
      console.log("Priority 3 systems disposed");
    } catch (error) {
      errorHandler.handleError(error, {
        component: "Priority3IntegrationManager",
        operation: "dispose"
      });
    }
  }
};

// src/main.ts
init_typeGuards();

// src/utils/PerformanceDashboard.ts
var import_obsidian35 = require("obsidian");
init_performanceMonitor();
init_APICircuitBreaker();
init_logger();
var _PerformanceDashboard = class _PerformanceDashboard {
  constructor() {
    __publicField(this, "config");
    __publicField(this, "alertRules", /* @__PURE__ */ new Map());
    __publicField(this, "activeAlerts", /* @__PURE__ */ new Map());
    __publicField(this, "historicalData", []);
    __publicField(this, "refreshTimer");
    __publicField(this, "isRunning", false);
    __publicField(this, "DEFAULT_CONFIG", {
      refreshInterval: 1e4,
      // 10 seconds
      alertThresholds: {
        responseTime: 5e3,
        // 5 seconds
        errorRate: 10,
        // 10%
        memoryUsage: 100 * 1024 * 1024,
        // 100MB
        cacheHitRate: 50
        // 50%
      },
      enableAlerts: true,
      historicalDataPoints: 288
      // 24 hours at 5-minute intervals
    });
    this.config = { ...this.DEFAULT_CONFIG };
    this.initializeDefaultAlertRules();
  }
  static getInstance() {
    if (!_PerformanceDashboard.instance) {
      _PerformanceDashboard.instance = new _PerformanceDashboard();
    }
    return _PerformanceDashboard.instance;
  }
  /**
   * Start the dashboard monitoring
   */
  start() {
    if (this.isRunning) return;
    this.isRunning = true;
    this.refreshTimer = setInterval(() => {
      this.collectMetrics();
      this.checkAlerts();
    }, this.config.refreshInterval);
    debugLog(true, "info", "[PerformanceDashboard] Started monitoring");
  }
  /**
   * Stop the dashboard monitoring
   */
  stop() {
    if (!this.isRunning) return;
    this.isRunning = false;
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = void 0;
    }
    debugLog(true, "info", "[PerformanceDashboard] Stopped monitoring");
  }
  /**
   * Get current performance snapshot
   */
  getCurrentSnapshot() {
    var _a2;
    const metrics = performanceMonitor.getMetrics();
    const circuitBreakerMetrics = apiCircuitBreaker.getAllMetrics();
    return {
      timestamp: Date.now(),
      performance: metrics,
      circuitBreakers: circuitBreakerMetrics,
      alerts: {
        total: this.activeAlerts.size,
        critical: Array.from(this.activeAlerts.values()).filter((a) => a.rule.severity === "critical").length,
        unacknowledged: Array.from(this.activeAlerts.values()).filter((a) => !a.acknowledged).length
      },
      system: {
        uptime: Date.now() - (((_a2 = this.historicalData[0]) == null ? void 0 : _a2.timestamp) || Date.now()),
        dataPoints: this.historicalData.length
      }
    };
  }
  /**
   * Get historical performance data
   */
  getHistoricalData(hours = 24) {
    const cutoff = Date.now() - hours * 60 * 60 * 1e3;
    return this.historicalData.filter((data) => data.timestamp > cutoff);
  }
  /**
   * Add custom alert rule
   */
  addAlertRule(rule) {
    const id = `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const alertRule = {
      ...rule,
      id,
      lastTriggered: 0
    };
    this.alertRules.set(id, alertRule);
    debugLog(true, "info", `[PerformanceDashboard] Added alert rule: ${rule.name}`);
    return id;
  }
  /**
   * Remove alert rule
   */
  removeAlertRule(id) {
    return this.alertRules.delete(id);
  }
  /**
   * Acknowledge alert
   */
  acknowledgeAlert(id) {
    const alert = this.activeAlerts.get(id);
    if (alert) {
      alert.acknowledged = true;
      return true;
    }
    return false;
  }
  /**
   * Clear all acknowledged alerts
   */
  clearAcknowledgedAlerts() {
    let cleared = 0;
    for (const [id, alert] of this.activeAlerts.entries()) {
      if (alert.acknowledged) {
        this.activeAlerts.delete(id);
        cleared++;
      }
    }
    return cleared;
  }
  /**
   * Generate performance report
   */
  generateReport(hours = 24) {
    const snapshot = this.getCurrentSnapshot();
    const historical = this.getHistoricalData(hours);
    const oldData = historical[0];
    const trends = oldData ? {
      responseTime: this.calculateTrend(historical, "performance.averageResponseTime"),
      errorRate: this.calculateTrend(historical, "performance.errorRate"),
      cacheHitRate: this.calculateTrend(historical, "performance.cacheHitRate"),
      memoryUsage: this.calculateTrend(historical, "performance.memoryUsage")
    } : null;
    return `
# AI Assistant Performance Report
Generated: ${(/* @__PURE__ */ new Date()).toISOString()}
Period: ${hours} hours

## Current Status
- **Response Time**: ${snapshot.performance.averageResponseTime.toFixed(2)}ms
- **Error Rate**: ${snapshot.performance.errorRate.toFixed(2)}%
- **Cache Hit Rate**: ${snapshot.performance.cacheHitRate.toFixed(2)}%
- **Memory Usage**: ${(snapshot.performance.memoryUsage / 1024 / 1024).toFixed(2)}MB
- **API Calls/min**: ${snapshot.performance.apiCallsPerMinute}

## Circuit Breakers
${Object.entries(snapshot.circuitBreakers).map(
      ([provider, metrics]) => `- **${provider}**: ${metrics.state} (${metrics.totalCalls} calls, ${metrics.failureRate.toFixed(2)}% failure rate)`
    ).join("\n")}

## Alerts
- **Total Active**: ${snapshot.alerts.total}
- **Critical**: ${snapshot.alerts.critical}
- **Unacknowledged**: ${snapshot.alerts.unacknowledged}

${trends ? `## Trends (${hours}h)
- **Response Time**: ${trends.responseTime > 0 ? "\u{1F4C8}" : "\u{1F4C9}"} ${trends.responseTime.toFixed(2)}%
- **Error Rate**: ${trends.errorRate > 0 ? "\u{1F4C8}" : "\u{1F4C9}"} ${trends.errorRate.toFixed(2)}%
- **Cache Hit Rate**: ${trends.cacheHitRate > 0 ? "\u{1F4C8}" : "\u{1F4C9}"} ${trends.cacheHitRate.toFixed(2)}%
- **Memory Usage**: ${trends.memoryUsage > 0 ? "\u{1F4C8}" : "\u{1F4C9}"} ${trends.memoryUsage.toFixed(2)}%` : ""}

## Recent Alerts
${Array.from(this.activeAlerts.values()).sort((a, b) => b.timestamp - a.timestamp).slice(0, 10).map((alert) => `- [${alert.rule.severity.toUpperCase()}] ${alert.message} (${new Date(alert.timestamp).toLocaleString()})`).join("\n") || "No recent alerts"}

---
*Report generated by AI Assistant Performance Dashboard*
    `.trim();
  }
  /**
   * Export dashboard data
   */
  exportData() {
    return {
      config: this.config,
      alertRules: Array.from(this.alertRules.values()),
      activeAlerts: Array.from(this.activeAlerts.values()),
      historicalData: this.historicalData,
      snapshot: this.getCurrentSnapshot()
    };
  }
  /**
   * Initialize default alert rules
   */
  initializeDefaultAlertRules() {
    const defaultRules = [
      {
        name: "High Response Time",
        metric: "averageResponseTime",
        threshold: this.config.alertThresholds.responseTime,
        operator: "gt",
        severity: "high",
        enabled: true,
        cooldownMs: 3e5
        // 5 minutes
      },
      {
        name: "High Error Rate",
        metric: "errorRate",
        threshold: this.config.alertThresholds.errorRate,
        operator: "gt",
        severity: "critical",
        enabled: true,
        cooldownMs: 18e4
        // 3 minutes
      },
      {
        name: "Low Cache Hit Rate",
        metric: "cacheHitRate",
        threshold: this.config.alertThresholds.cacheHitRate,
        operator: "lt",
        severity: "medium",
        enabled: true,
        cooldownMs: 6e5
        // 10 minutes
      },
      {
        name: "High Memory Usage",
        metric: "memoryUsage",
        threshold: this.config.alertThresholds.memoryUsage,
        operator: "gt",
        severity: "high",
        enabled: true,
        cooldownMs: 3e5
        // 5 minutes
      }
    ];
    defaultRules.forEach((rule) => this.addAlertRule(rule));
  }
  /**
   * Collect current metrics and store historically
   */
  collectMetrics() {
    const snapshot = this.getCurrentSnapshot();
    this.historicalData.push({
      timestamp: snapshot.timestamp,
      metrics: snapshot
    });
    if (this.historicalData.length > this.config.historicalDataPoints) {
      this.historicalData = this.historicalData.slice(-this.config.historicalDataPoints);
    }
  }
  /**
   * Check alert rules and trigger alerts
   */
  checkAlerts() {
    if (!this.config.enableAlerts) return;
    const metrics = performanceMonitor.getMetrics();
    const now = Date.now();
    for (const rule of this.alertRules.values()) {
      if (!rule.enabled) continue;
      if (now - rule.lastTriggered < rule.cooldownMs) continue;
      const value = this.getMetricValue(metrics, rule.metric);
      if (value === void 0) continue;
      let triggered = false;
      switch (rule.operator) {
        case "gt":
          triggered = value > rule.threshold;
          break;
        case "lt":
          triggered = value < rule.threshold;
          break;
        case "eq":
          triggered = value === rule.threshold;
          break;
      }
      if (triggered) {
        this.triggerAlert(rule, value);
      }
    }
  }
  /**
   * Trigger an alert
   */
  triggerAlert(rule, value) {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const alert = {
      id: alertId,
      rule,
      value,
      timestamp: Date.now(),
      message: `${rule.name}: ${rule.metric} is ${value} (threshold: ${rule.threshold})`,
      acknowledged: false
    };
    this.activeAlerts.set(alertId, alert);
    rule.lastTriggered = Date.now();
    debugLog(true, "warn", `[PerformanceDashboard] Alert triggered: ${alert.message}`);
    if (this.activeAlerts.size > 100) {
      const sorted = Array.from(this.activeAlerts.entries()).sort(([, a], [, b]) => b.timestamp - a.timestamp);
      this.activeAlerts.clear();
      sorted.slice(0, 100).forEach(([id, alert2]) => {
        this.activeAlerts.set(id, alert2);
      });
    }
  }
  /**
   * Get metric value by path
   */
  getMetricValue(metrics, path3) {
    return path3.split(".").reduce((obj, key) => obj == null ? void 0 : obj[key], metrics);
  }
  /**
   * Calculate trend percentage
   */
  calculateTrend(data, metricPath) {
    if (data.length < 2) return 0;
    const oldValue = this.getMetricValue(data[0].metrics, metricPath);
    const newValue = this.getMetricValue(data[data.length - 1].metrics, metricPath);
    if (oldValue === void 0 || newValue === void 0 || oldValue === 0) return 0;
    return (newValue - oldValue) / oldValue * 100;
  }
};
__publicField(_PerformanceDashboard, "instance");
var PerformanceDashboard = _PerformanceDashboard;
var PerformanceDashboardModal = class extends import_obsidian35.Modal {
  constructor(plugin) {
    super(plugin.app);
    __publicField(this, "dashboard");
    __publicField(this, "refreshTimer");
    this.dashboard = PerformanceDashboard.getInstance();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "AI Assistant Performance Dashboard" });
    this.renderDashboard();
    this.refreshTimer = setInterval(() => {
      this.renderDashboard();
    }, 1e4);
  }
  onClose() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
    }
  }
  renderDashboard() {
    const snapshot = this.dashboard.getCurrentSnapshot();
    const { contentEl } = this;
    const children = Array.from(contentEl.children);
    children.slice(1).forEach((child) => child.remove());
    const metricsSection = contentEl.createDiv("dashboard-metrics");
    metricsSection.createEl("h3", { text: "Current Performance" });
    const metricsGrid = metricsSection.createDiv("metrics-grid");
    metricsGrid.style.display = "grid";
    metricsGrid.style.gridTemplateColumns = "repeat(auto-fit, minmax(200px, 1fr))";
    metricsGrid.style.gap = "16px";
    this.createMetricCard(
      metricsGrid,
      "Response Time",
      `${snapshot.performance.averageResponseTime.toFixed(2)}ms`,
      snapshot.performance.averageResponseTime > 2e3 ? "warning" : "good"
    );
    this.createMetricCard(
      metricsGrid,
      "Error Rate",
      `${snapshot.performance.errorRate.toFixed(2)}%`,
      snapshot.performance.errorRate > 5 ? "danger" : "good"
    );
    this.createMetricCard(
      metricsGrid,
      "Cache Hit Rate",
      `${snapshot.performance.cacheHitRate.toFixed(2)}%`,
      snapshot.performance.cacheHitRate < 70 ? "warning" : "good"
    );
    this.createMetricCard(
      metricsGrid,
      "Memory Usage",
      `${(snapshot.performance.memoryUsage / 1024 / 1024).toFixed(2)}MB`,
      snapshot.performance.memoryUsage > 50 * 1024 * 1024 ? "warning" : "good"
    );
    const circuitSection = contentEl.createDiv("dashboard-circuits");
    circuitSection.createEl("h3", { text: "Circuit Breakers" });
    const circuitGrid = circuitSection.createDiv("circuit-grid");
    circuitGrid.style.display = "grid";
    circuitGrid.style.gridTemplateColumns = "repeat(auto-fit, minmax(150px, 1fr))";
    circuitGrid.style.gap = "12px";
    Object.entries(snapshot.circuitBreakers).forEach(([provider, metrics]) => {
      const cbMetrics = metrics;
      this.createCircuitCard(circuitGrid, provider, cbMetrics.state, cbMetrics.failureRate);
    });
    const alertsSection = contentEl.createDiv("dashboard-alerts");
    alertsSection.createEl("h3", { text: "Active Alerts" });
    if (snapshot.alerts.total === 0) {
      alertsSection.createEl("p", { text: "No active alerts", cls: "alert-none" });
    } else {
      const alertsList = alertsSection.createDiv("alerts-list");
      Array.from(this.dashboard["activeAlerts"].values()).sort((a, b) => b.timestamp - a.timestamp).slice(0, 5).forEach((alert) => {
        this.createAlertItem(alertsList, alert);
      });
    }
    const actionsSection = contentEl.createDiv("dashboard-actions");
    actionsSection.style.marginTop = "20px";
    actionsSection.style.display = "flex";
    actionsSection.style.gap = "10px";
    const exportBtn = actionsSection.createEl("button", { text: "Export Report" });
    exportBtn.onclick = () => this.exportReport();
    const clearAlertsBtn = actionsSection.createEl("button", { text: "Clear Alerts" });
    clearAlertsBtn.onclick = () => {
      const cleared = this.dashboard.clearAcknowledgedAlerts();
      console.log(`Cleared ${cleared} acknowledged alerts`);
      this.renderDashboard();
    };
  }
  createMetricCard(parent, title, value, status) {
    const card = parent.createDiv(`metric-card metric-${status}`);
    card.style.padding = "16px";
    card.style.border = "1px solid var(--background-modifier-border)";
    card.style.borderRadius = "8px";
    card.style.backgroundColor = status === "danger" ? "rgba(255,0,0,0.1)" : status === "warning" ? "rgba(255,165,0,0.1)" : "rgba(0,255,0,0.1)";
    card.createEl("h4", { text: title, cls: "metric-title" });
    card.createEl("div", { text: value, cls: "metric-value" });
  }
  createCircuitCard(parent, provider, state, failureRate) {
    const card = parent.createDiv(`circuit-card circuit-${state.toLowerCase()}`);
    card.style.padding = "12px";
    card.style.border = "1px solid var(--background-modifier-border)";
    card.style.borderRadius = "6px";
    card.style.backgroundColor = state === "OPEN" ? "rgba(255,0,0,0.1)" : state === "HALF_OPEN" ? "rgba(255,165,0,0.1)" : "rgba(0,255,0,0.1)";
    card.createEl("div", { text: provider.toUpperCase(), cls: "circuit-provider" });
    card.createEl("div", { text: state, cls: "circuit-state" });
    card.createEl("div", { text: `${failureRate.toFixed(1)}% fail`, cls: "circuit-rate" });
  }
  createAlertItem(parent, alert) {
    const item = parent.createDiv(`alert-item alert-${alert.rule.severity}`);
    item.style.padding = "8px";
    item.style.marginBottom = "8px";
    item.style.border = "1px solid var(--background-modifier-border)";
    item.style.borderRadius = "4px";
    item.style.backgroundColor = alert.rule.severity === "critical" ? "rgba(255,0,0,0.1)" : alert.rule.severity === "high" ? "rgba(255,165,0,0.1)" : "rgba(255,255,0,0.1)";
    item.createEl("div", { text: alert.message, cls: "alert-message" });
    item.createEl("div", { text: new Date(alert.timestamp).toLocaleString(), cls: "alert-time" });
    if (!alert.acknowledged) {
      const ackBtn = item.createEl("button", { text: "Acknowledge" });
      ackBtn.onclick = () => {
        this.dashboard.acknowledgeAlert(alert.id);
        this.renderDashboard();
      };
    }
  }
  async exportReport() {
    const report = this.dashboard.generateReport(24);
    const fileName = `performance-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.md`;
    try {
      await this.app.vault.create(fileName, report);
      console.log(`Performance report exported to ${fileName}`);
    } catch (error) {
      console.error("Failed to export report:", error);
    }
  }
};
var performanceDashboard = PerformanceDashboard.getInstance();

// src/main.ts
var _MyPlugin = class _MyPlugin extends import_obsidian37.Plugin {
  constructor() {
    super(...arguments);
    /**
     * Plugin settings object, loaded from disk or defaults.
     */
    __publicField(this, "settings");
    /**
     * Reference to the model settings view, if open.
     */
    __publicField(this, "modelSettingsView", null);
    /**
     * Reference to the current active streaming controller (for aborting AI responses).
     */
    __publicField(this, "activeStream", null);
    /**
     * Central AI dispatcher for managing all AI requests and streams.
     */
    __publicField(this, "aiDispatcher", null);
    /**
     * List of registered YAML attribute command IDs for cleanup/re-registration.
     */
    __publicField(this, "_yamlAttributeCommandIds", []);
    /**
     * Listeners for settings changes (for reactive UI updates).
     */
    __publicField(this, "settingsListeners", []);
    /**
     * Backup manager instance for handling plugin data backups.
     */
    __publicField(this, "backupManager");
    /**
     * Agent mode manager instance for handling agent-related settings and logic.
     */
    __publicField(this, "agentModeManager");
    /**
     * Priority 3 optimizations integration manager.
     */
    __publicField(this, "priority3Manager");
    /**
     * Recently opened files manager for tracking file access.
     */
    __publicField(this, "recentlyOpenedFilesManager");
  }
  /**
   * Register a callback to be called when settings change.
   * @param listener Callback function
   */
  onSettingsChange(listener) {
    this.settingsListeners.push(listener);
  }
  /**
   * Remove a previously registered settings change callback.
   * @param listener Callback function
   */
  offSettingsChange(listener) {
    this.settingsListeners = this.settingsListeners.filter((l) => l !== listener);
  }
  /**
   * Notify all registered listeners that settings have changed.
   */
  emitSettingsChange() {
    for (const listener of this.settingsListeners) {
      try {
        listener();
      } catch (e) {
        console.error(e);
      }
    }
  }
  /**
   * Helper to activate the chat view and load messages into it.
   * @param messages An array of messages to load.
   */
  async activateChatViewAndLoadMessages(messages) {
    this.debugLog("info", "[main.ts] activateChatViewAndLoadMessages called", { messageCount: messages.length });
    await activateView(this.app, VIEW_TYPE_CHAT);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CHAT);
    if (!leaves.length) {
      showNotice("Could not find chat view.");
      this.debugLog("warn", "[main.ts] No chat view found");
      return;
    }
    const chatView = leaves[0].view;
    chatView.clearMessages();
    for (const msg of messages) {
      if (msg.role === "user" || msg.role === "assistant") {
        const toolData = parseToolDataFromContent(msg.content);
        if (toolData) {
          const cleanContent = cleanContentFromToolData(msg.content);
          await chatView["addMessage"](msg.role, cleanContent, false, {
            toolResults: toolData.toolResults,
            reasoning: toolData.reasoning,
            taskStatus: toolData.taskStatus
          });
          this.debugLog("debug", "[main.ts] Added message with tool data", { role: msg.role, toolData });
        } else {
          await chatView["addMessage"](msg.role, msg.content);
          this.debugLog("debug", "[main.ts] Added regular message", { role: msg.role });
        }
      }
    }
    chatView.scrollMessagesToBottom();
    showNotice("Loaded chat note into chat.");
    this.debugLog("info", "[main.ts] Chat note loaded into chat view");
  }
  /**
   * Registers a view type with Obsidian, ensuring no duplicate registration.
   * @param viewType The type of the view.
   * @param viewCreator The function that creates the view.
   */
  registerPluginView(viewType, viewCreator) {
    if (!_MyPlugin.registeredViewTypes.has(viewType)) {
      this.registerView(viewType, viewCreator);
      _MyPlugin.registeredViewTypes.add(viewType);
    }
  }
  /**
   * Called by Obsidian when the plugin is loaded.
   * Handles initialization, settings, view registration, and command registration.
   */
  async onload() {
    var _a2, _b, _c, _d, _e, _f;
    await this.loadSettings();
    let vaultPath = "";
    try {
      const adapter = this.app.vault.adapter;
      if (isVaultAdapterWithBasePath(adapter)) {
        vaultPath = adapter.basePath;
      } else {
        debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, "warn", "[main.ts] Vault adapter does not have basePath property");
      }
    } catch (error) {
      debugLog((_b = this.settings.debugMode) != null ? _b : false, "error", "[main.ts] Failed to get vault path:", error);
    }
    const pluginDataPath = this.app.vault.configDir + "/plugins/ai-assistant-for-obsidian";
    this.backupManager = new BackupManager(this.app, pluginDataPath);
    await this.backupManager.initialize();
    this.agentModeManager = new AgentModeManager(
      this.settings,
      () => this.saveSettings(),
      () => this.emitSettingsChange(),
      (level, ...args) => {
        var _a3;
        return debugLog((_a3 = this.settings.debugMode) != null ? _a3 : false, level, ...args);
      }
      // Changed from log to debugLog
    );
    this.aiDispatcher = new AIDispatcher(this.app.vault, this);
    this.priority3Manager = new Priority3IntegrationManager(this);
    await this.priority3Manager.initialize();
    this.recentlyOpenedFilesManager = RecentlyOpenedFilesManager.getInstance(this.app);
    debugLog((_c = this.settings.debugMode) != null ? _c : false, "info", "Priority 3 optimizations initialized");
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.registerPluginView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));
    this.registerPluginView(VIEW_TYPE_MODEL_SETTINGS, (leaf) => new ModelSettingsView(leaf, this));
    this._yamlAttributeCommandIds = registerAllCommands(
      this,
      this.settings,
      (messages) => this.processMessages(messages),
      (messages) => this.activateChatViewAndLoadMessages(messages),
      { current: this.activeStream },
      (stream) => {
        this.activeStream = stream;
      },
      this._yamlAttributeCommandIds
    );
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.autoOpenModelSettings) {
        activateView(this.app, VIEW_TYPE_MODEL_SETTINGS);
      }
    });
    this.registerMarkdownPostProcessor((element, context) => {
      this.processToolExecutionBlocks(element, context);
    });
    this.registerMarkdownCodeBlockProcessor("ai-tool-execution", (source, el, ctx) => {
      this.processToolExecutionCodeBlock(source, el, ctx);
    });
    this.addCommand({
      id: "open-performance-dashboard",
      name: "Open Performance Dashboard",
      callback: () => {
        new PerformanceDashboardModal(this).open();
      }
    });
    this.addRibbonIcon("activity", "Performance Dashboard", () => {
      new PerformanceDashboardModal(this).open();
    });
    if (this.settings.debugMode) {
      try {
        const { registerTestCommands: registerTestCommands2 } = await Promise.resolve().then(() => (init_testRunner(), testRunner_exports));
        registerTestCommands2(this);
        debugLog((_d = this.settings.debugMode) != null ? _d : false, "info", "Test commands registered");
      } catch (error) {
        debugLog((_e = this.settings.debugMode) != null ? _e : false, "warn", "Failed to register test commands:", error);
      }
    }
    debugLog((_f = this.settings.debugMode) != null ? _f : false, "info", "AI Assistant Plugin loaded.");
  }
  /**
   * Enhanced debug logger for the plugin.
   * @param level Log level: 'debug' | 'info' | 'warn' | 'error'. Defaults to 'debug'.
   * @param args Arguments to log.
   */
  debugLog(level = "debug", ...args) {
    var _a2;
    debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
  }
  /**
   * Loads plugin settings from data.
   * Merges loaded data with default settings with runtime validation.
   */
  async loadSettings() {
    var _a2;
    try {
      const loadedData = await this.loadData();
      if (loadedData !== null && loadedData !== void 0) {
        const validatedData = validatePluginSettings(loadedData);
        this.settings = Object.assign({}, DEFAULT_SETTINGS, validatedData);
      } else {
        this.settings = Object.assign({}, DEFAULT_SETTINGS);
      }
      debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, "info", "[main.ts] Settings loaded and validated successfully");
    } catch (error) {
      debugLog(true, "error", "[main.ts] Failed to load settings, using defaults:", error);
      this.settings = Object.assign({}, DEFAULT_SETTINGS);
    }
  }
  /**
   * Saves plugin settings to data.
   * Also re-registers YAML attribute commands and emits a settings change event.
   */
  async saveSettings() {
    await this.saveData(this.settings);
    this._yamlAttributeCommandIds = registerYamlAttributeCommands(
      this,
      this.settings,
      (messages) => this.processMessages(messages),
      this._yamlAttributeCommandIds,
      (level, ...args) => {
        var _a2;
        return debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, level, ...args);
      }
      // Changed from log to debugLog
    );
    this.emitSettingsChange();
  }
  /**
   * Processes an array of messages, potentially adding context notes.
   * @param messages The messages to process.
   * @returns A promise that resolves to the processed messages.
   */
  async processMessages(messages) {
    return processMessages(messages, this.app, this.settings);
  }
  /**
   * Called when the plugin is unloaded.
   * Unregisters views to prevent issues on reload.
   */
  onunload() {
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_MODEL_SETTINGS);
    _MyPlugin.registeredViewTypes.delete(VIEW_TYPE_CHAT);
    if (this.priority3Manager) {
      this.priority3Manager.dispose();
    }
    if (this.recentlyOpenedFilesManager) {
      this.recentlyOpenedFilesManager.destroy();
    }
    MessageContextPool.getInstance().clear();
    PreAllocatedArrays.getInstance().clear();
  }
  /**
   * Process ai-tool-execution code blocks specifically for Live Preview mode
   * @param source The code block source string (should be JSON)
   * @param element The HTML element to render into
   * @param context The Obsidian context object
   */
  processToolExecutionCodeBlock(source, element, context) {
    try {
      const toolData = JSON.parse(source);
      ToolRichDisplay.renderToolExecutionBlock(toolData, element, async (resultText) => {
        try {
          await navigator.clipboard.writeText(resultText);
          showNotice("Copied to clipboard!");
        } catch (error) {
          console.error("Failed to copy to clipboard:", error);
          showNotice("Failed to copy to clipboard");
        }
      });
    } catch (error) {
      console.error("Failed to parse ai-tool-execution code block:", error);
      this.debugLog("error", "[main.ts] Failed to parse ai-tool-execution code block", { error });
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.textContent = source;
      pre.appendChild(code);
      element.innerHTML = "";
      element.appendChild(pre);
    }
  }
  /**
   * Process ai-tool-execution blocks in markdown and replace them with rich tool displays
   * @param element The root HTML element containing markdown content
   * @param context The Obsidian context object
   */
  processToolExecutionBlocks(element, context) {
    var _a2;
    const codeBlocks = element.querySelectorAll("pre > code");
    for (const codeBlock of Array.from(codeBlocks)) {
      const codeElement = codeBlock;
      const preElement = codeElement.parentElement;
      const text = ((_a2 = codeElement.textContent) == null ? void 0 : _a2.trim()) || "";
      const isAIToolExecution = codeElement.className.includes("language-ai-tool-execution") || text.startsWith('{"toolResults"');
      if (isAIToolExecution) {
        try {
          const toolData = JSON.parse(text);
          const toolContainer = document.createElement("div");
          toolContainer.className = "ai-tool-execution-container";
          ToolRichDisplay.renderToolExecutionBlock(toolData, toolContainer, async (resultText) => {
            try {
              await navigator.clipboard.writeText(resultText);
              showNotice("Copied to clipboard!");
            } catch (error) {
              console.error("Failed to copy to clipboard:", error);
              showNotice("Failed to copy to clipboard");
            }
          });
          preElement.replaceWith(toolContainer);
        } catch (error) {
          console.error("Failed to parse ai-tool-execution block:", error);
          this.debugLog("error", "[main.ts] Failed to parse ai-tool-execution block", { error });
        }
      }
    }
  }
  /**
   * Check if there are any active AI streams.
   * @returns True if there are active streams, false otherwise.
   */
  hasActiveAIStreams() {
    if (this.activeStream) {
      return true;
    }
    if (this.aiDispatcher && this.aiDispatcher.hasActiveStreams()) {
      return true;
    }
    return false;
  }
  /**
   * Stop all active AI streams across the plugin.
   * This includes streams from chat, editor completions, and agent mode.
   */
  stopAllAIStreams() {
    var _a2;
    if (this.activeStream) {
      this.activeStream.abort();
      this.activeStream = null;
    }
    if (this.aiDispatcher) {
      this.aiDispatcher.abortAllStreams();
    }
    debugLog((_a2 = this.settings.debugMode) != null ? _a2 : false, "info", "[MyPlugin] All AI streams stopped");
  }
  /**
   * Debug method to get information about active streams.
   */
  getStreamDebugInfo() {
    const info = [];
    if (this.activeStream) {
      info.push("Main plugin activeStream: active");
    } else {
      info.push("Main plugin activeStream: null");
    }
    if (this.aiDispatcher) {
      const count = this.aiDispatcher.getActiveStreamCount();
      info.push(`AIDispatcher streams: ${count}`);
    } else {
      info.push("AIDispatcher: not initialized");
    }
    const chatLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CHAT);
    info.push(`Chat views: ${chatLeaves.length}`);
    chatLeaves.forEach((leaf, index) => {
      const chatView = leaf.view;
      if (chatView && typeof chatView.hasActiveStream === "function") {
        const hasStream = chatView.hasActiveStream();
        info.push(`  Chat view ${index}: ${hasStream ? "has stream" : "no stream"}`);
      }
    });
    return info.join("\n");
  }
  /**
   * Test Priority 3 optimizations to demonstrate their functionality.
   */
  async testPriority3Optimizations() {
    try {
      if (!this.priority3Manager) {
        showNotice("Priority 3 optimizations not initialized");
        return;
      }
      const status = this.priority3Manager.getStatus();
      const { ServiceLocator: ServiceLocator2 } = await Promise.resolve().then(() => (init_dependencyInjection(), dependencyInjection_exports));
      const { globalStateManager: globalStateManager2 } = await Promise.resolve().then(() => (init_stateManager(), stateManager_exports));
      const { globalStreamManager: globalStreamManager2, StreamUtils: StreamUtils2 } = await Promise.resolve().then(() => (init_streamManager(), streamManager_exports));
      console.log("\u{1F527} Testing Dependency Injection...");
      const stateManager = ServiceLocator2.resolve("stateManager");
      const streamManager = ServiceLocator2.resolve("streamManager");
      console.log("\u2705 Services resolved successfully");
      console.log("\u{1F4CA} Testing State Management...");
      globalStateManager2.setState("test.priority3.demo", {
        timestamp: Date.now(),
        message: "Priority 3 optimizations are working!",
        features: ["dependency-injection", "state-management", "stream-management"]
      }, { persistent: true });
      const testData = globalStateManager2.getState("test.priority3.demo");
      console.log("\u2705 State set and retrieved:", testData);
      console.log("\u{1F30A} Testing Stream Management...");
      const testStream = globalStreamManager2.createStream(
        "priority3-test",
        StreamUtils2.fromArray(["Hello", " ", "Priority", " ", "3", " ", "Optimizations!"]),
        { timeout: 1e4 }
      );
      let streamResult = "";
      testStream.on("data", (chunk) => {
        streamResult += chunk;
      });
      testStream.on("end", () => {
        console.log("\u2705 Stream completed:", streamResult);
        showNotice(`Priority 3 Test Complete! Check console for details. Status: ${status.services.length} services, ${status.stateKeys} state keys, ${status.activeStreams} active streams`);
      });
      await testStream.start();
      console.log("\u{1F4C8} Priority 3 Status:", status);
      console.log("\u{1F3AF} All Priority 3 optimizations tested successfully!");
    } catch (error) {
      console.error("\u274C Priority 3 test failed:", error);
      showNotice("Priority 3 test failed - check console for details");
    }
  }
};
/**
 * Static set to track registered view types and avoid duplicate registration.
 */
__publicField(_MyPlugin, "registeredViewTypes", /* @__PURE__ */ new Set());
var MyPlugin = _MyPlugin;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
